<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" 
	>
<channel>
	<title>Comments on: Le pattern observer en utilisant des décorateurs</title>
	<atom:link href="http://sametmax.com/le-pattern-observer-en-utilisant-des-decorateurs/feed/" rel="self" type="application/rss+xml" />
	<link>http://sametmax.com/le-pattern-observer-en-utilisant-des-decorateurs/</link>
	<description>Du code, du cul</description>
	<lastBuildDate>Fri, 06 Sep 2019 09:34:15 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.7</generator>
	<item>
		<title>By: Sam</title>
		<link>http://sametmax.com/le-pattern-observer-en-utilisant-des-decorateurs/#comment-3456</link>
		<dc:creator><![CDATA[Sam]]></dc:creator>
		<pubDate>Fri, 23 Nov 2012 03:04:18 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=2591#comment-3456</guid>
		<description><![CDATA[Oui, mais avec le &lt;a href=&quot;http://blip.tv/carlfk/mindblowing-python-gil-2243379&quot; rel=&quot;nofollow&quot;&gt;GIL&lt;/a&gt;, on n&#039;a pas d&#039;options non bloquantes valables en Python, c&#039;est une des limitations du langage.

Il n&#039;existe pas de possibilité de faire quelque chose de complètement asynchrones, même en utilisant des threads. Au mieux on peut faire:

- des threads / des coroutines qui au moins évitent de bloquer les IO.
- utiliser le module &lt;a href=&quot;http://sametmax.com/remplacer-les-threads-avec-le-module-multiprocessing-en-python/&quot; rel=&quot;nofollow&quot;&gt;multiprocessing&lt;/a&gt;, mais ça veut dire créer un process pour chaque trigger.

Et dans tous les cas, ça veut dire des races conditions possibles sur les ressources partagées.

Bref, si on veut vraiment un truc asynchrone en Python (c&#039;est rare, mais ça arrive), on doit se tourner vers des frameworks types twisted ou tornado, qui eux implémente le truc en C derrière.]]></description>
		<content:encoded><![CDATA[<p>Oui, mais avec le <a href="http://blip.tv/carlfk/mindblowing-python-gil-2243379" rel="nofollow">GIL</a>, on n&#8217;a pas d&#8217;options non bloquantes valables en Python, c&#8217;est une des limitations du langage.</p>
<p>Il n&#8217;existe pas de possibilité de faire quelque chose de complètement asynchrones, même en utilisant des threads. Au mieux on peut faire:</p>
<p>&#8211; des threads / des coroutines qui au moins évitent de bloquer les IO.<br />
&#8211; utiliser le module <a href="http://sametmax.com/remplacer-les-threads-avec-le-module-multiprocessing-en-python/" rel="nofollow">multiprocessing</a>, mais ça veut dire créer un process pour chaque trigger.</p>
<p>Et dans tous les cas, ça veut dire des races conditions possibles sur les ressources partagées.</p>
<p>Bref, si on veut vraiment un truc asynchrone en Python (c&#8217;est rare, mais ça arrive), on doit se tourner vers des frameworks types twisted ou tornado, qui eux implémente le truc en C derrière.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: anthony</title>
		<link>http://sametmax.com/le-pattern-observer-en-utilisant-des-decorateurs/#comment-3454</link>
		<dc:creator><![CDATA[anthony]]></dc:creator>
		<pubDate>Fri, 23 Nov 2012 02:29:10 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=2591#comment-3454</guid>
		<description><![CDATA[Si je me trompe pas implémenté comme ça c&#039;est bloquant, e.g. j&#039;ai une seule fonction abonnée à &#039;evenement1&#039;, si je trigger deux fois de suite cet l&#039;event

evenement.trigger(&#039;evenement1&#039;)
evenement.trigger(&#039;evenement1&#039;)

Et que la fonction abonnée bloque:

@evenement(&#039;evenement1&#039;)
def reagir_a_evenement(evenement):
    print &quot;Oh, evenement &#039;%s&#039; a eu lieu&quot; % evenement
    time.sleep(60)
	
Je verrai les 2 prints à 1min d&#039;interval. Quelle serait la bonne solution pour faire qqch de complètement asynchrone ? Utiliser dans le décorateur evenement une thread pour lancer la fonction ?]]></description>
		<content:encoded><![CDATA[<p>Si je me trompe pas implémenté comme ça c&#8217;est bloquant, e.g. j&#8217;ai une seule fonction abonnée à &#8216;evenement1&#8217;, si je trigger deux fois de suite cet l&#8217;event</p>
<p>evenement.trigger(&#8216;evenement1&#8217;)<br />
evenement.trigger(&#8216;evenement1&#8217;)</p>
<p>Et que la fonction abonnée bloque:</p>
<p>@evenement(&#8216;evenement1&#8217;)<br />
def reagir_a_evenement(evenement):<br />
    print &#8220;Oh, evenement &#8216;%s&#8217; a eu lieu&#8221; % evenement<br />
    time.sleep(60)</p>
<p>Je verrai les 2 prints à 1min d&#8217;interval. Quelle serait la bonne solution pour faire qqch de complètement asynchrone ? Utiliser dans le décorateur evenement une thread pour lancer la fonction ?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sam</title>
		<link>http://sametmax.com/le-pattern-observer-en-utilisant-des-decorateurs/#comment-2470</link>
		<dc:creator><![CDATA[Sam]]></dc:creator>
		<pubDate>Mon, 15 Oct 2012 15:06:53 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=2591#comment-2470</guid>
		<description><![CDATA[^^]]></description>
		<content:encoded><![CDATA[<p>^^</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Recher</title>
		<link>http://sametmax.com/le-pattern-observer-en-utilisant-des-decorateurs/#comment-2469</link>
		<dc:creator><![CDATA[Recher]]></dc:creator>
		<pubDate>Mon, 15 Oct 2012 13:35:36 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=2591#comment-2469</guid>
		<description><![CDATA[C&#039;est très chouette.

Dans le cas où vous voudriez mon opinion personnelle que j&#039;ai, je vous dirais que je trouve cette ligne là :
&lt;pre lang=&quot;python&quot;&gt;evenement.abonnements = getattr(evenement, &#039;abonnements&#039;, {})&lt;/pre&gt;
un peu bourrine et pas super compréhensible.

Si j&#039;ai bien tout compris, le but, c&#039;est d&#039;initialiser l&#039;attribut &quot;abonnements&quot; à un dictionnaire vide, dans le cas où il n&#039;existe pas encore. Si il existe, on le laisse comme il est.

Si l&#039;attribut existe déjà, ça revient à faire ça : 

&lt;pre lang=&quot;python&quot;&gt;evenement.abonnements = getattr(evenement, &#039;abonnements&#039;)&lt;/pre&gt;

Ce qui revient à faire ça :

&lt;pre lang=&quot;python&quot;&gt;evenement.abonnements = evenement.abonnements&lt;/pre&gt;

On affecte l&#039;objet à lui-même.
Ca ne dérange absolument pas le python de faire quelque chose de ce genre. Mais ça dérange l&#039;humain qui lit le code. Il risque de se dire : &quot;WTF ? C&#039;est quoi l&#039;intérêt ?&quot;. (Alors que le vrai intérêt de cette ligne se trouve uniquement dans le cas où l&#039;attribut n&#039;existe pas).

Bref, moi je propose ça. C&#039;est en deux lignes, mais ça me semble plus clair.

&lt;pre lang=&quot;python&quot;&gt;if not hasattr(evenement, &#039;abonnements&#039;):
    evenement.abonnements = {}&lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>C&#8217;est très chouette.</p>
<p>Dans le cas où vous voudriez mon opinion personnelle que j&#8217;ai, je vous dirais que je trouve cette ligne là :</p>
<pre lang="python">evenement.abonnements = getattr(evenement, 'abonnements', {})</pre>
<p>un peu bourrine et pas super compréhensible.</p>
<p>Si j&#8217;ai bien tout compris, le but, c&#8217;est d&#8217;initialiser l&#8217;attribut &#8220;abonnements&#8221; à un dictionnaire vide, dans le cas où il n&#8217;existe pas encore. Si il existe, on le laisse comme il est.</p>
<p>Si l&#8217;attribut existe déjà, ça revient à faire ça : </p>
<pre lang="python">evenement.abonnements = getattr(evenement, 'abonnements')</pre>
<p>Ce qui revient à faire ça :</p>
<pre lang="python">evenement.abonnements = evenement.abonnements</pre>
<p>On affecte l&#8217;objet à lui-même.<br />
Ca ne dérange absolument pas le python de faire quelque chose de ce genre. Mais ça dérange l&#8217;humain qui lit le code. Il risque de se dire : &#8220;WTF ? C&#8217;est quoi l&#8217;intérêt ?&#8221;. (Alors que le vrai intérêt de cette ligne se trouve uniquement dans le cas où l&#8217;attribut n&#8217;existe pas).</p>
<p>Bref, moi je propose ça. C&#8217;est en deux lignes, mais ça me semble plus clair.</p>
<pre lang="python">if not hasattr(evenement, 'abonnements'):
    evenement.abonnements = {}</pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sam</title>
		<link>http://sametmax.com/le-pattern-observer-en-utilisant-des-decorateurs/#comment-2462</link>
		<dc:creator><![CDATA[Sam]]></dc:creator>
		<pubDate>Sun, 14 Oct 2012 17:15:08 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=2591#comment-2462</guid>
		<description><![CDATA[@DSeed: oui, exactement.

@Soli: Il faut apprendre à ne pas mettre ce genre d&#039;informations dans un exemple pédagogique. On parle de wraps dans le tutos sur les décorateurs, ici la notion expliquée est le pattern observer. Top d&#039;info rend les explications confuses.]]></description>
		<content:encoded><![CDATA[<p>@DSeed: oui, exactement.</p>
<p>@Soli: Il faut apprendre à ne pas mettre ce genre d&#8217;informations dans un exemple pédagogique. On parle de wraps dans le tutos sur les décorateurs, ici la notion expliquée est le pattern observer. Top d&#8217;info rend les explications confuses.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Soli</title>
		<link>http://sametmax.com/le-pattern-observer-en-utilisant-des-decorateurs/#comment-2461</link>
		<dc:creator><![CDATA[Soli]]></dc:creator>
		<pubDate>Sun, 14 Oct 2012 17:12:42 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=2591#comment-2461</guid>
		<description><![CDATA[Et en général, pour faciliter le débogage notamment, on n&#039;hésitera pas à utiliser http://docs.python.org/library/functools.html#functools.wraps pour conserver/rétablir le nom de la fonction « enveloppée ».]]></description>
		<content:encoded><![CDATA[<p>Et en général, pour faciliter le débogage notamment, on n&#8217;hésitera pas à utiliser <a href="http://docs.python.org/library/functools.html#functools.wraps" rel="nofollow">http://docs.python.org/library/functools.html#functools.wraps</a> pour conserver/rétablir le nom de la fonction « enveloppée ».</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: DSeed</title>
		<link>http://sametmax.com/le-pattern-observer-en-utilisant-des-decorateurs/#comment-2460</link>
		<dc:creator><![CDATA[DSeed]]></dc:creator>
		<pubDate>Sun, 14 Oct 2012 16:07:41 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=2591#comment-2460</guid>
		<description><![CDATA[Les signaux de django font pas la mm chose ? A part que les receivers sont des décorateurs (sans doute plus de liberté ... )]]></description>
		<content:encoded><![CDATA[<p>Les signaux de django font pas la mm chose ? A part que les receivers sont des décorateurs (sans doute plus de liberté &#8230; )</p>
]]></content:encoded>
	</item>
</channel>
</rss>
