<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" >

<channel>
	<title>crossbar &#8211; Sam &amp; Max</title>
	<atom:link href="http://sametmax.com/tag/crossbar/feed/" rel="self" type="application/rss+xml" />
	<link>http://sametmax.com</link>
	<description>Du code, du cul</description>
	<lastBuildDate>Thu, 05 Sep 2019 08:22:03 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.7</generator>
<site xmlns="com-wordpress:feed-additions:1">32490438</site>	<item>
		<title>Nouvelle release de crossbar: historique des events et crypto</title>
		<link>http://sametmax.com/nouvelle-release-de-crossbar-historique-des-events-et-crypto/</link>
		<comments>http://sametmax.com/nouvelle-release-de-crossbar-historique-des-events-et-crypto/#comments</comments>
		<pubDate>Sun, 31 Jan 2016 18:25:33 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[crossbar]]></category>
		<category><![CDATA[crypto]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[wamp]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=18018</guid>
		<description><![CDATA[Je dois toujours un article sur Polymer + Crossbar à Tavendo. Et il faut que je fasse un tuto sur l'authentification également. 

Fichtre.

En attendant, je vais en profiter pour faire un article vite fait sur la release, puisque <a href="http://sametmax.com/crossbar-le-futur-des-applications-web-python/">Crossbar</a>, le routeur WAMP, <a href="https://groups.google.com/forum/#!topic/autobahnws/R86_F8jd17s">passe en 0.12</a>.]]></description>
				<content:encoded><![CDATA[<p>Je suis méga à la bourre. Entre <a href="https://github.com/sametmax/0bin/">les tickets github qui s’accumulent</a>, <a href="http://sametmax.com/un-petit-dashboard-de-monitoring-avec-django-et-wamp/#comment-174036">les comments auxquels j’ai toujours pas répondu</a> et <a href="http://sametmax.com/129-drafts/">la liste d’articles à écrire</a> qui augmente au lieu de diminuer (mais comment, bordel, comment ?), j’ai vraiment du mal à suivre.</p>
<p>Je dois toujours un article sur Polymer + Crossbar à Tavendo. Et il faut que je fasse un tuto sur l’authentification également (en attendant, <a href="https://github.com/crossbario/crossbarexamples/tree/master/authentication">y a des exemples plus à jour</a>). </p>
<p>Fichtre.</p>
<p>En attendant, je vais en profiter pour faire un article vite fait sur la dernière release, puisque <a href="http://sametmax.com/crossbar-le-futur-des-applications-web-python/">Crossbar</a>, le routeur WAMP, <a href="https://groups.google.com/forum/#!topic/autobahnws/R86_F8jd17s">passe en 0.12</a>.</p>
<p>Comme d’hab, correction de bugs, amélioration du support de Python 3, plus de docs et d’exemples, blablabla&#8230;</p>
<p>Mais ce qui est vraiment intéressant, <a href="https://github.com/crossbario/crossbarexamples/tree/master/event-history">c’est l’historique des évènements</a>. </p>
<p>Normalement un évènement est éphémère, dans le sens où une fois qu’il a été propagé, vous ne pouvez plus le recevoir. Si vous arrivez après la fête, c’est terminé.</p>
<p>C’est un problème, par exemple si vous redémarrez un client qui a besoin de ces évènements. Ou si vous implémentez un client qui veut savoir ce qui vient de se passer avant de se pointer, comme dans le cas d’un chat : on veut avoir les derniers messages postés.</p>
<p>Par défaut, l’historique n’est pas activé, puisqu’il y un coût pour chaque pub/sub. On doit explicitement le demander pour chaque event dans le fichier de config :</p>
<pre lang="javascript">{
   "name": "realm1",
   "roles": [
   ],
   "store": {
      "type": "memory", # ou stocker l'historique
      "event-history": [
         {
            "uri": "mon.uri.pour.un.event", # quel type event
            "limit": 10000 # combien d’events stocker
         }
      ]
   }
}</pre>
<p><code>type</code> n’accepte pour le moment que <code>memory</code>, qui est une simple liste en mémoire dans crossbar, et bouffe donc de la RAM. On perd aussi l’historique au redémarrage du routeur, mais ça a l’avantage d’être très rapide.</p>
<p>Pour la prochaine version, Tavendo va implémenter un stockage dans une base <code>lmdb</code> et si ils font une belle API, on peut s’attendre à voir fleurir des backends pour SQLAlchemy, Django, Redis, etc.</p>
<p><code>event-history</code> prend un liste d’events (les URIs peuvent utiliser <a href="http://sametmax.com/pendant-ce-temps-a-vera-cruz/">les jokers introduits dans la version précédente</a>), on met la limite du nombre total d’events à stocker pour cet URI en particulier.</p>
<p>Pour profiter de l’historique côté client, il faut obligatoirement avoir un abonnement à un event dont les messages sont sauvegardés. On ne peut pas récupérer l’historique de messages auxquels on n&#8217;est pas abonnés : forcer l’abonnement oblige en effet le client à passer le check des permissions.</p>
<p>Par exemple, en JS, d’abord on s’inscrit:</p>
<pre lang="python">var promise = session.subscribe('mon.uri.pour.un.event',
   function (args, kwargs, details) {
      // bon là vous faites bien ce que vous voulez avec les nouveaux events
      //, car ça n’a rien à voir avec l’historique
   }
)</pre>
<p>Puis on demande les events:</p>
<pre lang="python">promise = promise.then(function (sub) {
      // L’abonnement retourne un objet "subcription" qui possède l’id
      // dont on a besoin pour demander l’historique des events.
      // On fait un petit RPC sur la meta API 'wamp.subscription.get_events'
      // qui demande aux routeurs tous les X derniers events qui matchent
      // notre abo. Ici x = 10
      return session.call('wamp.subscription.get_events', [sub.id, 10]);
)</pre>
<p>Et enfin, on a droit à l’histo:</p>
<pre lang="python">promise.then(function (history) {
    console.log(history.length, " events:");
    history.forEach(function(event){
        console.log(event.timestamp, event.publication, event.args[0]);
    })
 });</pre>
<p> En Python, le code pour récupérer l’histo est logiquement:</p>
<pre lang="python">import asyncio
from autobahn.asyncio.wamp import ApplicationSession, ApplicationRunner


class Component(ApplicationSession):

    async def onJoin(self, details):


        def on_event(i):
            print("Got: {}".format(i))

        # pareil on chope la souscription
        sub = await self.subscribe(on_event, u'mon.uri.pour.un.event')
        # et on demande la liste des 10 derniers events pour cet abo
        events = await self.call('wamp.subscription.get_events', sub.id, 10)
        # et on boucle. Et on kiff await parceque putain c’est pratique.
        for event in events:
            print(event['timestamp'], event['publication'], event['args'][0])

    def onDisconnect(self):
        asyncio.get_event_loop().stop()


if __name__ == '__main__':
    runner = ApplicationRunner("ws://127.0.0.1:8080/ws", 'realm1')
    runner.run(Component)</pre>
<p>L’autre point phare de cette release, c’est la dépréciation de Mozilla Persona comme méthode d’authentification (le projet est dead) et la promotion de deux nouvelles méthodes: les certificats TLS et les paires de clés publiques/privées (Curve25519 pour le moment).</p>
<p>C’est une très bonne nouvelle, car ça veut dire plus de mots de passe dans les fichiers de configuration en production pour identifier vos propres clients qui ont forcément des privilèges supplémentaires.</p>
<p>Je reviendrais là dessus en faisant le tuto sur l’authentification.</p>
<p> Une release chouette donc. Mais qui introduit plein de dépendances à des extensions en C qui pourraient être optionnelles, ce qui rend l’installation plus compliquée. Je suis en train de discuter avec la team pour voir si on peut arranger ça, mais Tobias à l’air plutôt pour les garder. Si vous aussi vous voulez garder la simplicité de la base pure Python, <a href="https://github.com/crossbario/crossbar/issues/626">rejoignez la discussion</a>.</p>
<p> Enfin, on a pu voir l’annonce d’une feature très intéressante : le chiffrement end-to-end des messages WAMP. Ça, c’est chouette. C’est pas encore implémenté, mais ça veut dire que la prochaine release, vous pourrez probablement envoyer des messages à travers le serveur WAMP sans que celui-ci puisse les lire. </p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/nouvelle-release-de-crossbar-historique-des-events-et-crypto/feed/</wfw:commentRss>
		<slash:comments>8</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">18018</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2016/01/z9EVG1X.jpg" length="36840" type="image/jpg" />	</item>
		<item>
		<title>Nouvelle release de crossbar : support de Python 3 !</title>
		<link>http://sametmax.com/nouvelle-release-de-crossbar-support-de-python-3/</link>
		<comments>http://sametmax.com/nouvelle-release-de-crossbar-support-de-python-3/#comments</comments>
		<pubDate>Wed, 09 Sep 2015 15:13:22 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[crossbar]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[wamp]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=16908</guid>
		<description><![CDATA[L'équipe de Tavendo est à l'écoute de toutes les critiques de Crossbar et <a href="http://sametmax.com/presentation-de-wamp-round-2/">WAMP</a> en général, et je me suis fais un plaisir de leur rapporter toutes les merdes donc vous m'avez fait part.]]></description>
				<content:encoded><![CDATA[<p>L’équipe de Tavendo est à l’écoute de toutes les critiques de <a href="https://crossbar.io/">Crossbar</a> et <a href="http://sametmax.com/presentation-de-wamp-round-2/">WAMP</a> en général, et je me suis fait un plaisir de leur rapporter toutes les merdes dont vous m’avez fait part.</p>
<p>Cette <a href="https://groups.google.com/forum/#!topic/autobahnws/VvSM_mEQ0c0">nouvelle release</a> contient beaucoup de choses qui corrigent ou pallient un paquet de trucs relou dans le routeur Crossbar (et par conséquent la lib client Autobahn) :</p>
<ul>
<li>Support officiel de Python 3. Yes. Yes, yes yes !</li>
<li>Le debug a été complètement revu : meilleure console, meilleur login, meilleurs messages d’erreur et meilleur comportement en cas d’exceptions.</li>
<li>Un service dédié à l’upload de fichier intégré.</li>
<li>Un bridge HTTP complet qui permet d’utiliser Crossbar depuis n’importe quelle app qui peut faire des requêtes HTTP.</li>
</ul>
<p>Pour la suite, ils travaillent sur la doc, et l’amélioration de l’API. En attendant, on peut <code>pip install crossbar</code> et profiter de ces nouveautés sans avoir à passer par github.</p>
<p>De mon côté j&#8217;ai un article sur l&#8217;authentification avec Crossbar dans les cartons. ETA dans les 10 prochains jours.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/nouvelle-release-de-crossbar-support-de-python-3/feed/</wfw:commentRss>
		<slash:comments>18</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">16908</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2015/09/rXRWFB0.jpg" length="292725" type="image/jpg" />	</item>
		<item>
		<title>Today is a glorious day</title>
		<link>http://sametmax.com/today-is-a-glorious-day/</link>
		<comments>http://sametmax.com/today-is-a-glorious-day/#comments</comments>
		<pubDate>Sun, 12 Jul 2015 21:29:59 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[crossbar]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[python 3]]></category>
		<category><![CDATA[twisted]]></category>
		<category><![CDATA[wamp]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=16600</guid>
		<description><![CDATA[pip install crossbar]]></description>
				<content:encoded><![CDATA[<pre lang="python">>>> import crossbar
>>> crossbar.__version__
'0.10.4'
>>> import twisted
>>> twisted.__version__
'15.2.1'
>>> import sys
>>> print('Wait for it...')
Wait for it...
>>> sys.version
'3.4.0 (default, Apr 11 2014, 13:05:11) \n[GCC 4.8.2]'
</pre>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/today-is-a-glorious-day/feed/</wfw:commentRss>
		<slash:comments>15</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">16600</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2015/07/T5C15Zm.gif" length="996010" type="image/jpg" />	</item>
		<item>
		<title>Pendant ce temps, à Vera Cruz</title>
		<link>http://sametmax.com/pendant-ce-temps-a-vera-cruz/</link>
		<comments>http://sametmax.com/pendant-ce-temps-a-vera-cruz/#comments</comments>
		<pubDate>Sun, 10 May 2015 09:29:24 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[autobahn]]></category>
		<category><![CDATA[crossbar]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[wamp]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=16198</guid>
		<description><![CDATA[Pour une fois, ce n&#8217;est pas un article payé par Tavendo, mais bien un truc que je ponds par enthousiasme :) Pendant qu&#8217;on en parle pas, la stack WAMP continue d&#8217;évoluer, des mises à jours significatives ayant été apportées à Crossbar.io, ainsi qu&#8217;aux libs Python et JS d&#8217;autobahn. Parmi les plus intéressantes : Le code [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>Pour une fois, ce n&#8217;est pas un article payé par Tavendo, mais bien un truc que je ponds par enthousiasme :)</p>
<p>Pendant qu&#8217;on en parle pas, la stack WAMP continue d&#8217;évoluer, des mises à jours significatives ayant été apportées à Crossbar.io, ainsi qu&#8217;aux libs Python et JS d&#8217;autobahn. Parmi les plus intéressantes :</p>
<ul>
<li>Le code passe de la licence Apache 2 à la licence MIT, augmentant la compatibilité avec un tas d&#8217;autres licences.</li>
<li>On peut faire un SUB avec un joker, et donc lier un seul callback à plusieurs événements.</li>
<li>On peut faire un register avec un joker également.</li>
<li>On peut choisir la stratégie à appliquer si plusieurs registers sont faits sur le même nom.</li>
<li>Une meta API permet d&#8217;être prévenu quand un client fait quelque chose ou de demander l&#8217;état des nœuds en cours.</li>
</ul>
<p>Inutile de dire que c&#8217;est trop cool.</p>
<p>Pour profiter de tout ça, il suffit de faire :</p>
<pre lang="bash">pip install crossbar autobahn --upgrade</pre>
<p>Et de télécharger la nouvelle version de la <a href="https://autobahn.s3.amazonaws.com/autobahnjs/latest/autobahn.min.jgz">dernière version</a> de la lib JS.</p>
<h2>Licence MIT</h2>
<p>Auparavant le travail de Tavendo était essentiellement sous Licence Apache. Une licence libre, certes, mais qui pouvait poser problème quand on mélangeait tout ça avec d&#8217;autres licences (par exemple, elle n&#8217;est pas compatible avec la GPL2). Avec la version 0.10, le code est maintenant sous licence MIT, beaucoup plus permissive.</p>
<h2>Joker pour les subs</h2>
<p>Supposez que vous faites un système de jeu d&#8217;échec donc chaque coup déclenche un événement &#8220;chess.game.[id_de_partie]&#8221;. C&#8217;est pratique, car seuls les clients intéressés à cette partie vont recevoir les événements. Mais si votre serveur doit enregistrer un log de tous les coups d&#8217;une partie, il faut que chaque client envoie AUSSI les coups au serveur explicitement.</p>
<p>C&#8217;était en tout cas vrai avant cette mise à jour, puisque maintenant on peut spécifier <a href="http://crossbar.io/docs/Pattern-Based-Subscriptions/">des jokers</a> dans les noms des topics au moment de l&#8217;abonnement.</p>
<p>Essentiellement il y a deux modes.</p>
<p>Le mode &#8220;prefix&#8221;, qui match tous les events qui commencent par ce nom :</p>
<pre lang="javascript">session.subscribe("debut.du.nom.du.topic", callback, { match: "prefix" });
# matchera debut.du.nom.du.topic.genial et debut.du.nom.du.topic.trop.cool</pre>
<p>Et le mode &#8220;wildcard&#8221; qui permet, un peu comme les glob Unix (mais on utilise &#8220;..&#8221; au lieu de &#8220;*&#8221;&#8221;), de faire un texte à trou :</p>
<pre lang="javascript">session.subscribe("nom.du.topic..general", callback, { match: "wildcard" });
# matchera "nom.du.topic.moins.general" et "nom.du.topic.oui.mon.general"</pre>
<p>Tous les callbacks qui matchent un topic seront appelés.</p>
<h2>Plusieurs clients pour la même procédure</h2>
<p>On peut utiliser le même principe que pour les sub avec joker, mais pour les procédures.</p>
<pre lang="javascript">session.register("debut.du.nom.de.la.procedure", callback, { match: "prefix" });    
session.register("nom.de.la.procedure..generale", callback, { match: "wildcard" });</pre>
<p>La différence avec le subscribe, c&#8217;est que seule UNE procédure est appelée. Dans les cas simples, un match exact prend le dessus sur un prefix (et le plus long prefix gagne toujours), qui prend le dessus sur un wildcard. Crossbar n&#8217;implemente pas encore de résolution pour deux wildcards en conflits, et je ne sais pas ce qu&#8217;il fait dans ce cas.</p>
<p>Il est aussi possible de <a href="http://crossbar.io/docs/Shared-Registrations/">de définir des règles</a> d&#8217;appels en faisant :</p>
<pre lang="javascript">session.register("nom.de.la.procedure..generale", procedure1, { invoke: "regle"});</pre>
<p>La règle peut être :</p>
<ul>
<li><strong>roundrobin</strong>: on prend la liste de clients, on regarde le dernier appelé, et on utilise le suivant.</li>
<li><strong>random</strong>: on prend un client au hasard.</li>
<li><strong>last</strong>: on prend le dernier client ajouté de la liste.</li>
<li><strong>first</strong>: on prend premier client ajouté à la liste.</li>
</ul>
<p>&#8220;roundrobin&#8221; et &#8220;random&#8221; sont pratiques pour faire du load balancing.</p>
<p>&#8220;last&#8221; et &#8220;first&#8221; sont pratique pour les mises à jour d&#8217;un client sans arrêter le serveur. En gros on rajoute un client, on attend un peu, &#8220;last&#8221; route tout sur le dernier client, donc le nouveau client prend les requêtes, et on peut arrêter le vieux clients sans souci. </p>
<h2>Meta RPC</h2>
<p>Crossbar met automatiquement à notre disposition des procédures distantes toutes faites qui donnent des informations sur l&#8217;état des clients et du routeur. Voici les RPC que vous pouvez maintenant faire :</p>
<ul>
<li><strong>wamp.session.list</strong>: lister les sessions des clients connectés au routeur.</li>
<li><strong>wamp.session.get</strong>: obtenir les infos d&#8217;un session pour un ID en particulier.</li>
<li><strong>wamp.session.count</strong>: obtenir le nombre de client connectés.</li>
<li><strong>wamp.registration.lookup</strong>: absolument aucune idée.</li>
<li><strong>wamp.registration.get</strong>: obtenir des infos sur une procédure distante enregistrée.</li>
<li><strong>wamp.registration.list_callees</strong>: lister les clients ayant enregistré pour une procédure avec ce nom.</li>
<li><strong>wamp.registration.count_callees</strong>: compter les clients ayant enregistré une procédure avec ce nom.</li>
<li><strong>wamp.registration.list</strong>: lister toutes les procédures distantes disponibles.</li>
<li><strong>wamp.registration.remove_callee</strong>: virer un client de la liste de des clients enregistrés pour cet procédure.</li>
<li><strong>wamp.subscription.lookup</strong>: toujours aucune idée.</li>
<li><strong>wamp.subscription.get</strong>: récupérer des infos sur l&#8217;abonnement avec cet ID.</li>
<li><strong>wamp.subscription.list_subscribers</strong>: lister les clients qui sont abonnés à ce sujet.</li>
<li><strong>wamp.subscription.count_subscribers</strong>: compter les clients abonnés à ce sujet.</li>
<li><strong>wamp.subscription.match</strong>: aucune idée.</li>
<li><strong>wamp.subscription.list</strong>: lister tous les sujets d&#8217;abonnement disponibles.</li>
<li><strong>wamp.subscription.remove_subscriber</strong>: </li>
<p> virer un client de la liste des abonnés à ce sujet.</ul>
<p>En gros, si vous voulez faire une admin qui vous permet de killer certains client ou rechercher si des events existent, vous utilisez ça.</p>
<h2>Meta SUB</h2>
<p>De même, le routeur envoie maintenant des publications sur des sujets concernant le cycle son cycle de vie et celui des clients. On peut donc s&#8217;abonner à ces meta topic pour réagir à l&#8217;activité de son système :</p>
<ul>
<li><strong>wamp.session.on_join</strong> : un client s&#8217;est connecté au routeur.</li>
<li><strong>wamp.session.on_leave</strong> : un client s&#8217;est déconnecté du routeur.</li>
<li><strong>wamp.subscription.on_create</strong> : un nouveau topic existe.</li>
<li><strong>wamp.subscription.on_subscribe</strong> : un client s&#8217;est abonné à un topic.</li>
<li><strong>wamp.subscription.on_unsubscribe</strong> : un client s&#8217;est désabonné à un topic.</li>
<li><strong>wamp.subscription.on_delete</strong> : un topic est retiré de la liste des topics disponibles.</li>
<li><strong>wamp.registration.on_create</strong> : une procédure distante porte ce nom pour la première fois.</li>
<li><strong>wamp.registration.on_register</strong> : un client propose ajoute un callable pour ce nom de procédure distante..</li>
<li><strong>wamp.registration.on_unregister</strong> : un client retire son callable pour ce nom de procédure distante. </li>
<li><strong>wamp.registration.on_delete</strong> : le nom de cette procédure n&#8217;a plus aucun callable lié.</li>
<li><strong>wamp.schema.on_define</strong> : aucune idée.</li>
<li><strong>wamp.schema.on_undefine</strong> : kamolox. </li>
</ul>
<p>Ce genre de truc est idéal pour faire un petit outil de monitoring pour son archi et voir ce qui se passe en temps réel.</p>
<h2>Le HTTP bridge est complet</h2>
<p>Le <a href="http://crossbar.io/docs/HTTP-Bridge-Services/">bridge HTTP</a> propose maintenant PUB/SUB, et tout RPC. On peut donc maintenant utiliser crossbar depuis n&#8217;importe quel app qui peut faire du HTTP : flask, pyramid, ruby on rails, du PHP pur, wget en ligne de commande et tout le bordel. C&#8217;est plus verbeux, mais ça dépanne bien.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/pendant-ce-temps-a-vera-cruz/feed/</wfw:commentRss>
		<slash:comments>8</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">16198</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2015/05/uZyph09.gif" length="677811" type="image/jpg" />	</item>
		<item>
		<title>Les managers le détestent : faites tourner WAMP dans Django avec cette astuce insolite</title>
		<link>http://sametmax.com/les-managers-le-detestent-faites-tourner-wamp-dans-django-avec-cette-astuce-insolite/</link>
		<comments>http://sametmax.com/les-managers-le-detestent-faites-tourner-wamp-dans-django-avec-cette-astuce-insolite/#comments</comments>
		<pubDate>Sun, 04 Jan 2015 19:45:07 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[autobahn]]></category>
		<category><![CDATA[crochet]]></category>
		<category><![CDATA[crossbar]]></category>
		<category><![CDATA[django]]></category>
		<category><![CDATA[flask]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[twisted]]></category>
		<category><![CDATA[wamp]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=15665</guid>
		<description><![CDATA[On peut utiliser WAMP, <code>directement</code> dans Django.]]></description>
				<content:encoded><![CDATA[<p>Il existe une lib appelée <a href="https://pypi.python.org/pypi/crochet">crochet</a> qui permet de faire marcher des API de twisted entre deux bouts de code bloquants. Certes, ça ne marche qu&#8217;en 2.7 et c&#8217;est pas hyper performant, mais on peut faire des trucs mignons du genre cette démo qui <a href="https://github.com/tavendo/AutobahnPython/tree/master/examples/twisted/wamp/app/crochet/example1">mélange flask et WAMP</a>.</p>
<p>C&#8217;est du pur Python, pas de process externe à gérer, c&#8217;est presque simple.</p>
<p>Bref, si on veut utiliser WAMP avec une app synchrone comme flask, c&#8217;est un bon moyen de s&#8217;y mettre. On aura jamais des perfs fantastiques, mais on peut pusher vers le browser.</p>
<p>Du coup je me suis demandé si on pouvait faire ça avec Django.</p>
<p>Évidement, ça a été un peu plus compliqué car par défaut <code>runserver</code> lance plusieurs workers et fait un peu de magie avec les threads. Mais après un peu de bidouillage, ça marche !</p>
<p>On peut utiliser WAMP, <code>directement</code> dans Django.</p>
<h2>Suivez le guide</h2>
<p>D&#8217;abord, on installe tout le bouzin (python 2.7, souvenez-vous) :</p>
<pre lang="bash">pip install crossbar crochet django</pre>
<p>Il vous faudra un Django 1.7, le tout dernier, car il possède <a href="https://docs.djangoproject.com/en/dev/ref/applications/#django.apps.AppConfig.ready">une fonctionnalité</a> qui nous permet de lancer du code quand tout le framework est chargé.</p>
<p>Vous vous faites votre projet comme d&#8217;hab, et vous ouvrez le fichier de settings et au lieu de mettre votre app dans <code>INSTALLED_APPS</code>, vous rajoutez ça :</p>
<pre lang="python">INSTALLED_APPS = (
    '...',
    'votreapp.app.VotreAppConfig'
)</pre>
<p>Puis dans le module de votre app, vous créez un fichier app.py, qui va contenir ça:</p>
<pre lang="python"># -*- coding: utf-8 -*-

import crochet

from django.apps import AppConfig

# On charge l'objet contenant la session WAMP définie dans la vue
from votreapp.views import wapp

class VotreAppConfig(AppConfig):
    name = 'votreapp'
    def ready(self):
        # On dit a crochet de faire tourner notre app wamp dans sa popote qui
        # isole le reactor de Twisted
        @crochet.run_in_reactor
        def start_wamp():
           # On démarre la session WAMP en se connectant au serveur
           # publique de test
           wapp.run("wws://demo.crossbar.io/ws", "realm1", start_reactor=False)
        start_wamp()</pre>
<p>On passe à urls.py dans lequel on se rajoute des vues de démo :</p>
<pre lang="python">
    url(r'^ping/', 'votreapp.views.ping'),
    url(r'^$', 'votreapp.views.index')
</pre>
<p>Puis dans notre fichier views.py, on met :</p>
<pre lang="python">
# -*- coding: utf-8 -*-

import uuid

from django.shortcuts import render

import crochet

# Crochet se démerde pour faire tourner le reactor twisted de
# manière invisible. A lancer avant d'importer autobahn
crochet.setup()

from autobahn.twisted.wamp import Application

# un objet qui contient une session WAMP
wapp = Application()

# On enrobe les primitives de WAMP pour les rendre synchrones
@crochet.wait_for(timeout=1)
def publish(topic, *args, **kwargs):
   return wapp.session.publish(topic, *args, **kwargs)

@crochet.wait_for(timeout=1)
def call(name, *args, **kwargs):
   return wapp.session.call(name, *args, **kwargs)

def register(name, *args, **kwargs):
    @crochet.run_in_reactor
    def decorator(func):
        wapp.register(name, *args, **kwargs)(func)
    return decorator

def subscribe(name, *args, **kwargs):
    @crochet.run_in_reactor
    def decorator(func):
        wapp.subscribe(name, *args, **kwargs)(func)
    return decorator

# Et hop, on peut utiliser nos outils WAMP !

@register('uuid')
def get_uuid():
    return uuid.uuid4().hex

@subscribe('ping')
def onping():
    with open('test', 'w') as f:
        f.write('ping')

# Et à côté, quelques vues django normales

def index(request):
    # pub et RPC en action côté Python
    publish('ping')
    print call('uuid')

    with open('test') as f:
        print(f.read())
    return render(request, 'index.html')

def ping(request):
    return render(request, 'ping.html')
</pre>
<p>Après, un peu de templating pour que ça marche&#8230;</p>
<p>Index.html :</p>
<pre lang="html">
{% load staticfiles %}
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>
       UUID
    </title>

    <script src="{% static 'autobahn.min.js' %}"></script>
    <script type="text/javascript">
      var connection = new autobahn.Connection({
         url: "ws://localhost:8080/ws",
         realm: "realm1"
      });

     connection.onopen = function (session) {

        session.call("uuid").then(function (uuid) {
          var p = document.getElementById('uuid');
          p.innerHTML = uuid;
        });
     };

     connection.open();
    </script>
</head>
<body>
<h2>UUID</h2>
<p id="uuid"></p>
</body>
</html></pre>
<p>ping.html :</p>
<pre lang="python">{% load staticfiles %}
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>
       Ping
    </title>

    <script src="{% static 'autobahn.min.js' %}"></script>
    <script type="text/javascript">
      var connection = new autobahn.Connection({
         url: "ws://localhost:8080/ws",
         realm: "realm1"
      });

     connection.onopen = function (session) {

        session.subscribe("ping", function () {
          var ul = document.getElementById('ping');
          var li = document.createElement('li');
          li.innerHTML = 'Ping !'
          ul.appendChild(li);
        });
     };

     connection.open();
    </script>
</head>
<body>
<h2>Ping me !</h2>

<ul id="ping">
</ul>
</body>
</html></pre>
<p>On ouvre la console, on lance son routeur :</p>
<pre lang="bash">
    crossbar init
    crossbar start</pre>
<p>On lance dans une autre console son serveur Django :</p>
<pre lang="bash">./manage.py runserver</pre>
<p>Et si on navigue sur <code>http://127.0.0.1:8000</code>, on récupère un UUID tout frais via RCP.</p>
<p>On peut aussi voir dans le shell que ça marche côté Python :</p>
<pre>94cfccf0899d4c42950788fa655b65ed
ping</pre>
<p>D’ailleurs un fichier nommé &#8220;test&#8221; est créé à la racine du projet.</p>
<p>Et si on navigue sur <code>http://127.0.0.1:8000/ping/</code> et qu&#8217;on refresh <code>http://127.0.0.1:8000</code> plusieurs fois, on voit la page se mettre à jour.</p>
<p>Achievement unlock : use WAMP and Django code in the same file.</p>
<h2>A partir de là</h2>
<p>Il y a plein de choses à faire.</p>
<p>On pourrait faire une lib qui wrap tout ça pour pas à avoir à le mettre dans son fichier de vue et qui utilise settings.py pour la configuration.</p>
<p>Il faut tester ça avec des setups plus gros pour voir comment ça se comporte avec gunicorn, plusieurs workers, le logging de Django, etc. Je suis à peu près sûr que les callbacks vont être registrés plusieurs fois et ça devrait faire des erreurs dans les logs (rien de grave ceci dit).</p>
<p>On pourrait aussi adapter le RPC pour qu&#8217;il utilise les cookies d&#8217;authentification Django, et pouvoir les protéger avec @login_required.</p>
<p>Mais un monde d&#8217;opportunités s&#8217;offrent à vous à partir de là.</p>
<p>Moi, ça fait 6 h que je taffe dessus, je vais me pieuter.</p>
<hr>
<p><a href="https://github.com/sametmax/codes-des-articles/tree/master/2015/janvier/wamp_et_django">Télécharger le code de l&#8217;article</a></p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/les-managers-le-detestent-faites-tourner-wamp-dans-django-avec-cette-astuce-insolite/feed/</wfw:commentRss>
		<slash:comments>16</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">15665</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2015/01/index.jpeg" length="10867" type="image/jpg" />	</item>
		<item>
		<title>Corrections des slides WAMP</title>
		<link>http://sametmax.com/corrections-des-slides-wamp/</link>
		<comments>http://sametmax.com/corrections-des-slides-wamp/#comments</comments>
		<pubDate>Thu, 25 Dec 2014 09:58:47 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[autobhan]]></category>
		<category><![CDATA[crossbar]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[tavendo]]></category>
		<category><![CDATA[wamp]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=13011</guid>
		<description><![CDATA[Suites aux commentaires, j'ai fais une refonte des dispos.]]></description>
				<content:encoded><![CDATA[<p>Suite aux commentaires, j&#8217;ai fais une refonte des dispos :</p>
<ul>
<li>Plus d&#8217;insistance sur la différence entre RPC et PUB/SUB.</li>
<li>Les exemples sont amenés plus tôt, et les schémas sont en premier.</li>
<li>Des lourdeurs et des redondances sont supprimées.</li>
<li>J&#8217;ai ajouté des réponses à quelques questions posées : perf, sécu, etc.</li>
</ul>
<p>Histoire d&#8217;éviter d&#8217;éparpiller des versions partout, je l&#8217;ai juste réup <a href="http://sametmax.com/presentation-de-wamp-round-2/">au même endroit</a>.</p>
<p>Merci, donc, pour toutes les remarques qui ont significativement permises d&#8217;améliorer la prez.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/corrections-des-slides-wamp/feed/</wfw:commentRss>
		<slash:comments>8</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">13011</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2014/12/giphy.gif" length="616980" type="image/jpg" />	</item>
		<item>
		<title>Full disclosure</title>
		<link>http://sametmax.com/full-disclosure/</link>
		<comments>http://sametmax.com/full-disclosure/#comments</comments>
		<pubDate>Tue, 16 Dec 2014 15:32:26 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Philo et culture]]></category>
		<category><![CDATA[autobahn]]></category>
		<category><![CDATA[crossbar]]></category>
		<category><![CDATA[evangelism]]></category>
		<category><![CDATA[meta]]></category>
		<category><![CDATA[wamp]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=12883</guid>
		<description><![CDATA[On m'a contacté pour me demander si je n'étais pas chaud pour faire de l'évangélisme, rémunéré, autour de WAMP, Autobahn et Crossbar.]]></description>
				<content:encoded><![CDATA[<p>Depuis quelques jours je suis en discussion avec Tobias de Tavendo. Comme vous avez pu le remarquer avec mes précédents articles sur <a href="http://sametmax.com/crossbar-le-futur-des-applications-web-python/">WAMP</a> et <a href="http://sametmax.com/le-potentiel-de-wamp-autobahn-et-crossbar-io/">Crossbar</a> :</p>
<ul>
<li>Ils sont bons techniquement, et nuls pour expliquer ce qu&#8217;ils ont techniqué.</li>
<li>Cette techno est une techno de rêve pour moi. J&#8217;y crois à mort.</li>
<li>Je suis le seul à avoir pondu des explications décentes sur WAMP et Crossbar. Et ça n&#8217;a pas suffit à faire battre un cil.</li>
</ul>
<p>Bref, ils ont embauché des mecs de haute voltige pour la technique (du genre un contributeur PyPy). Et ils m&#8217;ont contacté pour me demander si je n&#8217;étais pas chaud pour faire de l&#8217;évangélisme, rémunéré, autour de WAMP, Autobahn et Crossbar.</p>
<p>L&#8217;idée : écrire des tutos, des articles, améliorer la doc, répondre sur le chan IRC, etc.</p>
<p>J&#8217;adore le concept, vu que j&#8217;aime leur projet et que je le faisais gratos avant, surtout qu&#8217;ils sont pas trop contraignants sur le temps que je vais passer dessus.</p>
<p>Donc voilà le deal : quand je vais pondre des tutos et des articles sur WAMP et Co, je vais d&#8217;abord les faire en français ici. Comme ça j&#8217;aurai les retours des lecteurs du blog qui pourront, comme d&#8217;habitude, me faire part de leurs douces remarques sur à quel point on ne pige rien.</p>
<p>Une fois la prose aiguisée, je traduis et je publie chez Tavendo.</p>
<p>Je disclose donc ici que vous verrez peut-être des prochaines rédactions qui seront attachées à une activité pro. Pas impartial donc. Mais bon, depuis quand je suis impartial ? Javascript c&#8217;est de la merde, et je préfère les rousses.</p>
<p>Par saucisse d&#8217;honnêteté, je signalerai chaque choucroute concernée avec un lien vers ce post.</p>
<p>Enfin, le contrat est pas signé encore, mais vu que je vais commencer à taffer dessus aujourd&#8217;hui, je pense à une première publication demain sous la forme d&#8217;un slide show expliquant avec de jolies diapos ce que sont WAMP, Autobahn et Crossbar. À quoi ça sert et ce qu&#8217;on peut faire avec.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/full-disclosure/feed/</wfw:commentRss>
		<slash:comments>28</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">12883</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2014/12/0vC5kst.jpg" length="194264" type="image/jpg" />	</item>
		<item>
		<title>Petite démo pragmatique d&#8217;un usage de WAMP en Python</title>
		<link>http://sametmax.com/introduction-a-wamp-en-python/</link>
		<comments>http://sametmax.com/introduction-a-wamp-en-python/#comments</comments>
		<pubDate>Thu, 26 Jun 2014 07:27:03 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[autobahn]]></category>
		<category><![CDATA[crossbar]]></category>
		<category><![CDATA[javascript]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[wamp]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=11146</guid>
		<description><![CDATA[Vu que dernièrement je vous ai bien gavé avec WAMP, ça mérite un tuto non ?]]></description>
				<content:encoded><![CDATA[<p><em>L&#8217;API a changé depuis, j&#8217;ai donc mis à jour l&#8217;article pour refléter ces changements</em></p>
<p>Vu que dernièrement je vous ai bien gavé avec <a href="http://sametmax.com/crossbar-le-futur-des-applications-web-python/">WAMP</a>, ça mérite un tuto non ?</p>
<p>Il se trouve que l&#8217;équipe derrière WAMP a publié plus tôt que prévu une version de leurs libs contenant l&#8217;API flaskesque sur laquelle on bosse. L&#8217;idée est que même si on n&#8217;a pas encore les tests unitaires, on peut déjà jouer avec.</p>
<p>Maintenant il me fallait un projet sexy, histoire de donner envie. Donc j&#8217;ai fouillé dans ce qui se faisait côté temps réel (essentiellement du NodeJS et du Tornado, mais pas que) pour trouver l&#8217;inspiration.</p>
<p>Et j&#8217;ai trouvé un truc très sympa : <a href="http://news.softpedia.com/news/YouTube-Will-Turn-Your-Phone-into-a-Smart-TV-Remote-318286.shtml">un player vidéo piloté à distance.</a></p>
<p>En effet, n&#8217;est-il pas chiant de regarder une vidéo en ligne sur son ordi posé sur la commode pendant qu&#8217;on est enfoncé dans le canap ? Si on veut faire pause ou changer le son, il faut se lever, arg.</p>
<p>Les problèmes du tiers monde, c&#8217;est du pipi de chat à côté. Ils ont de la chance, eux, ils ne connaissent pas le streaming.</p>
<p><strong>Voici donc le projet : </strong></p>
<p>Une page avec un player HTML 5 et un QR code.</p>
<div id="attachment_11151" style="width: 335px" class="wp-caption aligncenter"><a href="http://sametmax.com/wp-content/uploads/2014/06/video.png" class="grouped_elements" rel="tc-fancybox-group11146"><img class="size-full wp-image-11151" title="Pour simplifier la démo, on peut cliquer sur le QR code est avoir la télécommande dans un autre tab pour ceux qui n'ont pas de smartphone ou d'app de scan de QRCode." src="http://sametmax.com/wp-content/uploads/2014/06/video.png" alt="Capture d'écran de la démo, côté player" width="325" height="186" /></a><p class="wp-caption-text">Pour simplifier la démo, on peut cliquer sur le QR code et avoir la télécommande dans un autre tab pour ceux qui n&#8217;ont pas de smartphone ou d&#8217;app de scan de QRCode.</p></div>
<p>Si on scanne le QR code avec son téléphone, il vous envoie sur une page avec une télécommande pour contrôler le player sans bouger votre cul :</p>
<div id="attachment_11152" style="width: 306px" class="wp-caption aligncenter"><a href="http://sametmax.com/wp-content/uploads/2014/06/controles.png" class="grouped_elements" rel="tc-fancybox-group11146"><img class="size-full wp-image-11152" title="Évidement, c'est basique. Je vais pas m'amuser à faire un produit complet juste pour un truc dont le code source ne sera même pas regardé par la plupart d'entre vous. Je vous connais, bandes de feignasses !" src="http://sametmax.com/wp-content/uploads/2014/06/controles.png" alt="Capture d'écrand de la démo, côté contrôles" width="296" height="370" /></a><p class="wp-caption-text">Évidement, c&#8217;est basique. Je vais pas m&#8217;amuser à faire un produit complet juste pour un truc dont le code source ne sera même pas regardé par la plupart d&#8217;entre vous. Je vous connais, bandes de feignasses !</p></div>
<p>Et vous allez voir, c&#8217;est même pas dur à faire.</p>
<p>Démo en ligne:</p>
<p style="margin: 1em; text-align: center;"><a style="font-size: 2em;" href="https://demo.crossbar.io/videocontrol/">La démo</a></p>
<p><a href="https://github.com/sametmax/codes-des-articles/tree/master/2014/juin/video_remote">Vous pouvez télécharger le code ici</a>.</p>
<p>Pour comprendre ce qui va suivre, il va vous falloir les bases en prog Javascript et Python, ainsi que bien comprendre la notion de <a href="http://sametmax.com/quest-ce-quun-callback/">callback</a>. Être à l&#8217;aise avec <a href="http://sametmax.com/deferred-future-et-promise-le-pourquoi-le-comment-et-quand-est-ce-quon-mange">promises</a> peut aider.</p>
<p>Et pour bien digérer ce paté, rien ne vaut un peu de son :</p>
<p><iframe class='youtube-player' type='text/html' width='1170' height='689' src='http://www.youtube.com/embed/FU4cnelEdi4?version=3&#038;rel=1&#038;fs=1&#038;autohide=2&#038;showsearch=0&#038;showinfo=1&#038;iv_load_policy=1&#038;wmode=transparent' allowfullscreen='true' style='border:0;'></iframe></p>
<h2>Le Chteumeuleu</h2>
<p>Il va nous falloir deux pages Web, une pour le player vidéo, et une pour la télécommande.</p>
<p>Le player :</p>
<pre lang="html">

<!DOCTYPE html>
<html>
<head>
   <title>Video</title>
   <meta charset='utf-8'>
   <!-- Chargement des dépendances : autobahn pour WAMP
   et qrcode pour générer le QR code. Bien entendu, je
   vous invite à ne pas les hotlinker dans vos projets,
   mais pour la démo c'est plus simple. -->
   <script src="https://autobahn.s3.amazonaws.com/autobahnjs/latest/autobahn.min.jgz"
           type="text/javascript"></script>
   <script src="http://davidshimjs.github.com/qrcodejs/qrcode.min.js"
           type="text/javascript"></script>

   <style type="text/css">
      #vid {
         /* Taille de la video */
         width:427px;
         height:240px;
      }
      /* Centrage avec la méthode Rache */
      #container {
          width:427px;
          margin:auto;
      }
      #ctrllink {
          display:block;
          width:256px;
          margin:auto;
      }
   </style>

</head>
<body>
<div id="container">
  <p>

   <!-- Pareil, je hotlink la video, mais ne faites pas ça
   à la maison les enfants. Surtout que les perfs du
   serveur du W3C sont merdiques et ça bufferise à mort. -->
    <video id="vid"
           class="video-js vjs-default-skin"
           controls preload="auto"
           poster="http://media.w3.org/2010/05/sintel/poster.png" >
    <source id='ogv'
      src="http://media.w3.org/2010/05/sintel/trailer.ogv"
      type='video/ogg'>
    <source id='mp4'
      src="http://media.w3.org/2010/05/sintel/trailer.mp4"
      type='video/mp4'>
    <source id='webm'
      src="http://media.w3.org/2010/05/sintel/trailer.webm"
      type='video/webm'>
    </video>
  </p>
  <p>
    <a id="ctrllink" href="#" target="_blank">
      <span id="qrcode"></span>
    </a>
  </p>
 </div>

</body>
</pre>
<p>Et la télécommande :</p>
<pre lang="html">

<!DOCTYPE html>
<html>
<head>
  <title>Télécommande</title>
  <meta charset='utf-8'>
  <script src="https://autobahn.s3.amazonaws.com/autobahnjs/latest/autobahn.min.jgz"
         type="text/javascript"></script>
  <!-- Zoom du viewport sur mobile pour éviter d'avoir
       à le faire à la main. -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style type="text/css">
    #controls {
      width:350px;
      margin:auto;
    }
    #controls button {
      font-size: 1em;
    }
    #controls input {
      vertical-align:middle;
       width: 200px;
       height:20px;
   }
  </style>
</head>
<body>
  <p id="controls">
    <!-- Marrant de se dire qu'en 2000, le JS inline était
         considéré comme démoniaque, et maintenant avec
         angularjs et cie, c'est exactement ce que tout
         le monde fait...
         Bref, on attache le clic sur nos contrôles à des
         méthodes de notre objet qui va se charger de la
         logique. -->

    <button id="play" onclick="control.togglePlay()">Play</button>
    <input id="volume"
                    onchange="control.volume(this.value)"
                    type="range">
  </p>
</body>
</pre>
<p>Rien d&#8217;incroyable. C&#8217;est du HTML, un peu de CSS, on charge les dépendances en JS. Classique.</p>
<p>Vu qu&#8217;on utilise des ressources hotlinkées par souci de simplicité, <strong>il vous faudra être connecté à Internet.</strong></p>
<h2>Setup du routeur</h2>
<p>On va travailler avec Python 2.7 puisque Crossbar.io est uniquement en 2.7 et que je n&#8217;ai pas envie de vous faire installer deux versions de Python juste pour le tuto.</p>
<p>Il nous faut avant tout un serveur HTTP pour servir les fichiers HTML et un routeur WAMP. On installe donc Crossbar.io :</p>
<pre lang="bash">pip install crossbar</pre>
<p>Ca va aussi installer autobahn, twisted et tout le bordel.</p>
<p>On va ensuite dans le dossier qui contient ses fichiers HTML, et on créé le fichier de config de Crossbar.io avec un petit :</p>
<pre lang="bash">crossbar init</pre>
<p>Vous noterez la création d&#8217;un dossier <code>.crossbar</code> qui contient un fichier <code>config.json</code>. C&#8217;est la config de crossbar. <strong>Videz moi ce fichier</strong>, on va le remplir avec notre config :</p>
<pre lang="javascript">
{
   "workers": [
      {
         "type": "router",
         "realms": [
            {
               "name": "realm1",
               "roles": [
                  {
                     "name": "anonymous",
                     "permissions": [
                        {
                           "uri": "*",
                           "publish": true,
                           "subscribe": true,
                           "call": true,
                           "register": true
                        }
                     ]
                  }
               ]
            }
         ],
         "transports": [
            {
               "type": "web",
               "endpoint": {
                  "type": "tcp",
                  "port": 8080,
                  "interface": "0.0.0.0"
               },
               "paths": {
                  "/": {
                     "type": "static",
                     "directory": ".."
                  },
                  "ws": {
                     "type": "websocket",
                  }
               }
            }
         ]
      }
   ]
}
</pre>
<p>Crossbar est en effet un gestionnaire de processus : il ne gère vraiment rien lui même. Il démarre d&#8217;autres processus, appelés workers, à qui il délègue le travail. </p>
<p>On définit dans ce fichier de config quels processus (les workers) lancer quand Crossbar.io démarre. Les valeurs qu&#8217;on utilise disent de créer un seul worker de type &#8220;router&#8221;, c&#8217;est à dire un worker capable de gérer les entrées et les sorties WAMP. Hey oui, le routeur n&#8217;est qu&#8217;un worker comme les autres :)</p>
<p>Il y a d&#8217;autres sortes de workers, mais aujourd&#8217;hui on s&#8217;en branle.</p>
<p>Dans notre config du worker router, on crée d&#8217;abord un realm, qui est juste un namespace avec des permissions. Si un client WAMP se connecte à ce routeur, il doit choisir un realm (qui est juste un nom), et il ne peut parler qu&#8217;avec les clients du même realm. C&#8217;est une cloture quoi.</p>
<p>Dans un realm, on définit des roles qui déclarent quelles opérations PUB/SUB et RPC on a le droit de faire. Ici on dit que tout le monde (anonymous) a le droit de tout faire sur toutes les urls (&#8220;uri&#8221;:  &#8216;*&#8221;) histoire de pas se faire chier. Si on met en prod, évidement on va se pencher sur la sécurité et faire ça plus proprement.</p>
<pre lang="javascript">
"realms": [
{
   "name": "realm1",
   "roles": [
      {
         "name": "anonymous",
         "permissions": [
            {
               "uri": "*",
               "publish": true,
               "subscribe": true,
               "call": true,
               "register": true
            }
         ]
      }
   ]
}
],</pre>
<p>Puis on définit les transports, c&#8217;est à dire sur quoi notre worker va ouvrir ses oreilles pour écouter les messages entrant :</p>
<pre lang="javascript">"transports": [
            {
               "type": "web",
               "endpoint": {
                  "type": "tcp",
                  "port": 8080,
                  "interface": "0.0.0.0"
               },
               "paths": {
                  "/": {
                     "type": "static",
                     "directory": ".."
                  },
                  "ws": {
                     "type": "websocket",
                  }
               }
            }
        ]
</pre>
<p>Encore une fois on en déclare un seul, de type &#8220;web&#8221;. Ce transport peut écouter HTTP et Websocket sur le même port. On lui dit d&#8217;écouter sur &#8220;0.0.0.0:8080&#8221; :</p>
<p><lang="javascript"><br />
&#8220;endpoint&#8221;: {<br />
  &#8220;type&#8221;: &#8220;tcp&#8221;,<br />
  &#8220;port&#8221;: 8080,<br />
  &#8220;interface&#8221;: &#8220;0.0.0.0&#8221;<br />
},</lang></p>
<p>Ensuite on dit que si quelqu&#8217;un arrive sur &#8220;/&#8221;, on sert en HTTP les fichiers statiques histoire que nos pages Web soient servies :</p>
<pre lang="javascript">"/": {
 "type": "static",
 "directory": ".."
},</pre>
<p>Si on arrive sur &#8220;/ws&#8221;, on route les requêtes WAMP via Websocket :</p>
<pre lang="javascript">"ws": {
 "type": "websocket",
}</pre>
<p>Le routeur est prêt, on lance Crossbar.io :</p>
<pre lang="bash">
$ crossbar start
2015-01-07 20:02:55+0700 [Controller  26914] Log opened.
2015-01-07 20:02:55+0700 [Controller  26914] ============================== Crossbar.io ==============================
    
2015-01-07 20:02:55+0700 [Controller  26914] Crossbar.io 0.9.12-2 starting
2015-01-07 20:02:55+0700 [Controller  26914] Running on CPython using EPollReactor reactor
2015-01-07 20:02:55+0700 [Controller  26914] Starting from node directory /home/sam/Work/sametmax/code_des_articles/2014/juin/video_remote/.crossbar
2015-01-07 20:02:55+0700 [Controller  26914] Starting from local configuration '/home/sam/Work/sametmax/code_des_articles/2014/juin/video_remote/.crossbar/config.json'
2015-01-07 20:02:55+0700 [Controller  26914] Warning, could not set process title (setproctitle not installed)
2015-01-07 20:02:55+0700 [Controller  26914] Warning: process utilities not available
2015-01-07 20:02:55+0700 [Controller  26914] No WAMPlets detected in enviroment.
2015-01-07 20:02:55+0700 [Controller  26914] Starting Router with ID 'worker1' ..
2015-01-07 20:02:55+0700 [Controller  26914] Entering reactor event loop ...
2015-01-07 20:02:55+0700 [Router      26917] Log opened.
2015-01-07 20:02:55+0700 [Router      26917] Warning: could not set worker process title (setproctitle not installed)
2015-01-07 20:02:55+0700 [Router      26917] Running under CPython using EPollReactor reactor
2015-01-07 20:02:56+0700 [Router      26917] Entering event loop ..
2015-01-07 20:02:56+0700 [Router      26917] Warning: process utilities not available
2015-01-07 20:02:56+0700 [Controller  26914] Router with ID 'worker1' and PID 26917 started
2015-01-07 20:02:56+0700 [Controller  26914] Router 'worker1': realm 'realm1' started
2015-01-07 20:02:56+0700 [Controller  26914] Router 'worker1': role 'role1' started on realm 'realm1'
2015-01-07 20:02:56+0700 [Router      26917] Site starting on 8080
2015-01-07 20:02:56+0700 [Controller  26914] Router 'worker1': transport 'transport1' started
</pre>
<h2>Setup du client</h2>
<p>Pour cette démo, le serveur n&#8217;a pas grand chose à faire. On pourrait en fait la faire sans aucun code Python, mais ça va nous simplifier la vie et donner un peut de grain à moudre pour le tuto.</p>
<p>En effet, on a deux problématiques que le serveur va résoudre facilement pour nous : <strong>créer un ID unique pour le player et récupérer l&#8217;IP sur le réseau local.</strong></p>
<p>L&#8217;ID, c&#8217;est simplement que si plusieurs personnes lancent en même temps un player, on ne veut pas que les télécommandes puissent lancer un ordre à un autre player que le sien. On pourrait utiliser un timestamp, mais ils sont contigus, n&#8217;importe quel script kiddies pourrait faire un script pour foutre la merde. On va donc créer un ID unique qui ne soit pas facilement prévisible. Javascript n&#8217;a rien pour faire ça en natif, et c&#8217;est un peu con de charger une lib de plus pour ça alors que Python peut le faire pour nous.</p>
<p>L&#8217;IP, c&#8217;est parce qu&#8217;il faut donner l&#8217;adresse de notre machine contient notre routeur. Et le téléphone qui sert de télécommande doit se connecter à ce routeur. Il faut donc qu&#8217;il connaisse l&#8217;adresse de celui-ci, donc on va la mettre dans notre QR code.</p>
<p>Cela veut dire aussi que le téléphone doit être sur le même réseau local pour que ça fonctionne. <strong>Donc mettez votre téléphone en Wifi, pas en 3G.</strong></p>
<p>Voilà ce que donne notre code WAMP côté serveur :</p>
<pre lang="python"># -*- coding: utf-8 -*-

from autobahn.twisted.wamp import Application

import socket
import uuid

# Comme pour flask, l'objet app
# est ce qui lie tous les éléments
# de notre code ensemble. On lui donne
# un nom, ici "demo"
app = Application('demo')
# Bien que l'app va démarrer un serveur
# pour nous, l'app est bien un CLIENT
# du serveur WAMP. Le serveur démarré
# automatiquement n'est qu'une facilité
# pour le dev. En prod on utiliserait
# crossbar.

# Juste un conteneur pour y mettre notre IP
app._data = {}

# On déclare que cette fonction sera appelée
# quand l'app se sera connectée au serveur WAMP.
# Ceci permet de lancer du code juste après
# le app.run() que l'on voit en bas du fichier.
# '_' est une convention en Python pour dire
# "ce nom n'a aucune importance, c'est du code
# jetable qu'on utilisera une seule fois".
@app.signal('onjoined')
def _():
   # On récupère notre adresse IP sur le réseau local
   # C'est une astuce qui demande de se connecter et donc
   #  à une IP externe, on a besoin d'une connexion internet.
   s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
   s.connect(("8.8.8.8", 80))
   # On stocke l'adresse IP locale dans un conteneur
   # qui sera accessible partout ailleur.
   app._data['LOCAL_IP'] = s.getsockname()[0]
   s.close()

# On déclare que la fonction "ip()" est appelable
# via RCP. Ce qui veut dire que tout autre client
# WAMP peut obtenir le résultat de cette fonction.
# Donc on va pouvoir l'appeler depuis notre navigateur.
# Comme notre app s'appelle "demo" et notre fonction
# s'appelle "ip", un client pourra l'appeler en faisant
# "demo.ip".
@app.register()
def ip():
   # On ne fait que retourner l'IP locale. Rien de fou.
   return app._data['LOCAL_IP']

# Je voulais appeler cette fonction distante "uuid", mais ça
# override le module Python uuid. Ce n'est pas une bonne
# idée. Je l'appelle donc 'get_uuid' mais je déclare le
# namespace complet dans register(). Un client WAMP pourra donc
# bien l'appeler via "demo.uuid".
# Notez que ce namespace doit toujours s'écrire
# truc.machine.bidule. Pas truc/machin ou truc:machin.
# ou truc et bidule.MACHIN.
@app.register('demo.uuid')
def get_uuid():
   # Retourne un UUID, sans les tirets.
   # ex: b27f7e9360c04efabfae5ac21a8f4e3c
   return str(uuid.uuid4()).replace('-', '')

# On lance notre client qui va se connecter au
# routeur.
if __name__ == '__main__':
    app.run(url="ws://127.0.0.1:8080/ws")
# On ne peut rien mettre comme code ici, il faut le
# mettre dans @app.signal('onjoined') si on veut
# entrer du code après que l'app soit lancée.
</pre>
<p>Et on lance notre app dans un autre terminal:</p>
<pre lang="bash">python app.py</pre>
<p>Nous avons maintenant Crossbar.io qui tourne d&#8217;une console, et le client Python qui tourne dans une seconde console, connecté au routeur.</p>
<h2>Le lecteur vidéo</h2>
<p>Il nous faut maintenant définir le comportement de notre lecteur vidéo, un client WAMP Javascript. Il s&#8217;agit essentiellement de se connecter au serveur WAMP, et d&#8217;échanger des messages via RPC ou PUB/SUB :</p>
<pre lang="javascript">  var player = {};
  var url;
  /* On va utiliser du pur JS histoire de pas mélanger
    des notions de jQuery dans le tas. Je ne vais
    PAS utiliser les best practices sinon vous allez
    être noyés dans des détails */

  /* Lancer le code une fois que la page est chargée */
  window.addEventListener("load", function(){

    /* Connexion au serveur WAMP. J'utilise
       les valeurs par défaut du serveur de
       dev. On ouvre explicitement la connection
       à la fin du script. */
    var connection = new autobahn.Connection({
       url: 'ws://' + window.location.hostname + ':8080/ws',
       realm: 'realm1'
    });

    /* Lancer ce code une fois que la connexion
       est réussie. Notez que je ne gère pas
       les erreurs dans dans une APP JS, c'est
       un puits sans fond. */
    connection.onopen = function (session) {

      /* Appel de la fonction ip() sur le serveur */
      session.call('demo.ip')

      /* Une fois qu'on a récupéré l'IP,
         on peut fabriquer l'URL de notre
         projet et on appelle la fonction
         get_uuid() du serveur */
      .then(function(ip){
        url = 'http://' + ip + ':8000';
        return session.call('demo.uuid');
      })

      /* Une fois qu'on a l'UUID, on peut commencer
         à gérer la partie télécommande */
      .then(function(uuid){

        /* Création du QR code avec le lien pointant
           sur la bonne URL. On met l'ID dans le hash. */
        var controlUrl = url + '/control.html#' + uuid;
        var codeDiv = document.getElementById("qrcode");
        new QRCode(codeDiv, controlUrl);
        var ctrllink = document.getElementById("ctrllink");
        ctrllink.href = controlUrl;

        /* Notre travail consiste essentiellement à
           manipuler cet élément */
        var video = document.getElementById("vid");

        /* On attache déclare 4 fonctions comme étant
           appelable à distance. Ces fonctions sont
           appelables en utilisant le nom composé
           de notre ID et de l'action qu'on souhaite
           faire. Ex:
           'b27f7e9360c04efabfae5ac21a8f4e3c.play'
           pour appeler "play" sur notre session. */
        session.register(uuid + '.play', function(){
           video.play();
        });

        session.register(uuid + '.pause', function(){
           video.pause();
        });

        session.register(uuid + '.volume', function(val){
           video.volume = val[0];
        });

        session.register(uuid + '.status', function(val){
          return {
            'playing': !video.paused,
            'volume': video.volume
          };
        });



       /* Quelqu'un peut très bien
           appuyer sur play directement sur cette page.

          Il faut donc réagir si l'utilisateur le fait,
          publier un événement via WAMP pour permettre
          à notre télécommande de se mettre à jour
          */
       video.addEventListener('play', function(){
         /* On publie un message indiquant que
            le player a recommencé à lire la vidéo.
            */
         session.publish(uuid + '.play');
       });

        video.addEventListener('pause', function(){
          session.publish(uuid + '.pause');
        });

        video.addEventListener('volumechange', function(){
          session.publish(uuid + '.volume', [video.volume]);
        });

     });
    };

    /* Ouverture de la connection une fois que tous les
       callbacks sont bien en place.*/
    connection.open();
  });

</pre>
<h2>Code de la télécommande</h2>
<p>La télécommande est notre dernier client WAMP (on peut avoir plein de clients WAMP, ne vous inquiétez, ça tient 6000 connections simultanées sur un tout petit Raspberry PI). </p>
<p>Son code a pour but d&#8217;envoyer des ordres au player HTML5, mais aussi de mettre à jour son UI si le player change d&#8217;état.</p>
<pre lang="javascript">/* L'objet qui se charge de la logique de nos
   controles play/pause et changement de
   volume.
   Rien de fou, il change l'affichage
   du bouton et du slider selon qu'on
   est en pause/play et la valeur du
   volume.
   */
var control = {
   playing: false,
   setPlaying: function(val){
      control.playing = val;
      var button = window.document.getElementById('play');
      if (!val){
         button.innerHTML = 'Play'
      } else {
         button.innerHTML = 'Pause';
      }
   },
   setVolume: function(val){
      var slider = window.document.getElementById('volume');
      slider.value = val;
   }
};
window.onload = function(){
  var connection = new autobahn.Connection({
    url: 'ws://' + window.location.hostname + ':8080/ws',
    realm: 'realm1'
  });

  connection.onopen = function (session) {

    /* Récupération de l'ID dans le hash de l'URL */
    var uuid = window.location.hash.replace('#', '');

    /* Mise à jour des controles selon le status actuel
       du player grace à un appel RPC vers notre autre
       page. */
    session.call(uuid + '.status').then(function(status){

      control.setPlaying(status['playing']);
      control.setVolume(status['volume'])

      /* On attache l'appui sur les contrôles à
         un appel de la fonction play() sur le
         player distant. L'uuid nous permet
         de n'envoyer l'événement que sur le
         bon player. */
      control.togglePlay = function() {
        if (control.playing){
          session.call(uuid + '.pause');
          control.setPlaying(false);
        } else {
          session.call(uuid + '.play');
          control.setPlaying(true);
        }
      };

      control.volume = function(val){
        session.call(uuid + '.volume', [val / 100]);
      };

      /* On ajoute un callback sur les événements
         de changement de status du player. Si
         quelqu'un fait play/pause ou change le
         volume, on veut mettre à jour la page. */
      session.subscribe(uuid + '.play', function(){
        control.setPlaying(true);
      });

      session.subscribe(uuid + '.pause', function(){
        control.setPlaying(false);
      });

      session.subscribe(uuid + '.volume', function(val){
        control.setVolume(val[0] * 100);
      });
    });
  };

  connection.open();
};
</pre>
<h2>En résumé</h2>
<p>Voici à quoi ressemble le projet final :</p>
<pre>.
├── app.py
├── control.html
├── .crossbar
│   └── config.json
└── index.html
</pre>
<div id="attachment_11173" style="width: 499px" class="wp-caption aligncenter"><a href="http://sametmax.com/wp-content/uploads/2014/06/demo_video_wamp.png" class="grouped_elements" rel="tc-fancybox-group11146"><img class="size-full wp-image-11173" title="Bien que l'app Python lance le serveur automatiquement et de manière invisible, c'est bien un composant à part." src="http://sametmax.com/wp-content/uploads/2014/06/demo_video_wamp.png" alt="Schéma de fonctionnement de la démo" width="489" height="346" /></a><p class="wp-caption-text">Bien que l&#8217;app Python lance le serveur automatiquement et de manière invisible, c&#8217;est bien un composant à part.</p></div>
<p>Pour ce projet, on aura utilisé :</p>
<ul>
<li><a href="http://wamp.ws/">WAMP</a>: le protocole qui permet de faire communiquer en temps réel des parties d&#8217;application via RPC et PUB/SUB.</li>
<li><a href="http://autobahn.ws/js/">Autobahn.js</a>: une lib pour créer des clients WAMP en javascript.</li>
<li><a href="http://autobahn.ws/python/">Autobahn.py</a>: une lib pour créer des clients WAMP en Python.</li>
<li><a href="http://crossbar.io/">Crossbar.io</a>: un routeur WAMP.</li>
</ul>
<p>Il y a pas mal de notions à prendre en compte.</p>
<p>D&#8217;abord, le <strong>RPC</strong>.</p>
<p>Cela permet à un client de dire &#8220;les autres clients peuvent appeler cette fonction à distance&#8221;. On l&#8217;utilise pour exposer <code>ip()</code> et <code>get_uuid()</code> sur notre serveur et notre Javascript peut donc les appeler. Mais on l&#8217;utilise AUSSI pour qu&#8217;une des pages (le player) expose <code>play()</code>, <code>pause()</code> et <code>volume()</code> et que l&#8217;autre page (notre télécommande) puisse les utiliser.</p>
<p>La grosse différence, c&#8217;est que <code>ip()</code> peut être appelé par tous les clients en utilisant &#8220;demo.ip&#8221; alors que <code>play()</code> ne peut être appelé que par les clients qui connaissent l&#8217;ID du player, puisqu&#8217;il faut utiliser &#8220;&lt;id&gt;.play&#8221;.</p>
<p>Ensuite, il y a le <strong>PUB/SUB</strong>.</p>
<p>Cela permet à un client de dire &#8220;j&#8217;écoute tous les messages adressés à ce nom&#8221;. Et un autre client peut envoyer un message (on appelle ça aussi un événement, c&#8217;est pareil) sur ce nom, de telle sorte que tous les clients abonnés le reçoivent.</p>
<p>On l&#8217;utilise pour que notre télécommande dise &#8220;j&#8217;écoute tous les messages qui concernent les changements de status du player.&#8221; De l&#8217;autre côté, quand on clique sur un contrôle du player, on envoie un message précisant si le volume a changé, ou si on a appuyé sur play/pause. La télécommande peut ainsi mettre son UI à jour et refléter par exemple, la nouvelle valeur du volume.</p>
<p>Cela résume bien les usages principaux de ces deux outils :</p>
<ul>
<li>RPC permet de donner un ordre ou récupérer une information.</li>
<li>PUB/SUB permet de (se) tenir au courant d&#8217;un événement.</li>
</ul>
<p>Voici le workflow de notre projet :</p>
<ul>
<li>On lance un serveur WAMP.</li>
<li>On connecte des clients dessus (du code Python ou Js dans notre exemple).</li>
<li>Les clients déclarent les fonctions qu&#8217;ils exposent en RPC et les événements qu&#8217;ils écoutent en PUB/SUB.</li>
<li>Ensuite on réagit aux actions utilisateurs et on fait les appels RPC et les publications PUB/SUB en conséquence.</li>
</ul>
<p><strong>Si vous virez tous les commentaires, vous verrez que le code est en fait vraiment court pour une application aussi complexe.</strong></p>
<p>Encore une fois, il est possible de le faire sans WAMP, ce sera juste plus compliqué. Je vous invite à essayer de le faire pour vous rendre compte. Avec PHP, Ruby ou une app WSGI, c&#8217;est pas marrant du tout. Avec NodeJs, c&#8217;est plus simple, mais il faut quand même se taper la logique de gestion RPC et PUB/SUB à la main ou installer pas mal de libs en plus.</p>
<p>WAMP rend ce genre d&#8217;app triviale à écrire. Enfin triviale parce que là j&#8217;ignore tous les edge cases, évidemment. Pour un produit solide, il faut toujours suer un peu.</p>
<h2>Les limites du truc</h2>
<p>C&#8217;est du Python 2.7. Bientôt on pourra le faire avec asyncio et donc Python 3.4, mais malheureusement sans le serveur de dev.</p>
<p>Heureusement, Twisted est en cours de portage vers Python 3, et donc tout finira par marcher en 3.2+.</p>
<p>C&#8217;est du HTML5, mais bien entendu, rien ne vous empêche de faire ça avec du Flash si ça vous amuse.</p>
<p>C&#8217;est du WebSocket, mais on peut utiliser un peu de Flash pour <a href="https://github.com/gimite/web-socket-js">simuler WebSocket</a> pour les vieux navigateurs qui ne le supportent pas.</p>
<p>Non, la vraie limite c&#8217;est encore la jeunesse du projet : pas d&#8217;autoreload pour le serveur (super chiant de devoir le faire à la main à chaque fois qu&#8217;on modifie le code) et les erreurs côté serveur se lisent dans la console JS, et pas dans le terminal depuis lequel on a lancé le serveur. Plein de petits détails comme ça.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/introduction-a-wamp-en-python/feed/</wfw:commentRss>
		<slash:comments>47</slash:comments>
<enclosure url="http://media.w3.org/2010/05/sintel/trailer.ogv" length="12965718" type="video/ogg" />
<enclosure url="http://media.w3.org/2010/05/sintel/trailer.mp4" length="4372373" type="video/mp4" />
<enclosure url="http://media.w3.org/2010/05/sintel/trailer.webm" length="3091780" type="video/webm" />
	<post-id xmlns="com-wordpress:feed-additions:1">11146</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2014/06/FqebLW21.png" length="439958" type="image/jpg" />	</item>
		<item>
		<title>Le potentiel de WAMP, autobahn et crossbar.io</title>
		<link>http://sametmax.com/le-potentiel-de-wamp-autobahn-et-crossbar-io/</link>
		<comments>http://sametmax.com/le-potentiel-de-wamp-autobahn-et-crossbar-io/#comments</comments>
		<pubDate>Sun, 01 Jun 2014 10:09:32 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[autobahn]]></category>
		<category><![CDATA[crossbar]]></category>
		<category><![CDATA[flask]]></category>
		<category><![CDATA[http]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[wamp]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=10380</guid>
		<description><![CDATA[Je sais, je sais, je vous fais chier avec <a href="http://sametmax.com/crossbar-le-futur-des-applications-web-python/">crossbar</a> et <a href="http://sametmax.com/un-petit-gout-de-meteor-js-en-python/">autobahn</a>.

Mais ça me tue de ne pas voir plus de monde exploiter cette techno.]]></description>
				<content:encoded><![CDATA[<p>Je sais, je sais, je vous fais chier avec <a href="http://sametmax.com/crossbar-le-futur-des-applications-web-python/">crossbar</a> et <a href="http://sametmax.com/un-petit-gout-de-meteor-js-en-python/">autobahn</a>.</p>
<p>Mais ça me tue de ne pas voir plus de monde exploiter cette techno.</p>
<p>Pendant que Max fait la sieste, j&#8217;ai pris mon stylo et j&#8217;ai fait la liste des besoins d&#8217;une app Web actuelle. Quels sont les composants qu&#8217;on utilise presque systématiquement, mais en agrégeant divers bouts de trucs à droite et à gauche ?</p>
<p>Ensuite j&#8217;ai regardé les possibilités des outils WAMP :</p>
<ul>
<li>PUB/SUB et RPC.</li>
<li>Asynchrone.</li>
<li>Gestionnaire de process intégré.</li>
<li>Serveur stand alone qui n&#8217;a pas besoin d&#8217;un proxy pour être en prod.</li>
</ul>
<p>M&#8217;inspirant de cela, et du travail que je suis en train de faire avec l&#8217;équipe de Tavendo pour faire une API flaskesque pour autobahn, j&#8217;ai prototypé une API d&#8217;un framework Web qu&#8217;on pourrait coder au dessus de cette techno.</p>
<p>Voilà ce que ça donne&#8230;</p>
<p>Une API qui mélange flask et nodejs pour le Web</p>
<pre lang="python">app = Application('YourProjectName')

# Envoyer et recevoir des requêtes HTTP
@app.http.post(r'/form')
def _(req, res):
    res.json({'data': 'pouet'})

@app.http.get(r'/user/:id/')
def _(req, res):
    res.render('index.html', {'data': 'pouet'})

# Servir des fichiers statiques
@app.http.serve('uri', '/path/to/dir', [allow_index])

app.run()</pre>
<p>Comme c&#8217;est asynchrone, on a de très bonnes perfs. Comme c&#8217;est basé sur Twisted, on a pas besoin d&#8217;un serveur wsgi (gunicorn, uwsgi, etc) ni d&#8217;un proxy (nginx) devant. On peut le mettre en prod tel quel.</p>
<p>Parti de ce principe, on peut ajouter la gestion du PUB/SUB et du RPC pour WAMP :</p>
<pre lang="python"># Callback attendant l'événement
@app.wamp.event('auth.signedin')
def _(ctx, a, b, c):
    pass

# déclenchement de l'événément
app.wamp.pub('auth.signedin')

# Déclaration du fonnction appelable à distance
@app.wamp.remote('auth.signin')
def _(ctx, a, b, c):
    pass

# appel de la fonnction
app.wamp.call('auth.signin')</pre>
<p>On est souvent perdu quand on fait de l&#8217;asynchrone pour la première fois avec Python car on ne sait pas comment lancer du code après <code>.run()</code>. On peut régler la question proposant des hooks pour les instants clés de l&#8217;app.</p>
<pre lang="python"># Callback à lancer quand l'app est prête
@app.on('app.ready')
def _(ctx, args):
    pass

# Signalement que l'app est prête (fait automatiquement en interne
# pour les moments les plus importants)
app.emit('app.ready')</pre>
<p>Et tant qu&#8217;on y est, puisqu&#8217;on a une event loop, profitons en pour proposer du CRON intégré à l&#8217;app. C&#8217;est moins chiant à déployer qu&#8217;un script CRON, c&#8217;est cross plateforme, et on a accès facilement à toute sa stack.</p>
<pre lang="python"># Lancer du code tous les x temps ou a une date précise
@app.cron(every=seconds)
@app.cron(every=timedelta, overlap=False)
@app.cron(hour=7, minute=30, day_of_week=1)
@app.cron(when=datetime)
def _(ctx, args):
    pass

</pre>
<p>Pourquoi s&#8217;arrêter là ? Event loop + message passing + safe queues + workers = tasks queues !</p>
<pre lang="python"># Créer une file d'attente
queue = @app.queue('name', [workers], [result_backend])

# Callback appelé par un worker quand il depop ce 
# message dans la file
@queue.task('encode.video')
def _(ctx, data):
    pass

# Envoie d'une tache dans la queu
queue.append('encode.video', data)
</pre>
<p>Comme on utilise Twisted, on a accès à une chiée de protocoles, et on peut aussi créer les siens. On peut donc imaginer un système de plugins qui rajoute des protocoles supportés :</p>
<pre lang="python">app = Application('YourProjectName')
app.plug('lib.ajoutant.sms', [namespace])</pre>
<p>Si on en a beaucoup et que le namespace nous convient :</p>
<pre lang="python">app = Application('YourProjectName', plugins=('lib1', 'lib2', 'etc'))</pre>
<p>Exemples de plugins possibles :</p>
<pre lang="python"># Recevoir et envoyer des SMS (via un service type twilio, une gateway kannel ou
# un modem physique)
@app.sms.receive(r'LOVE \w+ \w+')
def _(ctx, args):
    pass
app.sms.send('test', [contact])


# Envoyer et recevoir des emails (via un server SMTP ou IMAP)
@app.email.receive(src=r'.*@sametmax.com', dest=r'spam.*@*.')
def _(ctx, args):
    pass
app.email.send('test', [contact, title, attachments])


# techniquement n'importe quel service de message pour lequel on peut écrire
# un backend
@app.tweet.receive(r'Chat')
@app.fb.receive(r'Like')
@app.instagram.receive(r'Bouffe')
@app.irc.message(r'dtc')
def _(ctx, args):
    pass</pre>
<p>Le problème des apps centrées sur un objet, c&#8217;est qu&#8217;elles ont souvent un design monolithique. Ce n&#8217;est pas un problème du concept d&#8217;app, c&#8217;est juste que les auteurs ont pensé &#8220;point d&#8217;entrée&#8221;, et pas &#8220;élément composable&#8221;.</p>
<p>Si besoin, on doit pouvoir composer une app via plusieurs sous-app :</p>
<pre lang="python">app = Application()
app.embed('autre.app')</pre>
<p>ou</p>
<pre lang="python">app = Application(embed=['app1', 'app2', 'app3'])</pre>
<p>Il faut des hooks pour overrider la configuration, mais vous avez compris le principe.</p>
<p>Un autre problème avec les plateformes comme NodeJS, c&#8217;est qu&#8217;il est difficile d&#8217;utiliser plusieurs coeurs. C&#8217;est une des raisons du succès de Go.</p>
<p>Or, Crossbar encourage la division en plusieurs process qui communiquent entre eux (un peu comme les channels). Créons aussi une API pour ça :</p>
<pre lang="python">p1 = app.process()
p2 = app.process()

# Déclarer et appeler une procédure dans process 1
@p1.wamp.remote('auth.signin')
def _(ctx, args):
    pass

# Déclarer et appeler une procédure dans process 2
@p2.wamp.event('auth.signedin')
def _(ctx, args):
    pass</pre>
<p>Ainsi on profite enfin de plusieurs CPU. La même chose en plus facile à changer:</p>
<pre lang="python"># Déclarer et appeler une procédure
@app.wamp.remote('auth.signin')
def _(ctx, args):
    pass

# Déclarer et appeler une procédure
@app.wamp.event('auth.signedin')
def _(ctx, args):
    pass

app.processes({
    1: ['wamp.remote:auth.signin']
    2: ['wamp.event:auth.signedin']
})</pre>
<p>En bonus, on fait la nique au GIL.</p>
<p>Mieux, on peut bouger ses process sur plusieurs machines :</p>
<p>Machine 1 (routeur):</p>
<pre lang="python">
router = Application(endpoint="0.0.0.0:8080")
router.run()
</pre>
<p>Machine 2 (authentification):</p>
<pre lang="python">
# IP du router
auth = Application('auth', connect_to="182.64.1.15:8080")

# Nommage automatique en fonction du nom de la fonction
# et de l'app, avec possibilité d'annuler ou overrider le prefix.
# Ici du coup la fonction s'appellera en RPC via 'auth.signin'
@auth.wamp.remote()
def signin(ctx, args):
    pass

auth.run()
</pre>
<p>Machine 3 (API REST):</p>
<pre lang="python">
web = Application('site', connect_to="182.64.1.15:8080")

@web.http.post(r'api/auth/')
def _(req, res):
    user = yield res.wamp.call('auth.signin',
                               req.POST['username'],
                               req.POST['password'])*
    if user
        user = yield res.wamp.pub('auth.signedin', user.userid)
        res.json({'token': user.token})
    else:
        res.json({'error': 'nope'})


@web.http.get(r'api/stuff/')
def _(req, res):
    res.json(get_stuff())

@web.http.serve('uri', '/path/to/dir', [allow_index])

web.run()
</pre>
<p>Et vous savez le plus beau dans tout ça ? En Python on a plein de libs qui sont encore bloquantes. En théorie on ne peut pas les utiliser dans les apps asynchrones. Quand on a toute sa logique métiers dans des classes d&#8217;ORM, c&#8217;est balot. Mais pas ici ! On met un process avec tous ces appels bloquants, et on les appelle depuis des process non bloquant en RPC de manière asynchrone. Pif, paf, pouf, problème isolé.</p>
<p>Après, libre à son imagination de rajouter des fonctionnalités de confort&#8230;</p>
<p>Callback qui sera appelé seulement x fois :</p>
<pre lang="python"># Déclarer et appeler une procédure
@p1.wamp.event('auth.signedin', options={'limit_calls': x} )
def _(ctx, args):
    pass</pre>
<p>Raccourcis pour les opérations courantes :</p>
<pre lang="python"># Recevoir et envoyer un événement
@app.sub('auth.signin')
def _(ctx, *args):
    # ctx.pub
@app.pub('auth.signedin')

# Déclarer et appeler une procédure
@app.proc('auth.signedin')
def _(ctx, args):
    # ctx.call
app.rpc()</pre>
<p>Comme je vous l&#8217;avais expliqué, crossbar peut gérer le cycle de vie de services externes à votre application au démarrage. Autant exposer cette API programativement :</p>
<pre lang="python">@app.service(['/urs/bin/nodejs', 'script.js'], [user], [group])</pre>
<p><code>.run()</code>, c&#8217;est cool, mais si on veut changer des options via la ligne de commande, faut se taper tout le boulot alors que ça pourrait très bien se générer automatiquement :</p>
<pre lang="python">@app.cmd_run()</pre>
<p>Et si vous faites : <code>python sites.py --debug=true --endpoint=0.0.0.0:5252</code>, ça le prend automatiquement en compte. Y a pas de raison de se faire chier.</p>
<p>En parlant de générer automatiquement des trucs, le fichiers de configs pour les services externes sur lesquels on peut avoir envie de brancher notre app, c&#8217;est toujours galère. Autant fournir un exemple de base qui est sûr de toujours marcher, généré avec les paramètres de notre app :</p>
<pre lang="bash">python site.py template centos:nginx
python site.py template ubuntu:upstart
python site.py template bsd:systemd # :D</pre>
<p>On peut partir très loin dans le délire &#8220;battery included&#8221;. Typiquement, on peut fournir des services externes nous même puisque crossbar nous le propose, et coder des versions moins bien, mais compatibles (et suffisantes pour les petits sites), de projets toujours utilses :</p>
<ul>
<li>cache (compatible redis)</li>
<li>live settings (compatible etcd) mais avec en prime un event wamp propagé à chaque</li>
<p>  changement de valeur</p>
<li>build (compatible, heu, j&#8217;en sais rien) qui s&#8217;occupe en tâche de fond de surveiller le >système de fichier et lancer les compilations, les minifications, les copies, les tests unittaires, etc.</li


<li>logging centralisé (compatible sentry).</li>
<li>Un bridge WAMP/REST qui permet d&#8217;envoyer et recevoir des events WAMP sur votre app Django ou flask en utilisant HTTP.</li>
</ul>
<p>On plug tout ça a une admin Web.</p>
<p>J&#8217;espère que je vous ai donné maintenant l&#8217;envie de vous plonger un peu plus dans cette techno, et peut être coder quelque chose avec.</p>
<p>Il n&#8217;y a plus d&#8217;excuses pour ne pas avoir de framework web next gen, ultime de la mort qui tue en Python. A part le fait qu&#8217;on soit des feignasses.</p>
<p>Ah, merde, on est foutus.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/le-potentiel-de-wamp-autobahn-et-crossbar-io/feed/</wfw:commentRss>
		<slash:comments>29</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">10380</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2014/06/tumblr_n3hz135rRO1r539hzo1_500.jpg" length="48460" type="image/jpg" />	</item>
	</channel>
</rss>
