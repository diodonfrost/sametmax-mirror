<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" >

<channel>
	<title>variables &#8211; Sam &amp; Max</title>
	<atom:link href="http://sametmax.com/tag/variables/feed/" rel="self" type="application/rss+xml" />
	<link>http://sametmax.com</link>
	<description>Du code, du cul</description>
	<lastBuildDate>Thu, 05 Sep 2019 08:22:03 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.7</generator>
<site xmlns="com-wordpress:feed-additions:1">32490438</site>	<item>
		<title>Si vous ne savez pas ce que contient une variable, vous ne comprenez pas le programme</title>
		<link>http://sametmax.com/si-vous-ne-savez-pas-ce-que-contient-une-variable-vous-ne-comprenez-pas-le-programme/</link>
		<comments>http://sametmax.com/si-vous-ne-savez-pas-ce-que-contient-une-variable-vous-ne-comprenez-pas-le-programme/#comments</comments>
		<pubDate>Tue, 12 Feb 2013 13:41:27 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Philo et culture]]></category>
		<category><![CDATA[Programmation]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[variables]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=4521</guid>
		<description><![CDATA[L'immense majorité des questions qu'on me pose sur le fonctionnement d'un programme (ou sur des détails dans les tutos) peut être résolu d'une seule manière. ]]></description>
				<content:encoded><![CDATA[<p>L&#8217;immense majorité des questions qu&#8217;on me pose sur le fonctionnement d&#8217;un programme (ou sur des détails dans les tutos) peut être résolu d&#8217;une seule manière. </p>
<p>En sachant ce qu&#8217;il y a dans les variables.</p>
<p>Un ordinateur est une machine à états. Les variables représentent cet état. Le seul moyen de comprendre ce que fait un programme, c&#8217;est de savoir à quel moment il est dans quel état.</p>
<p>Quand vous ne comprenez pas ce que fait un programme, la première et plus importante question à vous poser et donc :</p>
<p><strong>Que contient cette variable ?</strong></p>
<h2>Répondre à la question</h2>
<p>La beauté de Python, c&#8217;est qu&#8217;il vous permet de très facilement répondre à cette question par vous même. Tout ce que vous avez à faire c&#8217;est copier le code, le mettre dans un fichier (ou un shell), et le lancer.</p>
<p><strong>Ne restez pas passif devant un tuto.</strong> Vous n&#8217;en comprendrez que la moitié (au mieux).</p>
<p>Un tuto, une doc, un cours, un snippet ne se lit pas, il se travaille. </p>
<p>Voici tout ce que vous pouvez faire à une variable pour obtenir des informations sur elle :</p>
<pre lang="python">>>> i = 1
>>> print(i) # afficher la variable
1
>>> print(type(i)) # afficher son type
<type 'int'>
>>> print(i.__class__) # afficher la classe dont elle est issue
<type 'int'>
>>> print(i.__class__.__name__) # affiche le nom de sa classe
>>> print(dir(i)) # afficher les méthodes de cet objet
['__abs__', '__add__', '__and__', '__class__', '__cmp__', '__coerce__', '__delattr__', '__div__', '__divmod__', '__doc__', '__float__', '__floordiv__', '__format__', '__getattribute__', '__getnewargs__', '__hash__', '__hex__', '__index__', '__init__', '__int__', '__invert__', '__long__', '__lshift__', '__mod__', '__mul__', '__neg__', '__new__', '__nonzero__', '__oct__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdiv__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'bit_length', 'conjugate', 'denominator', 'imag', 'numerator', 'real']
>>> help(i) # aide sur cet objet
Help on int object:

class int(object)
 |  int(x[, base]) -> integer
 |  
 |  Convert a string or number to an integer, if possible.  A floating point
 |  argument will be truncated towards zero (this does not include a string
 |  representation of a floating point number!)  When converting a string, use
 |  the optional base.  It is an error to supply a base when converting a
 |  non-string.  If base is zero, the proper base is guessed based on the
 |  string content.  If the argument is outside the integer range a
 |  long object will be returned instead.
 |  
 |  Methods defined here:
 |  
 |  __abs__(...)
 |      x.__abs__() <==> abs(x)
...</pre>
<p>Ces informations répondent à la question &#8220;qu&#8217;est-ce que c&#8217;est&#8221;, &#8220;comment c&#8217;est configuré&#8221; et &#8220;qu&#8217;est-ce que ça peut faire&#8221;.</p>
<p>C&#8217;est très important. Vous ne pouvez pas comprendre ce que fait un programme sans ces informations.</p>
<h2>En Python une variable peut contenir n&#8217;importe quoi</h2>
<p>J&#8217;ai dis <strong>n&#8217;importe quoi</strong>.</p>
<p>Pas juste les types de base :</p>
<pre lang="python">>>> i = 'a'
>>> type(i)
<type 'str'>
>>> i = {}
>>> type(i)
<type 'dict'>
>>> i = []
>>> type(i)
<type 'list'></pre>
<p>Ni même juste des résultats de fonctions :</p>
<pre lang="python">>>> i = test()
>>> type(i)
<type 'int'></pre>
<p>Non. Les variables Python peuvent contenir <strong>les fonctions elles-même</strong> !</p>
<pre lang="python">>>> type(test)
<type 'function'>
>>> i = test
>>> i()
1
>>> type(i)
<type 'function'></pre>
<p>Et là ça devient important de savoir de quoi on parle :</p>
<pre lang="python">>>> i.__name__
'test'</pre>
<p>Mais les variables peuvent aussi contenir des instances de vos classes :</p>
<pre lang="python">>>> class Essai(object):
...     pass
... 
>>> i = Essai()
>>> type(i)
<class '__main__.Essai'></pre>
<p>Sauf que les variables peuvent aussi contenir <strong>les classes elles-même</strong> !</p>
<pre lang="python">>>> type(Essai) # les classes sont de type 'type'. Funky !
<type 'type'>
>>> i = Essai # ceci n'est PAS une instance. Ce n'est PAS Essai().
>>> type(Essai)
<type 'type'>
>>> i.__class__
<type 'type'>
>>> i.__name__
'Essai'</pre>
<p>Les fonctions et les classes ne sont pas juste des noms en Python. Ce sont des choses que vous pouvez manipuler. Donc on les retrouve dans des variables.   </p>
<p>Donc vous n&#8217;avez pas le choix. Vous devez savoir de quoi on parle. Et il faut donc bien comprendre ce qu&#8217;est un type, et qu&#8217;est-ce qui est de quel type :</p>
<pre lang="python">>>> type(str) # str est une classe
<type 'type'>
>>> type(str()) # le résultat de l'appel de str est une string
<type 'str'>
>>> type(Essai) # Essai est une classe
<type 'type'>
>>> type(Essai()) # le résultat de l'appel de Essai est un objet Essai
<class '__main__.Essai'>
>>> type('1') # '1' est une string
<type 'str'>
>>> type(1) # 1 est un int
<type 'int'>
>>> type(True)
<type 'bool'> # True est un boolean
</pre>
<p>Si vous ne comprenez pas les types, vous ne pouvez PAS comprendre un programme. </p>
<p>Ce n&#8217;est pas honteux. Arrêtez d&#8217;essayer un truc impossible, c&#8217;est tout. Revenez en arrière. Allez apprendre ce qu&#8217;est un type x ou z. </p>
<p>Puis retournez essayer de comprendre le programme. </p>
<p>Il n&#8217;y a PAS d&#8217;alternative.</p>
<p> <strong>Quand vous lisez un programme, vous devez savoir ce qu&#8217;il y a dans une variable</strong> :</p>
<ul>
<li>quel est son type ?</li>
<li>quelle est sa valeur ?</li>
<li>qu&#8217;est-ce que je peux faire avec (méthodes, attributs, etc) ?</li>
</ul>
<h2>Pdb à la rescousse</h2>
<p>Donc quand vous lisez un tuto, vous allez copier / coller du code. Vous allez le lancer. Si vous ne le faites pas, vous ne comprendrez pas.</p>
<p>Maintenant, dans un premier temps vous allez utiliser des print.</p>
<p><code>print type(truc)<br />
print truc.__class__<br />
print dir(truc)</code></p>
<p>Et pour les fonctions et les classes :</p>
<p><code>print truc.__name__</code></p>
<p>Mais on peut faire mieux. Utilisez le debugger de Python intégré : PDB. J&#8217;ai écrit <a href="http://sametmax.com/debugger-en-python-les-bases-de-pdb/">un bon article sur la question</a>, mais pour résumer, quand vous voulez avoir des informations sur une variable dans un programme, juste avant la variable faites :</p>
<p><code>import ipdb; ipdb.set_trace()</code></p>
<p>Puis lancez le programme. Un shell va s&#8217;ouvrir, bloquant le programme à cet endroit. Et vous pourrez manipuler la variable <strong>à ce moment du programme</strong>.</p>
<p>Pour quitter, entrez <code>q</code>.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/si-vous-ne-savez-pas-ce-que-contient-une-variable-vous-ne-comprenez-pas-le-programme/feed/</wfw:commentRss>
		<slash:comments>11</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">4521</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2013/02/inside-a-jet-engine.jpg" length="694476" type="image/jpg" />	</item>
		<item>
		<title>Valeurs et références en Python</title>
		<link>http://sametmax.com/valeurs-et-references-en-python/</link>
		<comments>http://sametmax.com/valeurs-et-references-en-python/#comments</comments>
		<pubDate>Mon, 12 Nov 2012 19:28:28 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[variables]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=2869</guid>
		<description><![CDATA[Il y a plusieurs manière de passer une variable en informatique: par valeur ou par référence. Et dans les langages bas niveau comme le C, on se pose la question: "passe-t-on la valeur ? un pointer ? un pointer vers un pointer ?"

En Python ce n'est pas la question puisque tout se passe référence. Tous les objets. Dans tous les cas.

La question est donc plutôt: "ça veut dire quoi passer par référence ?"]]></description>
				<content:encoded><![CDATA[<p>Petit article en complément de <a href="http://sametmax.com/id-none-et-bidouilleries-memoire-en-python/">l&#8217;article de Réchèr</a>.</p>
<p>Il y a plusieurs manières de passer une variable en informatique: par valeur ou par référence. Et dans les langages bas niveau comme le C, on se pose la question: &#8220;passe-t-on la valeur ? un pointer ? un pointer vers un pointer ?&#8221;</p>
<p>En Python ce n&#8217;est pas la question puisque tout se passe par référence. Tous les objets. Dans tous les cas.</p>
<p>La question est donc plutôt: &#8220;ça veut dire quoi passer par référence ?&#8221;</p>
<h2>Assignation et référence</h2>
<p>Une référence est comme une adresse qui dit où la donnée se trouve en mémoire.</p>
<p>Quand vous faites ceci:</p>
<pre lang="python">a = [1, 2, 3]</pre>
<p>Vous n&#8217;assignez pas la liste à la variable &#8220;a&#8221;, vous assignez une référence vers la liste, donc une sorte d&#8217;adresse qui indique où elle se trouve en mémoire. (en vérité vous n&#8217;assignez rien, les variables sont des étiquettes en Python, mais on va ignorer ce détail ici).</p>
<p>Et quand vous faites:</p>
<pre lang="python">print a</pre>
<p>Python va chercher dans <code>a</code> la référence, et retrouver la liste en suivant &#8220;l&#8217;adresse&#8221;.</p>
<p>C&#8217;est important car ça veut dire deux choses.</p>
<p>1. Quand vous faites ça:</p>
<pre lang="python">b = a</pre>
<p>Vous ne copiez pas la liste. Vous copiez la référence. Du coup, on ne prend pas deux fois la place en mémoire, et la copie est très rapide</p>
<p>2. Quand vous faites ça:</p>
<pre lang="python">b = a</pre>
<p>Vous ne copiez pas la liste. Vous copiez la référence. Bis.</p>
<p>Et si vous faites:</p>
<pre lang="python">b.append(4)</pre>
<p>Alors:</p>
<pre lang="python">print a</pre>
<p>Va donner&#8230;</p>
<pre lang="python">[1, 2, 3, 4]</pre>
<p>Car en faisant <code>append()</code> sur <code>b</code>, Python va trouver une référence, retrouver la liste derrière la référence, et faire un <code>append()</code> sur la liste. Comme c&#8217;est la même réference dans <code>a</code> et <code>b</code> (puisqu&#8217;on l&#8217;a copié), c&#8217;est la même liste derrière. Tout ce qu&#8217;on applique à <code>a</code>, s&#8217;applique donc à <code>b</code>, et vice-versa.</p>
<p>Si vous voulez faire une vraie copie, alors il faut recréer une toute nouvelle liste. Par exemple:</p>
<pre lang="python">b = list(a)</pre>
<h2>Mutable et non mutable</h2>
<p>L&#8217;assignation par référence n&#8217;a vraiment d&#8217;importance que dans le cas où un objet est mutable. En Python, il existe en effet deux types d&#8217;objets: les mutables (listes, dictionnaires, sets, objets custo, etc) et les non mutables (strings, int, floats, tuples, etc).</p>
<p>Les mutables sont ceux qu&#8217;on peut modifier après leur création. Les non mutables sont ceux qu&#8217;on ne peut pas modifier après création.</p>
<p>On ne peut pas modifier <code>152</code> une fois que l&#8217;objet int est créé. Mais on peut rajouter des éléments à une liste après qu&#8217;elle soit créée. Les ints sont non mutables. Les lists sont mutables.</p>
<p>Cela peut surprendre, mais les strings sont non mutables. Même quand vous faites:</p>
<pre lang="python">>>> pa = "papa"
>>> pi = pa.replace("a", "i")
>>> print pa
papa
>>> print pi
pipi</pre>
<p>Vous ne modifiez pas la chaîne originale: vous créez une copie de la chaîne, et la chaîne de départ n&#8217;a pas bougé.</p>
<p>C&#8217;est important car si on fait une référence vers un type non mutable, on s&#8217;en oint le pourtour anal avec pelle à tarte: il ne peut pas être modifié. Peu importe que la référence soit copiée à droite et à gauche. Mais si l&#8217;objet est mutable, chaque copie de la référence ajoute un endroit dans le programme duquel on peut modifier l&#8217;objet.</p>
<p>Cela a des implications parfois assez coquines.</p>
<p>Ainsi:</p>
<pre lang="python">>>> l = [0] * 3
>>> l # une liste de 3 zéros
[0, 0, 0]
>>> l[1] += 1
>>> l
[0, 1, 0]</pre>
<p>Ici tout se comporte comme prévu. Les ints sont non mutables, donc on ne s’aperçoit pas d&#8217;un détail important: <code>[0] * 3</code> copie la référence à <code>0</code> trois fois. Quand on fait <code>+=</code>, ça remplace l&#8217;ancien int par un nouveau, donc un seul item de la liste est changé.</p>
<p>Mais si on fait vicieusement:</p>
<pre lang="python">>>> l = [[0]] * 3
>>> l # une liste de listes d'un seul zéro chacune
[[0], [0], [0]]
>>> l[1][0] += 1
>>> l
[[1], [1], [1]]</pre>
<p>Ici on a copié 3 fois la référence vers la même liste. Du coup une modification affecte les 3 items. Doh.</p>
<p>Rappels: les tuples ne sont pas mutables. Et on peut passer d&#8217;un tuple à une liste avec <code>tuple(l)</code> et <code>list(t)</code>. Pensez-y si vous rencontrez ce genre de problème.</p>
<h2>Passage des arguments de fonction par référence</h2>
<p>Quand vous faites cela:</p>
<pre lang="python">def encore_une_fonction_d_exemple_inutile(l):
    l.append(4)
    return l

>>> l1 = [1, 2, 3]
>>> encore_une_fonction_d_exemple_inutile(l1)
>>> print l1
[1, 2, 3, 4]</pre>
<p>Vous noterez que la liste a été modifiée. C&#8217;est parce que l&#8217;on passe une référence à la liste quand on la passe en argument. Toute modification de la liste dans la fonction est donc visible en dehors de la fonction. Si le paramètre était immutable, encore une fois on s&#8217;en ficherait. Mais là, comme liste est mutable, notre fonction possède ce qu&#8217;on nomme un effet de bord: quand on l&#8217;appelle, elle a des conséquences sur des objets qui existent en dehors d&#8217;elle même.</p>
<p>Il est généralement de bon ton d&#8217;éviter les effets de bord, aussi, essayez toujours de travailler sur des copies: utilisez le slicing, les listes en intention, les générateurs, etc., pour retourner les nouvelles valeurs plutôt que de modifier l&#8217;objet original.</p>
<p>Ici:</p>
<pre lang="python">def encore_une_fonction_d_exemple_inutile(l):
    return l1 + [4]</pre>
<p>Nous permet de retourner une nouvelle liste. Si la liste prend beaucoup de place en mémoire, on peut faire ça:</p>
<pre lang="python">def encore_une_fonction_d_exemple_inutile(l):

    for x in l:
        yield x
    yield 4</pre>
<p>Ce qui aurait pour effet de retourner un itérable similaire, sans prendre plus de mémoire.</p>
<h2>Valeurs par défaut et référence</h2>
<p>Quand on utilise une valeur par défaut, par exemple dans la déclaration des paramètres d&#8217;une fonction, on initialise une référence qui va rester la même pour toute la durée du programme.</p>
<pre lang="python">def encore_une_fonction_d_exemple_inutile(l=[1, 2, 3]):
    l.append(4)
    return l

>>> encore_une_fonction_d_exemple_inutile()
>>> encore_une_fonction_d_exemple_inutile()
>>> print l1
[1, 2, 3, 4, 4]</pre>
<p>On constate ici que <code>4</code> a été ajouté deux fois dans la liste. En effet, l est l&#8217;argument par défaut, et ici, il est initialisé à la référence pointant sur une liste <code>[1, 2, 3]</code>. Pas sur la valeur <code>[1, 2, 3]</code>. <code>[1, 2, 3]</code> est stocké quelque part dans un monde invisible que seul Guido Van Rossum connait, et <code>l</code> contient juste la référence à cette liste.</p>
<p>Cette référence est gardée, et à chaque appel, c&#8217;est la même liste qui est utilisée. Si on appelle deux fois la fonction, la première fois c&#8217;est la liste <code>[1, 2, 3, 4]</code> à laquelle on ajoute <code>4</code>. Puis comme c&#8217;est la même référence, on ajoute ensuite <code>4</code> à la même liste, à laquelle on avait déjà ajouté <code>4</code>.</p>
<p>Bref, évitez les mutables dans les paramètres par défaut à moins de savoir ce que vous faites (cache ou memoization).</p>
<h2>Variables de classe et références</h2>
<p>La même problématique existe pour les classes. Si vous faites:</p>
<pre lang="python">class AuChocolat(objet):

    supplements = ['chantilly', 'praline']

>>> g1 = AuChocolat()
>>> g2 = AuChocolat()
>>> g1.supplements.pop()
'praline'
>>> g2.supplements
['chantilly']</pre>
<p>Même principe: toute variable de classe pointe pour toute la durée du programme sur la même réference. La référence va être partagée entre toutes les instances de la classe. C&#8217;est donc la même liste !</p>
<h2>Maintient d&#8217;une référence</h2>
<p>Python garde un objet en mémoire tant qu&#8217;il existe une référence vers cet objet.</p>
<pre lang="python">>>> a = 1
>>> b = a
>>> del a
>>> print b
1</pre>
<p>Si je supprime <code>a</code>, il reste <code>b</code>, donc l&#8217;objet est toujours en mémoire. Si je supprime <code>b</code> également, Python va lancer le processus de nettoyage pour effacer l&#8217;objet de la mémoire.</p>
<p>Une référence existe toujours dans le cadre d&#8217;un scope. Par exemple, si une référence est copiée dans une fonction, quand la fonction se termine, la copie de la référence est supprimée, et ne compte plus comme une voix pour le maintient de l&#8217;objet en mémoire.</p>
<p>En Python, il n&#8217;existe donc aucun moyen de supprimer un objet. On peut juste supprimer toutes ses références, et attendre que Python s&#8217;aperçoive que tout le monde s&#8217;en branle à présent de l&#8217;objet, et le supprime.</p>
<p>Dans certains cas particuliers, on veut qu&#8217;une référence à un objet ne compte pas comme une voix. On peut le faire en utilisant le module <code>weakref</code>, mais cela ne marche qu&#8217;avec les classes que l&#8217;on code soit-même.</p>
<pre lang="python">class ALaVanille(object):
    pass

>>> import weakref
>>> g1 = ALaVanille()
>>> g2 = weakref.proxy(g1)
>>> g2
<weakproxy at 0x7f5f26994730 to ALaVanille at 0x7f5f26992d90>
>>> g1.foo = "bar"
>>> g2.foo
'bar'
>>> del g1
>>> g2
<weakproxy at 0x7f5f26994730 to NoneType at 0x859380>
</pre>
<p>Dès qu&#8217;on supprime <code>g1</code>, <code>g2</code> proxy vers <code>None</code>, car la référence vers l&#8217;instance de <code>ALaVanille</code> ne compte pas pour garder en vie l&#8217;objet.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/valeurs-et-references-en-python/feed/</wfw:commentRss>
		<slash:comments>23</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">2869</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2012/11/th1.jpeg" length="8700" type="image/jpg" />	</item>
	</channel>
</rss>
