<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" >

<channel>
	<title>collections &#8211; Sam &amp; Max</title>
	<atom:link href="http://sametmax.com/tag/collections/feed/" rel="self" type="application/rss+xml" />
	<link>http://sametmax.com</link>
	<description>Du code, du cul</description>
	<lastBuildDate>Thu, 05 Sep 2019 08:22:03 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.7</generator>
<site xmlns="com-wordpress:feed-additions:1">32490438</site>	<item>
		<title>Récupérer le premier et le dernier élément d&#8217;un OrderedDict</title>
		<link>http://sametmax.com/recuperer-le-premier-et-le-dernier-element-dun-ordereddict/</link>
		<comments>http://sametmax.com/recuperer-le-premier-et-le-dernier-element-dun-ordereddict/#comments</comments>
		<pubDate>Tue, 22 Mar 2016 18:18:11 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[collections]]></category>
		<category><![CDATA[dict]]></category>
		<category><![CDATA[orderedidct]]></category>
		<category><![CDATA[python]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=18724</guid>
		<description><![CDATA[<code>collections.OrderedDict</code> est une structure de données que j'utilise de plus en plus, surtout que sa réécriture en C en 3.5 lui donne des performances décentes.]]></description>
				<content:encoded><![CDATA[<p><code>collections.OrderedDict</code> est une structure de données que j&#8217;utilise de plus en plus, surtout que sa réécriture en C en 3.5 lui donne des performances décentes.</p>
<p>Néanmoins, il n&#8217;y a pas dans l&#8217;API de moyen de récupérer le premier ou le dernier élément inséré dans dico. Il y a bien <code>popitem()</code>, mais ça retire l&#8217;élément du dictionnaire, et c&#8217;est pas forcément ce qu&#8217;on veut.</p>
<p>Heureusement <code>OrderedDict</code> est un itérable, et implémente <code>__reversed__</code>, et on peut donc utiliser les outils suivant our récupérer les extrémités avec une perf 0(1):</p>
<pre lang="python">>>> from collections import OrderedDict
>>> d = OrderedDict.fromkeys('azerty')
>>> next(iter(d.items())) # premier élément
'a'
>>> next(reversed(d.items())) # dernier élément
'y'</pre>
<p>Après l&#8217;implémentation de <code>OrderedDict</code> reste une liste doublement chainée, et on ne peut donc pas récupérer un élément à un index arbitraire sans le parcourir à la main&#8230;</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/recuperer-le-premier-et-le-dernier-element-dun-ordereddict/feed/</wfw:commentRss>
		<slash:comments>15</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">18724</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2016/03/7SiQSD1.jpg" length="22422" type="image/jpg" />	</item>
		<item>
		<title>Compter et  grouper : encore plus fainéant</title>
		<link>http://sametmax.com/compter-et-grouper-encore-plus-faineant/</link>
		<comments>http://sametmax.com/compter-et-grouper-encore-plus-faineant/#comments</comments>
		<pubDate>Wed, 01 Jul 2015 19:37:12 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[collections]]></category>
		<category><![CDATA[counter]]></category>
		<category><![CDATA[dict]]></category>
		<category><![CDATA[python]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=16529</guid>
		<description><![CDATA[Après avoir bien galéré à créer un compteur à la main avec un dico, <a href="http://sametmax.com/aller-plus-loin-avec-les-hash-maps-en-python/">vous avez découvert</a> les joies des méthodes <code>dict.get</code> et <code>dict.setdefault</code>. Puis évidemment quelqu'un vous a pointé vers <code>collections.defaultdict</code>, et enfin, vous avez fini par découvrir <code>collections.Counter</code>. Joie.]]></description>
				<content:encoded><![CDATA[<p>Après avoir bien galéré à créer un compteur à la main avec un dico, <a href="http://sametmax.com/aller-plus-loin-avec-les-hash-maps-en-python/">vous avez découvert</a> les joies des méthodes <code>dict.get</code> et <code>dict.setdefault</code>. Puis évidemment quelqu&#8217;un vous a pointé vers <code>collections.defaultdict</code>, et enfin, vous avez fini par découvrir <code>collections.Counter</code>. Joie.</p>
<p>Le parcours est à peu près toujours le même quand on veut grouper ou compter des valeurs en Python.</p>
<p>Malgré cela, je vois encore des gens qui sous utilisent ces collections. Par exemple, <code>Counter</code> peut compter automatiquement :</p>
<pre lang="python">>>> from collections import Counter
>>> Counter('jfsqmfjdklmqfjsdqklmfjdsqhfdqsjkhfdshjkl')
    Counter({'j': 6, 'f': 6, 'q': 5, 's': 5, 'd': 5, 'k': 4, 'l': 3, 'm': 3, 'h': 3})
</pre>
<p>Mais ce que ne réalisent pas beaucoup de développeurs, c&#8217;est que cet objet accepte n&#8217;importe quel itérable en paramètre. Nous sommes en Python, et rededjiou, je me tue à répéter que l&#8217;itération est la philosophie centrale du langage.</p>
<p>Donc le compteur peut prendre une expression génératrice en paramètre.</p>
<p>Par exemple, si vous voulez compter un truc un peu plus complexe que des éléments, comme mettons, le ratio de lignes commentées dans un fichier, vous n&#8217;avez pas besoin de faire ça :</p>
<pre lang="python">count = Counter()
for line in open('/etc/fstab', encoding='ascii'):
        count[line.startswith('#')] += 1
 # out : Counter({True: 10, False: 3})
</pre>
<p>Ceci marchera parfaitement :</p>
<pre lang="python">count = Counter(line.startswith('#') for line in open('/etc/fstab', encoding='ascii'))
# out : Counter({True: 10, False: 3})</pre>
<p>Vous pouvez également utiliser des générateurs plus complexes. Combien de fichiers par types d&#8217;extensions ?</p>
<pre lang="python">import os
import pathlib

def get_extensions(path):
    for dirpath, dirnames, files in os.walk(path):
        for name in files:
            ext = pathlib.Path(name).suffix
            if ext: # on ignore les fichiers sans extension
                yield ext
            

Counter(get_extensions('/etc')).most_common(9)
 # Out : 
 # ('.conf', 632),
 # ('.0', 348),
 # ('.gz', 323),
 # ('.jhansonxi', 207),
 # ('.pem', 177),
 # ('.load', 127),
 # ('.ttb', 86),
 # ('.ktb', 80),
 # ('.kti', 55)]</pre>
<p>Notez que le <code>Counter</code> peut faire plus que compter. Ici il nous donne les 9 plus grandes valeurs du classement, mais en prime, il peut aussi nous faire des opérations ensemblistes :</p>
<pre lang="python">>>> c = Counter("aabbbbbbbbbbbbcccc")
>>> c & Counter('aaaaaaaaaaaaaaabbcddddddd') # valeurs min
    Counter({'b': 2, 'a': 2, 'c': 1})
>>> c | Counter('aaaaaaaaaaaaaaabbcddddddd') # valeurs max
    Counter({'a': 15, 'b': 12, 'd': 7, 'c': 4})</pre>
<p>Le compteur fournit par Python est donc naturellement très, très puissant.</p>
<p>Une autre chose qui est rarement faite : sous-classer ces types.</p>
<p>Par exemple, si vous avez souvent des opérations où il faut grouper des valeurs :</p>
<pre lang="python">from collections import defaultdict

class Grouper(defaultdict):
 
    def __init__(self, iterable):
        super(Grouper, self).__init__(list)
        self.update(iterable)
 
    def update(self, iterable):
        try:
            iterable = iterable.items()
        except AttributeError:
            iterable = iterable
        for k, v in iterable:
            self[k].append(v)</pre>
<p>On prend un default dict, on lui dit qu&#8217;un update ajoute les éléments à la liste en valeur plutôt que de la remplacer, et zou, vous avez un dictionnaire qui va grouper toutes les valeurs automatiquement.</p>
<p>Liste des fichiers par extensions ? Fastoche !</p>
<pre lang="python">def get_extensions(path):
    for dirpath, dirnames, files in os.walk(path):
        for name in files:
            ext = pathlib.Path(name).suffix
            if ext: 
                yield ext, name # on rajoute le name ici

>>>files = Grouper(get_extensions('/etc'))
>>> files['.tti']
['en-na-ascii.tti',
 'numbers-french.tti',
 'devanagari.tti',
 'letters-cyrillic.tti',
 'punctuation-basic.tti',
 'malayalam.tti',
 'ascii-basic.tti',
 'spaces.tti',
 'letters-latin.tti',
 'letters-latin-dot8.tti',
 'en-chess.tti',
 'numbers-dot8.tti',
 'punctuation-tibetan.tti',
 'boxes.tti',
 'gujarati.tti',
 'numbers-nemeth.tti',
 'punctuation-alternate.tti',
 'common.tti',
 'blocks.tti',
 'gurmukhi.tti',
 'kannada.tti',
 'telugu.tti',
 'tamil.tti',
 'numbers-dot6.tti',
 'de-chess.tti',
 'control-latin.tti',
 'letters-tibetan.tti',
 'oriya.tti',
 'bengali.tti']</pre>
<p>Bref, compter et grouper sont des opérations si communes : ne vous faites par chier à refaire tout ça à la main.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/compter-et-grouper-encore-plus-faineant/feed/</wfw:commentRss>
		<slash:comments>6</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">16529</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2015/07/DVKgxFH.gif" length="510930" type="image/jpg" />	</item>
		<item>
		<title>Heapq, le module Python incompris</title>
		<link>http://sametmax.com/heapq-le-module-python-incompris/</link>
		<comments>http://sametmax.com/heapq-le-module-python-incompris/#comments</comments>
		<pubDate>Fri, 21 Dec 2012 17:23:44 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[collections]]></category>
		<category><![CDATA[heapq]]></category>
		<category><![CDATA[iterable]]></category>
		<category><![CDATA[list]]></category>
		<category><![CDATA[python]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=3813</guid>
		<description><![CDATA[heapq est un algorythme qui organise une liste sous forme d'arbre binaire. Vous voyez c'était simple non ? Non ?]]></description>
				<content:encoded><![CDATA[<p>Guido Van Rossum, notre-Dieu-à-tous-beni-soit-il, a un jour accepté de faire une session de questions-réponses publique, dans laquelle un petit malin lui a demandé &#8220;<a href="http://neopythonic.blogspot.fr/2008/10/sorting-million-32-bit-integers-in-2mb.html">Comment ordonner un million d&#8217;entiers 32 bits dans 2Mo de Ram avec Python</a>&#8220;.</p>
<p>Ca aurait été sur ce blog, le mec se serait pris un tampon &#8220;drozophiliafucker&#8221; dans la gueule et ça aurait été plié. Mais quand on est BDFL et, à l&#8217;époque, employé chez Google, on est obligé de donner une réponse un peu sérieuse.</p>
<p>Si vous avez suivi le lien précédent, vous verrez que sa réponse implique un obscure module appelé heapq. Si vous allez sur <a href="http://docs.python.org/2/library/heapq.html">la doc</a> du-dit module, vous verrez qu&#8217;elle implique une obscure explication innomable et vous aller retourner à la vidéo de porn que vous avez laissé bufferiser en haute résolution afin de pouvoir voir les grains de beauté qui longent le pourtour anal de la principale protagoniste. Respirons. </p>
<h2>Il y a une explication rationnelle à tout cela</h2>
<p>heapq est un algorithme qui organise une liste sous forme d&#8217;arbre binaire. Vous voyez c&#8217;était simple non ?</p>
<p>Nan je déconne, je vais pas vous laisser avec ça quand même.</p>
<p>Le module heapq permet d&#8217;utiliser le type &#8220;list&#8221; pour y ajouter ou retirer les éléments de telle sorte qu&#8217;ils soient toujours dans l&#8217;ordre.</p>
<p>Sous le capot, ça marche effectivement avec un arbre binaire, mais on s&#8217;en branle. Tout ce qu&#8217;il faut comprendre c&#8217;est:</p>
<pre lang="python">>>> from heapq import heappush, heappop
>>> l = []
>>> heappush(l, 69)
>>> heappush(l, 42)
>>> heappush(l, 2048)
>>> heappush(l, -273.15)
>>> l # la liste est ordonnée en arbre binaire...
[-273.15, 42, 2048, 69]
>>> for x in xrange(len(l)): # et on depop pour itérer dans l'odre
    print heappop(l)
...     
-273.15
42
69
2048

</pre>
<p>Donc on a une liste, on lui met des éléments dans la tronche dans n&#8217;importe quel ordre, et bam, on peut itérer dans le bon ordre sans avoir à rien faire. Et cette insertion est assez rapide (O(lg n) pour les tatillons). Le parcours l&#8217;est également (de l&#8217;ordre de O(n log n)).</p>
<p>Et donc c&#8217;est très pratique pour trouver les x plus petits éléments (ou les plus grands), implémenter des queues de priorité, etc.</p>
<p>Exemple de queue de priorité, (courageusement <a href="http://joernhees.de/blog/2010/07/19/min-heap-in-python/">volé d&#8217;ici</a>):</p>
<pre lang="python">import heapq

class PriorityQueue(list):

    def __init__(self, data):
        super(Heap, self).__init__()
        for i, x in enumerate(data):
            self.push(i, x)
   
    def push(self, priority, item):
        """
            On push en rajoute une priorité
        """
        heapq.heappush(self, (priority, item))
   
    def pop(self):
        """
            On pop en retirant la proprité
        """
        return heapq.heappop(self)[1]
   
    def __len__(self):
        return len(self)
   
    def __iter__(self):
        """
            Comme on a une méthode next(), on peut se retourner soi-même.
            Ainsi la boucle for appelera next() automatiquement. 
        """
        return self
   
    def next(self):
        """ 
           On depop la liste du plus petit au plus grand.
        """
        try:
            return self.pop()
        except IndexError:
            raise StopIteration

>>> l = PriorityQueue(("azerty"))
>>> l
>>> l.push(100, 'après')
>>> l.push(-1, 'avant')
>>> l.push(5, 'pendant')
>>> for x in l:
...     print x
...     
avant
a
z
e
r
t
pendant
y
après</pre>
<p>Et le plus beau, c&#8217;est qu&#8217;on peut prendre plusieurs itérables ordonnés, et utiliser <code>heapq.merge</code> pour obtenir un générateur (qui ne charge pas tout en mémoire d&#8217;un coup) qui va permettre d&#8217;iterer de manière ordonnée sur tous les éléments.</p>
<pre lang="python">>>> import heapq
>>> l1 = sorted([random.randint(0, 1000) for x in xrange(5)])
>>> l2 = sorted([random.randint(0, 1000) for x in xrange(5)])
>>> l3 = sorted([random.randint(0, 1000) for x in xrange(5)])
>>> list(heapq.merge(l1, l2, l3))
[52, 59, 60, 171, 174, 262, 336, 402, 435, 487, 557, 645, 899, 949, 996]</pre>
<p>Notez que ce n&#8217;est pas du tout la même chose que de concaténer les listes:</p>
<pre lang="python">>>> l1 + l2 + l3
[59, 174, 336, 487, 996, 52, 171, 557, 645, 949, 60, 262, 402, 435, 899]</pre>
<p>Car des élements de <code>l2</code> peuvent être inférieurs à ceux de <code>l1</code>. <code>heap.merge</code> nous ordonne tout bien correctement. C&#8217;est l&#8217;équivalent de <code>sorted(l1 + l2 + l3)</code>, sauf que ça ne charge pas tout en mémoire:</p>
<pre lang="python">>>> heapq.merge(l1, l2, l3)
<generator object merge at 0x0314F238></pre>
<p>Alors que <code>sorted()</code>, charge tout en mémoire:</p>
<pre lang="python">>>> sorted(l1 + l2 + l3)
[52, 59, 60, 171, 174, 262, 336, 402, 435, 487, 557, 645, 899, 949, 996]</pre>
<p><del datetime="2012-12-21T17:35:16+00:00">Bien entendu, ça marche avec des listes créées avec </del><br />
<del datetime="2012-12-21T17:35:16+00:00"><code>heapq</code>, ainsi:</del></p>
<p><del datetime="2012-12-21T17:35:16+00:00">>>> l1 = []</del></p>
<p><del datetime="2012-12-21T17:35:16+00:00">>>> for x in xrange(5): heappush(l1, random.randint(0, 1000))</del></p>
<p><del datetime="2012-12-21T17:35:16+00:00">>>> l2 = []</del></p>
<p><del datetime="2012-12-21T17:35:16+00:00">>>> for x in xrange(5): heappush(l2, random.randint(0, 1000))</del></p>
<p><del datetime="2012-12-21T17:35:16+00:00">>>> l3 = []</del></p>
<p><del datetime="2012-12-21T17:35:16+00:00">>>> for x in xrange(5): heappush(l3, random.randint(0, 1000))</del></p>
<p><del datetime="2012-12-21T17:35:16+00:00">>>> list(heapq.merge(l1, l2, l3))</del></p>
<p><del datetime="2012-12-21T17:35:16+00:00">[31, 40, 133, 360, 504, 508, 513, 679, 645, 792, 838, 413, 765, 886, 924]</del></p>
<p><em>(Grosse connasserie de ma part, faites comme si vous aviez rien vu.)</em></p>
<p>Quand on a de grosses quantités de données à trier, c&#8217;est très pratique, car l&#8217;effort de tri est répartie à chaque insertion, et à chaque itération pendant le parcours, pas concentré sur de gros appels de <code>sorted()</code>.</p>
<p>On peut aussi récupérer des trucs du genre, les n plus petits / grands éléments sans tout coder à la main:</p>
<pre lang="python">>>> l = [random.randint(0, 1000) for x in xrange(100)]
>>> heapq.nsmallest(4, l)
[0, 2, 4, 7]
>>> heapq.nlargest(3, l)
[999, 996, 983]</pre>
<p>Et c&#8217;est beaucoup plus efficace que de le faire soi-même.</p>
<p>J&#8217;en profite pour rappeler au passage que tous les objets en Python sont ordonnables:</p>
<pre lang="python">>>> (1, 2) > (2, 1)
False
>>> (1, 2) < (2, 1)
True
>>> "a" > "b"
False
>>> "a" < "b"
True</pre>
<p>Et qu'en définissant les méthodes <a href="http://docs.python.org/2/reference/datamodel.html#object.__eq__">__eq_</a>_, <code>__lt__</code>, <code>__gt__</code>, etc., on peut donner un moyen de <a href="http://wiki.python.org/moin/HowTo/Sorting">comparer n'importe quelle classe</a>.</p>
<p>Bref, pour tous les besoins de classement, de priorisations, d'ordonnancement, de notion de plus petits, de plus grands, etc. qui concernent un gros jeu de données, <code>heapq</code> est le module qu'il vous faut.</p>
<p>Et là je percute que ça fait quelque temps déjà que je fais des articles élitistes pour des uses cases de 1% de la population. Donc les prochains tutos concerneront des trucs plus terre à terre. Parce que, je fais le malin là, mais je savais pas à quoi servait <code>heapq</code> il y a 3 semaines.</p>
<p>xoxo les filles</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/heapq-le-module-python-incompris/feed/</wfw:commentRss>
		<slash:comments>14</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">3813</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2012/12/hip-hop.jpg" length="76988" type="image/jpg" />	</item>
		<item>
		<title>Ce que vous ne saviez pas sur les collections en Python</title>
		<link>http://sametmax.com/ce-que-vous-ne-saviez-pas-sur-les-collections-en-python/</link>
		<comments>http://sametmax.com/ce-que-vous-ne-saviez-pas-sur-les-collections-en-python/#comments</comments>
		<pubDate>Tue, 10 Jul 2012 22:05:52 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[collections]]></category>
		<category><![CDATA[dicts]]></category>
		<category><![CDATA[iterables]]></category>
		<category><![CDATA[lists]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[set]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=1101</guid>
		<description><![CDATA[Batteries included on vous dit...]]></description>
				<content:encoded><![CDATA[<p>Les collections en Python sont organisées autour de la philosophie du langage, notament <a href="http://docs.python.org/glossary.html#term-eafp">EAFP</a>, et la <a href="http://sametmax.com/python-love-les-listes-en-intention-partie/">manie de l&#8217;itération</a>.</p>
<h2>Les dictionnaires</h2>
<h3>Valeur par défaut</h3>
<p>Une fois à l&#8217;aise en Python, on utilise souvent les dictionnaires. Et on fait souvent ça:</p>
<pre lang="python">
>>> def get(d, key, default):
...     try:
...         return d[key]
...     except KeyError:
...         return default
... 
>>> d = {'a':1}
>>> get(d, 'foo', 'bar')
'bar'
>>> get(d, 'a', 'bar')
1
</pre>
<p>C&#8217;est parfaitement superflux, puisque Python le propose en standard:</p>
<pre lang="python">
>>> d.get("foo", 'bar')
'bar'
>>> d.get("a", 'bar')
1
</pre>
<p>Plus tordu encore:</p>
<pre lang="python">
>>> def get_and_set_if_not_exist(d, key, default):
...     try:
...         return d[key]
...     except KeyError:
...         d[key] = default
...         return default
... 
>>> d = {'a':1}
>>> get_and_set_if_not_exist(d, 'foo', []).append('wololo')
>>> d
{'a': 1, 'foo': ['wololo']}
>>> get_and_set_if_not_exist(d, 'foo', []).append('oyo oyo')
>>> d
{'a': 1, 'foo': ['wololo', 'oyo oyo']}
</pre>
<p>Python le propose aussi en standard:</p>
<pre lang="python">
>>> d = {'a':1}
>>> d.setdefault('foo', []).append('wololo')
>>> d.setdefault('foo', []).append('oyo oyo')
>>> d
{'a': 1, 'foo': ['wololo', 'oyo oyo']}
</pre>
<h3>Clés des dictionnaires</h3>
<p>Les clés des dictionnaires n&#8217;ont pas à être des strings. N&#8217;importe quel objet hashable fait l&#8217;affaire, par exemple, des tuples:</p>
<pre lang="python">
>>> positions = {}
>>> positions[(48.856614, 48.856614)] = "Paris"
>>> positions[(40.7143528, -74.0059731)] = "New York"
>>> positions
{(48.856614, 48.856614): 'Paris', (40.7143528, -74.0059731): 'New York'}
>>> positions[(48.856614, 48.856614)]
'Paris'
</pre>
<h2>Les sets</h2>
<p>Les sets sont un type de structure peu connu: ils représentent un ensemble non ordonné d&#8217;objets uniques. Il n&#8217;y a donc pas d&#8217;ordre évident dans un set, et le résultat est garanti sans doublon:</p>
<pre lang="python">
>>> e = set((3, 2, 1, 1, 1, 1, 1))
>>> e
set([1, 2, 3])
>>> e.add(1)
>>> e.add(1)
>>> e.add(14)
>>> e
set([1, 2, 3, 14])
</pre>
<p>Les opérations du set acceptent n&#8217;importe quel <a href="http://sametmax.com/parcourir-un-iterable-par-morceaux-en-python/">itérable</a>. Y compris les opérations ensemblistes:</p>
<pre lang="python">
>>> e.update('abcdef')
>>> e
set(['a', 1, 2, 3, 'e', 'd', 'f', 'c', 14, 'b'])
>>> e = set('abc')
>>> e.union("cde")
set(['a', 'c', 'b', 'e', 'd'])
>>> e.difference("cde")
set(['a', 'b'])
>>> e.intersection("cde")
set(['c'])
</pre>
<p>Vérifier la présence l&#8217;un élément dans un set (avec l&#8217;opérateur <code>in</code>) est une opération extrêment rapide (compléxité <code>O(1)</code>), beaucoup plus que dans une liste ou un tuple. Le set reste pourtant itérable (mais on ne peut pas compter sur l&#8217;ordre).</p>
<p>Les opérateurs binaires sont overridés pour les opérations entre sets. De plus on peut utiliser une notation littérale pour décrire un set à partir de Python 2.7:</p>
<pre lang="python">
>>> {'a', 'b', 'c'} | {'c', 'd'} # union
set(['a', 'c', 'b', 'd'])
>>> {'a', 'b', 'c'} & {'c', 'd'} # intersection
set(['c'])
>>> {'a', 'b', 'c'} - {'c', 'd'} # difference
set(['a', 'b'])
</pre>
<h2>Les listes</h2>
<h3><code>Pop()</code> prend un argument</h3>
<p>La raison pour laquelle il n&#8217;y a pas de <code>unshift</code> sur les listes en Python, c&#8217;est que l&#8217;on en a pas besoin:</p>
<pre lang="python">>>
>>> l = [1, 2, 3, 4, 5]
>>> l.pop()
5
>>> l
[1, 2, 3, 4]
>>> l.pop(0)
1
>>> l
[2, 3, 4]
>>> l.pop(-2)
3
>>> l
[2, 4]</pre>
<h3>Le slicing accepte un 3eme argument</h3>
<p>Le slicing, que l&#8217;on peut appliquer à tous les indexables (listes, tuples, strings, etc), est la fonctionalité bien pratique qui permet de récupérer une sous partie de la structure de données:</p>
<pre lang="python">
>>> l = range(10)
>>> l
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> l[2:8]
[2, 3, 4, 5, 6, 7]
>>> l[5:]
[5, 6, 7, 8, 9]
>>> l[:5]
[0, 1, 2, 3, 4]

</pre>
<p>Ca vous connaissiez sûrement. Mais cette syntaxe accepte un 3eme nombre: le pas.</p>
<p>Le premier nombre dit d&#8217;où l&#8217;on part. Le second où l&#8217;on s&#8217;arrête. Le dernier dit de combien on avance (par défaut de 1).</p>
<pre lang="python">
>>> l[2:8:2]
[2, 4, 6]
>>> l[2::2] # chaque paramètre est optionel
[2, 4, 6, 8]
</pre>
<p>Et le pas peut être négatif, ce qui est plutôt sympas si vous voulez parcourir une liste ou une string à reculon.</p>
<pre lang="python">
>>> l[::-1]
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
</pre>
<h3><code>extend()</code> accepte n&#8217;importe quel itérable</h3>
<p>extend() permet de mettre à jour une liste. On l&#8217;utilise souvent en lui passant une autre liste:</p>
<pre lang="python">
>>> l = [1, 2, 3]
>>> l.extend([4, 5, 6])
>>> l
[1, 2, 3, 4, 5, 6]
</pre>
<p>Mais comme la plupart du code la bibliothèque standard, <code>extend()</code> accepte n&#8217;importe quel itérable.</p>
<pre lang="python">
>>> t = (42, 666, 1024) # un tuple
>>> s = '456' # une string
>>> d = {'3.14': 'pi'} # un dico
>>> l = [1, 2, 3]
>>> l.extend(s)
>>> l
[1, 2, 3, '4', '5', '6']
>>> l.extend(d) #
>>> l
[1, 2, 3, '4', '5', '6', '3.14']
>>> l.extend(t)
>>> l
[1, 2, 3, '4', '5', '6', '3.14', 42, 666, 1024]
</pre>
<p>Ca marche aussi avec les set, les fichiers, les expressions génératrices. Attention cependant, sachez que l&#8217;itération retourne: par exemple itérer sur un dico retourne ses clés, pas ses valeurs (car on peut récupérer l&#8217;un avec l&#8217;autre, mais pas l&#8217;inverse).</p>
<h2>Les tuples</h2>
<p>Ce qui permet de créer un tuple ne sont pas les parenthèses, mais la virgule:</p>
<pre lang="python">
>>> 1,2,3 # ceci EST un tuple
(1, 2, 3)
>>> 1, # tuple
(1,)
>>> 1 # int
1
</pre>
<p>La raison pour laquelle il est recommandé d&#8217;utiliser presque TOUJOURS les parenthèses, c&#8217;est qu&#8217;elles permettent d&#8217;éviter les ambiguïtés, et qu&#8217;elles autorisent la définition sur plusieurs lignes:</p>
<pre lang="python">
>>> type(1,2,3) # tuple ou paramètres ?
Traceback (most recent call last):
  File "<ipython-input-62-5be61417b8a3>", line 1, in <module>
    type(1,2,3)
TypeError: type() argument 1 must be string, not int
>>> type((1,2,3))
<type 'tuple'>
>>> (1, # un gros tuple s'écrit sur plusieurs lignes
... 2,
... 3)
(1, 2, 3)
</pre>
<p>Mais il existe des rares cas où il est acceptable de ne pas mettre de parenthèses:</p>
<pre lang="python">
>>> def debut_et_fin(lst):
...     """
...         Retourne le début et la fin d'une liste
...     """
...     debut = lst[0]
...     fin = lst[-1]
...     # donner l'illusion de retourner plusieurs valeurs
...     # alors qu'on retourne en fait un tuple
...     return debut, fin # 
... 
>>> debut, fin = debut_et_fin([1,2,3,4]) # unpacking
>>> debut
1
>>> fin
4
>>> debut, fin = fin, debut # variable swap
>>> debut
4
>>> fin
1
</pre>
<h2>Le module <code>collections</code></h2>
<p>En plus des collections built-in, la bibliothèque standard de Python propose un module <code>collections</code> avec plein d&#8217;outils en bonus.</p>
<p>Des dictionnaires qui conservent l&#8217;ordre d&#8217;insertion (comme les Arrays en PHP):</p>
<pre lang="python">
>>> from collections import OrderedDict
>>> d = {} # l'ordre d'un dico n'est pas garanti
>>> d['c'] = 1
>>> d['b'] = 2
>>> d['a'] = 3
>>> d.keys()
['a', 'c', 'b']
>>> d = OrderedDict()
>>> d['c'] = 1
>>> d['b'] = 2
>>> d['a'] = 3
>>> d.keys()
['c', 'b', 'a']
</pre>
<p>Un compteur qui a une interface similaire à un dictionnaire spécialisé.</p>
<pre lang="python">
>>> from collections import Counter
>>> score = Counter()
>>> score['bob']
0
>>> score['robert'] += 1
>>> score['robert']
1
>>> score['robert'] += 1
>>> score['robert']
2
</pre>
<p>Comme vous pouvez le voir il gère les valeurs par defaut, mais en prime il compte le contenu de n&#8217;importe quel itérable:</p>
<pre lang="python">
>>> Counter([1, 1, 1, 1, 1, 1, 2, 3, 3])
Counter({1: 6, 3: 2, 2: 1})
>>> Counter('Une petite puce pique plus')
Counter({'e': 5, ' ': 4, 'p': 4, 'u': 3, 'i': 2, 't': 2, 'c': 1, 'l': 1, 'n': 1, 'q': 1, 's': 1, 'U': 1})
</pre>
<p>Des tuples qui ressemblent à des structs en C, mais itérables:</p>
<pre lang="python">
>>> from collections import namedtuple
>>> Fiche = namedtuple("Fiche", "force charisme intelligence")
>>> f = Fiche(force=18, charisme=17, intelligence=3)
>>> f
Fiche(force=18, charisme=17, intelligence=3)
>>> for x in f:
...     print x
...
18
17
3
>>> f.force
18
</pre>
<p>Des dicos dont la valeur par défaut est le résultat de l&#8217;appel d&#8217;une fonction:</p>
<pre lang="python">
>>> from collections import defaultdict
>>> import datetime
>>> d = defaultdict(datetime.datetime.now)
>>> d["jour"]
datetime.datetime(2012, 7, 10, 17, 34, 7, 265222)
>>> d["jour"] # la valeur est settée
datetime.datetime(2012, 7, 10, 17, 34, 7, 265222)
>>> d["raison"] = "test"
>>> d.items()
[("jour", datetime.datetime(2012, 7, 10, 17, 34, 7, 265222)), ("raison", 'test')]
</pre>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/ce-que-vous-ne-saviez-pas-sur-les-collections-en-python/feed/</wfw:commentRss>
		<slash:comments>16</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">1101</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2012/07/sex-toy-collection.jpg" length="437398" type="image/jpg" />	</item>
	</channel>
</rss>
