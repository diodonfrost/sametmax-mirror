<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" >

<channel>
	<title>base 10 &#8211; Sam &amp; Max</title>
	<atom:link href="http://sametmax.com/tag/base-10/feed/" rel="self" type="application/rss+xml" />
	<link>http://sametmax.com</link>
	<description>Du code, du cul</description>
	<lastBuildDate>Thu, 05 Sep 2019 08:22:03 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.7</generator>
<site xmlns="com-wordpress:feed-additions:1">32490438</site>	<item>
		<title>La fin du mystère du binaire (nananère)</title>
		<link>http://sametmax.com/la-fin-du-mystere-du-binaire-nananere/</link>
		<comments>http://sametmax.com/la-fin-du-mystere-du-binaire-nananere/#comments</comments>
		<pubDate>Tue, 21 Jan 2014 15:01:56 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[base 10]]></category>
		<category><![CDATA[base 2]]></category>
		<category><![CDATA[binaire]]></category>
		<category><![CDATA[python]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=8808</guid>
		<description><![CDATA[Le binaire c'est simple. Tout le monde peut le comprendre. Par contre, il y a beaucoup de choses à savoir.]]></description>
				<content:encoded><![CDATA[<p>Quand mon voisin de table en cours de SVT a commencé à m&#8217;expliquer le binaire (il programmait en assembleur sur sa TI89), j&#8217;ai pas bien pigé. Des années plus tard, en cours d&#8217;archi, un prof nous a fait un cours magistral sur la question. Je n&#8217;ai définitivement rien pigé. J&#8217;ai regardé des tutos sur le net. RIEN P-I-G-É.</p>
<p>J&#8217;ai mis presque 10 ans (littéralement) avant que mon cerveau tilte. Non pas que je n&#8217;avais pas compris le principe, mais le détails, comment on faisait la conversion, ce qu&#8217;on pouvait faire avec, etc&#8230; Ca me passait au dessus de la tête.</p>
<p>Je râle beaucoup sur le manque de pédagogie d’autrui, et après tout, d&#8217;autres ont compris le truc à partir de ces explications. Mais je vais me répéter : leurs explications étaient merdiques.</p>
<p>Le binaire c&#8217;est simple. Tout le monde peut le comprendre.</p>
<p>Si vous ne pigez pas, c&#8217;est que le mec en face de vous est une grosse pine.</p>
<p>Par contre, il y a beaucoup de choses à savoir, alors à long article, loooooooooooongue musique :</p>
<p><iframe class='youtube-player' type='text/html' width='1170' height='689' src='http://www.youtube.com/embed/MSEQZ8reJA4?version=3&#038;rel=1&#038;fs=1&#038;autohide=2&#038;showsearch=0&#038;showinfo=1&#038;iv_load_policy=1&#038;wmode=transparent' allowfullscreen='true' style='border:0;'></iframe></p>
<p>Long article car j&#8217;ai vu des connards mélanger tout et n&#8217;importe quoi dans leurs explications du binaire, et je vais devoir démêler le sac de nœuds qu&#8217;ils ont fait dans votre tête.</p>
<h2>Pourquoi apprendre le binaire ?</h2>
<p>Pour le sport, essentiellement. La culture G. Parce qu&#8217;en toute honnêteté, aujourd&#8217;hui, ça ne sert plus à grand chose, tellement vous avez de couches d&#8217;abstraction entre les manipulations binaires et vous.</p>
<p>Il y a toujours quelques grincheux qui vous diront des trucs de grincheux comme &#8220;oui, mais pour comprendre les erreurs de flottant en arithmétique, il faut comprendre le binaire&#8221; comme mon père qui me disait qu&#8217;il fallait apprendre le latin au lycée. Meh.</p>
<p>D&#8217;abord, on a pas plus besoin d&#8217;apprendre le binaire pour comprendre les erreurs de flottant qu&#8217;on a besoin de comprendre la composition moléculaire de l&#8217;essence pour savoir pourquoi une voiture tombe en panne quand il y en a plus. Ensuite, vous n&#8217;avez même pas besoin de comprendre pourquoi il y a des erreurs de flottant, juste à savoir comment les éviter (ce que des tas de gens &#8220;qui les comprennent&#8221; ne sont pas foutu de faire).</p>
<p>Bref, c&#8217;est l&#8217;éternel bataille de l&#8217;arrière garde qui veut défendre le savoir aujourd&#8217;hui obsolète &#8211; qu&#8217;il a accumulé parce qu&#8217;a son époque c&#8217;était indispensable &#8211; à grand renfort de pédanterie. On voit ça dans tous les domaines. Généralement avec  force exemples de niches et enculage de mouche.</p>
<p>Mais au delà de ça, le binaire est encore utilisé dans certains domaines, comme la programmation de micro-contrôleurs (si vous planifiez de bosser chez Intel, Nvidia ou la NASA, ça peut servir), la cryptographie ou la programmation de calculatrices en cours de bio. Ce dernier point étant semble-t-il, un sujet intemporel qui ne se démode jamais.</p>
<p>Néanmoins ça reste 0.00001 % de l&#8217;informatique actuelle. Vous n&#8217;aurez pas besoin du binaire pour vos tâches de Sys Admin, vos GUI, votre app mobile, votre site Web, votre algo de simulation, etc. Bref, les trucs pour lesquels les gens sont payés dans les années 2000.</p>
<p>Maintenant que j&#8217;ai bien été désagréable avec une partie du lectorat, précisons tout de même que savoir 2, 3 trucs sur le binaire, ça ne fait pas de mal. Vous êtes informaticiens, ça fait un peu partie du folklore.</p>
<h2>Valeur et représentation</h2>
<p>En informatique, il y a le problème sans fond de la dualité valeur / représentation. L&#8217;écriture des nombres est un exemple parfait de cela.</p>
<p>Par exemple, j&#8217;ai ce nombre d&#8217;étoiles :</p>
<pre>* * * * *</pre>
<p>Il y a la valeur du nombre d&#8217;étoiles. Cette valeur ne peut pas être manipulée, elle existe, c&#8217;est tout. On ne peut que constater le nombre d&#8217;étoiles en interprétant ce que l&#8217;on voit.</p>
<p>Si on veut manipuler cette valeur (parler d&#8217;une valeur, c&#8217;est déjà manipuler la valeur), il faut lui donner une représentation.</p>
<p>Les arabes nous ont donné une représentation : 5.</p>
<p>Les romains avaient une autre représentation : V.</p>
<p>La valeur derrière ces deux représentations est strictement la même.</p>
<p>Le binaire est juste une autre représentation. Il n&#8217;y a rien de magique derrière le binaire.</p>
<p>Par exemple, la valeur que l&#8217;on représentante par 5, se représente ainsi en binaire : 101.</p>
<p>C&#8217;est la même valeur de nombre d&#8217;étoiles. Juste écrit différemment. Cela n&#8217;a aucun impact sur la réalité, ne change rien sur la nature des étoiles ou la valeur manipulée. C&#8217;est une manière de transmettre une information.</p>
<h2>A la base de la base</h2>
<p>La raison pour laquelle on s&#8217;embrouille facilement avec le binaire, c&#8217;est que la plupart d&#8217;entre nous ont appris à lire les nombres par cœur. On lit un nombre comme un tout.</p>
<p>En vérité, un nombre est une notation qui obéit à des règles très strictes, et non seulement chaque chiffre donne une information, mais <strong>sa place</strong> dans le nombre donne une information. Ce qu&#8217;on appelle &#8220;centaine&#8221;, &#8220;millier&#8221;, etc, sont des notions qu&#8217;on manipule sans y penser, mais derrière, il y a en fait un système.</p>
<p>Le système des bases.</p>
<p>Quand on utilise les chiffres arabes pour écrire un nombre, on utilise une série de symboles, et on les aligne dans un ordre précis. <strong>Selon la base utilisée, l&#8217;ordre implique une valeur différente.</strong></p>
<p>On ne s&#8217;en rend pas compte, mais on utilise tous les jours l&#8217;ordre de la base 10. On pense en base 10. On a tellement l&#8217;habitude de tout calculer en base 10 qu&#8217;on ne se rend pas compte qu&#8217;on suit une règle précise pour cela.</p>
<p>Que signifie le fait d&#8217;utiliser une base 10 ?</p>
<p>Deux choses.</p>
<p>La première, c&#8217;est que l&#8217;on a DIX symboles pour représenter DIX valeurs. On ne sait représenter directement que ces DIX valeurs là.</p>
<pre>
          0
*         1
**        2
***       3
****      4
*****     5
******    6
*******   7
********  8
********* 9</pre>
<p>On a des valeurs (un nombre d&#8217;étoiles), et on fait correspondre <strong>complètement arbitrairement</strong> dix symboles pour ces valeurs. On connait ces symboles par cœur, ce sont des conventions. Ils ne signifient rien par eux-même, nous leur avons donné cette signification.</p>
<p>Ça c&#8217;est la première règle. La deuxième règle, c&#8217;est que quand on tombe à cours de symboles parceque la valeur est trop grande, on utilise <strong>la position</strong> des symboles pour dire combien de groupes de dizaines de symboles il y a.</p>
<p>Par exemple avec ce nombre :</p>
<pre>10</pre>
<p>10 veut dire (en lisant de droite à gauche, ce sont des chiffres arabes, je le rappelle), 0 unité, et 1 groupe d&#8217;une dizaine.</p>
<p>Si on a 587, on dit (toujours de droite à gauche) : il y a 7 unités et 8 groupes d&#8217;une dizaine et 5 groupes d&#8217;une <strong>dizaine de dizaines</strong>.</p>
<p>La position du chiffre dit si l&#8217;on parle d&#8217;un groupe de 1, de 10, de 10 groupes de 10 (cent), de 10 groupes de 10 groupes de 10 (1000), etc.</p>
<p>C&#8217;est pour ça qu&#8217;on parle de base 10. Tout est en groupe de 10. On fait des paquets de 10. Puis des paquets de 10 paquets de 10. Puis des paquets de 10 paquets de 10 paquets de 10&#8230;</p>
<p>Exemple avec le nombre 1982 :</p>
<pre>
[1][9][8][2]
 |  |  |  |
 |  |  |  2 unités
 |  |  8 groupes de 10
 |  9 groupes de 10 groupes de 10 (10 x 10 = 100)
1 groupe de 10 groupes de 10 groupes de 10 (10 x 10 x 10 = 1000)</pre>
<p>Si on lit un chiffre comme un tableau en informatique (donc en commençant par 0), mais de droite à gauche, on peut utiliser les puissances pour noter ça de manière propre :</p>
<pre>
[1][9][8][2]
 |  |  |  |
 |  |  |  2 est à la place 0, sa "valeur" est 2 x 10^0 = 2 * 1 = 2
 |  |  8 est à la place 1, sa "valeur" est 8 x 10^1 = 8 * 10 = 80
 |  9 est à la place 2, sa "valeur" est 9 x 10^2 = 9 x 10 x 10 = 9 x 100 = 900
1 est à la place 3, sa "valeur" est 1 x 10^3 = 1 x 10 x 10 x 10 = 1 x 1000 = 1000</pre>
<p>Ça vous parait évident sans avoir à faire le calcul ? C&#8217;est parce que vous êtes tellement habitué à compter en base 10 que c&#8217;est automatique pour vous. Pourtant, en base 2, c&#8217;est <strong>exactement la même chose.</strong></p>
<p>On a DEUX symboles pour représenter DEUX valeurs. On ne sait représenter que ces DEUX valeurs là.</p>
<pre>
  0
* 1</pre>
<p>Quand on tombe à cours de symbole parce qu&#8217;une valeur est trop grande, on utilise <strong>la position</strong> des symboles pour dire combien de groupes de deux symboles il y a.</p>
<p>Par exemple avec ce nombre :</p>
<pre>10</pre>
<p>10, <strong>qui ne se prononce PAS dix</strong>, veut dire (en lisant de droite à gauche), 0 unité, et 1 groupe d&#8217;une paire. Donc deux en base 10 :-).</p>
<p>Pour les chiffres plus longs, c&#8217;est kiff, kiff :</p>
<pre>
[1][1][1][0]
 |  |  |  |
 |  |  |  0 unité
 |  |  1 groupes de 2
 |  1 groupes de 2 groupes de 2 (2 x 2 = 4 en base 10)
1 groupe de 2 groupes de 2 groupes de 2 (2 x 2 x 2 = 8 en base 10)</pre>
<p>Donc en base 10 : 8 + 4 + 2, soit 14.</p>
<p>Si on le représente en puissance de 2 :</p>
<pre>
[1][1][1][0]
 |  |  |  |
 |  |  |  0 est à la place 0, sa "valeur" est 0 x 2^0 = 0 * 1 = 0
 |  |  1 est à la place 1, sa "valeur" est 1 x 2^1 = 1 * 2 = 2
 |  1 est à la place 2, sa "valeur" est 1 x 2^2 = 1 x 2 x 2 = 1 x 4 = 4
1 est à la place 3, sa "valeur" est 1 x 2^3 = 1 x 2 x 2 x 2 = 1 x 8 = 8</pre>
<p>En gros pour convertir du binaire en base 10, il suffit de réciter les puissances de deux dans sa tête :</p>
<p>2, 4, 8, 16, 32&#8230; (2 fois 2 = 4, 2 fois 4 = 8, 2 fois 8 = 16, 2 fois 16 = 32&#8230;)</p>
<p>Et les appliquer de droite à gauche :</p>
<pre>[1][0][1][1][1][0] => [1 * 32] + [0 * 16] + [1 * 8] + [1 * 4] + [1 * 2] + [O * 1] => 46 en base 10</pre>
<p>Une illustration graphique ?</p>
<p>Voici quarante-six étoiles :</p>
<pre>**********************************************</pre>
<p>Si je les représente en base 10, je noterais ça 46, soit 4 groupes de dizaines, et 6 unités :</p>
<pre>
    4          6

**********   ******
**********
**********
**********
</pre>
<p>Si je le représente en base 2, je le note 101110: soit 1 groupe de trente-deux, 0 groupe de seize, 1 groupe de huit, 1 groupe de quatre, 1 groupe de deux, et 0 unité.</p>
<pre>
                1                  0      1        1     1    0

********************************   -   ********   ****   **   -</pre>
<p>On peut faire ça avec n&#8217;importe quelle base. On peut compter en base 3 (ternaire) ou en base 4, 5, 6&#8230; On utilise notamment parfois en informatique la base 8 (octale) et la base 16 (hexadécimale). Pour cette base, il y a 16 symboles : 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, représentant chacun une valeur, puis, quand on a plus de symbole, on utilise la position pour signaler un paquet de 16.</p>
<h2>Passons au code</h2>
<p>En Python on peut écrire un nombre en binaire en le préfixant de &#8216;0b&#8217;:</p>
<pre lang="python">>>> 0b101110
46
</pre>
<p>Mais par défaut Python <strong>représente</strong> toujours à l&#8217;affichage ce nombre en base 10. La valeur derrière est la même de toute façon (qui, de manière amusante, est sockée en binaire).</p>
<p>Si vous voulez forcer <strong>l&#8217;affichage</strong> du nombre en binaire, vous pouvez utilisez <code>bin()</code> ou <code>format()</code> :</p>
<pre lang="python">>>> 'Le nombre {0} en binaire donne : {0:b}'.format(46)
u'Le nombre 46 en binaire donne : 101110'

>>> bin(46)
'0b101110'
</pre>
<p>A l&#8217;inverse, si vous avez une représentation textuelle d&#8217;un chiffre binaire, vous pouvez préciser la base via le second paramètre de <code>int()</code> :</p>
<pre lang="python">>>> int('101110') # la base 10 est le réglage par défaut...
101110
>>> int('101110', 10) # ...donc on récupère cent un mille cent dix.
101110
>>> int('101110', 2) # si on précise la base 2, on récupère quarante-six.
46</pre>
<p>Mais si on n&#8217;a pas codé sa petite fonction pour faire pareil à la main à 50 ans, on a raté sa vie. Donc, voici un exemple simple d&#8217;une fonction qui convertit une représentation textuelle d&#8217;un chiffre binaire en int Python :</p>
<pre lang="python">def bin2dec(s):

    # on rejette les chaînes vides
    if not s:
        raise ValueError('The string cannot be empty')

    total = 0

    # on itère sur la chaîne, de droite à gauche
    reversed_number = s[::-1]
    for pos, num in enumerate(reversed_number):

        # on multiplie le chiffre en cours par la puissance de 2
        # qui correspond à sa position
        total += int(num) * (2 ** pos)

    return total

print(bin2dec('0'))
print(bin2dec('1'))
print(bin2dec('10'))
print(bin2dec('101'))
print(bin2dec('10011100'))

## 0
## 1
## 2
## 5
## 156
</pre>
<p>Et la fonction inverse :</p>
<pre lang="python">

from __future__ import division # pour être tous d'accord sur la division entière

def dec2bin(i):

    numbers = []

    if i == 0:
        return i

    # On divise (avec la division entière) par deux jusqu'à ce qu'il ne reste
    # plus rien à diviser (on fait des paquets de 2, quoi).
    # Avant chaque division par deux, on regarde si il y aura un reste
    # pour la prochaine division. Si oui, on met 1 pour le paquet de 2 actuel,
    # sinon on met 0.
    # C'est comme pour la multiplication à la main ("je met 2 et je retiens 1"),
    # mais à l'envers.
    while i != 0:
        numbers.append(str(i % 2))
        i = i // 2

    # Ensuite on inverse tout ça et on join() tout en une belle string
    return (''.join(numbers[::-1]))

print(dec2bin(0))
print(dec2bin(1))
print(dec2bin(2))
print(dec2bin(5))
print(dec2bin(156))

## 0
## 1
## 10
## 101
## 10011100</pre>
<h2>Et les opérateurs bitwise ?</h2>
<p>Dans les tutos on voit souvent mélanger la notion de binaire, avec la représentation des nombres, du texte, et les opérateurs spécialisés dans la manipulation du binaire : </p>
<pre>|, ^, ~, >>, <<, >>>, &, etc</pre>
<p>C&#8217;est le bordel.</p>
<p>On les appelle ces opérateurs &#8220;bitwise&#8221;, et ils sont essentiellement de deux types : les shifts, et les opérateurs logiques.</p>
<p>Les shifts, souvent notés <code>&gt;&gt;</code>, <code>&lt;&lt;</code>, etc, décalent d&#8217;un bit. Un bit, c&#8217;est une case dans un nombre binaire, une d&#8217;un chiffre position, qui prend donc la valeur 0 ou 1.</p>
<p>Ex: 1010 est un nombre de 4 bits. 10100 est un nombre de 5 bits.</p>
<p>Par décaler, j&#8217;entends qu&#8217;ils poussent littéralement les bits dans un sens ou dans l&#8217;autre :</p>
<p>1010 &gt;&gt; 1 va donner 101 (les bits se sont décalés vers la droite d&#8217;un cran, c&#8217;est le rshift). Ca fait disparaitre un bit à droite.<br />
1010 &lt;&lt; 1 va donner 10100 (les bits se sont décalés vers la gauche d&#8217;un cran, c&#8217;est le lshift). Ca rajoute un bit à droite.</p>
<p>Si on met un plus grand nombre, on décale de plusieurs bits :</p>
<p>1010 &lt;&lt; 3 va donner 1010000 (les bits se sont décalés vers la gauche de 3 crans)</p>
<p>C&#8217;est une opération très rapide, puisqu&#8217;il suffit de décaler les chiffres, sans faire de calculs complexes. Pourtant, c&#8217;est l&#8217;équivalent de certaines opérations mathématiques.</p>
<p>Par exemple, un lshift peut être équivalent à une multiplication par une puissance de 2.</p>
<p>Ainsi, si je prends le chiffre 10 en (binaire 1010), et que je lui applique un lshift de 3, c&#8217;est comme si je le multipliais par 2^3 (soit 8). Démo en Python :</p>
<pre lang="python">>>> 0b1010
10
>>> 0b1010 << 3
80</pre>
<p>Mais l'opération prend beaucoup moins de cycles CPU qu'une multiplication. C'est une astuce d'optimisation qui a été beaucoup utilisée au paléolithique et qui reste en vigueur chez les cryptonerds. Néanmoins ne l'utilisez pas en Python, les gains sont minimes. C'est surtout utile pour les codes C ou assembleur qui sont déjà sur optimisés et ont besoin de ce petit coup de pouce supplémentaire.</p>
<p>Ensuite il y a les opérateurs logiques. Ils appliquent tout simplement la logique booléenne à chaque bit d'un nombre avec chaque bit d'un autre nombre dont la position correspond. Par exemple :</p>
<p>Si je fais "1101 ET (représenté souvent par '&') 110", je vais obtenir :</p>
<pre>
[1][1][0][1]
 |  |  |  |
 &  &  &  &
 |  |  |  |
[ ][1][1][0]
 |  |  |  |
 v  v  v  v
 0  1  0  0

1 et rien => vrai ET faux ? => faux => 0
1 et 1 => vrai ET vrai ? => vrai => 1
0 et 1 => faux ET vrai ? => faux => 0
1 et 0 => faux ET vrai ? => faux => 0
</pre>
<p>C'est de la logique booléenne de base, vous pouvez la tester avec <code>True</code>, <code>False</code>, <code>and</code> et <code>or</code> dans votre shell si ça ne vous parle pas.</p>
<p>En code Python :</p>
<pre lang="python">>>> bin(0b1101 & 0b100)
'0b100'</pre>
<p>On l'utilise parfois pour faire ce qu'on appelle des "masques", c'est à dire représenter une série d'états sous forme de grille de bits, et changer un état de cette grille en appliquant une opération logique avec une autre grille.</p>
<p>Je sais, ça fait flou comme ça. Un exemple peut-être ?</p>
<p>Les permissions d'un fichiers Unix sont Read (lire), Write (écrire) et Execute (exécuter). Soit "rwx". Elles s'appliquent à User (utilisateur), Group (groupe), Other (autre), soit "ugo".</p>
<p>Cela est peut être représenté par 3 groupes de 3 bits, soit 9 bits :</p>
<pre>
    U         G         O
[r][w][x] [r][w][x] [r][w][x]</pre>
<p>1 veut dire que la permission est donnée, 0 veut dire qu'elle n'est pas donnée.</p>
<p>Ainsi :</p>
<pre>
[1][1][1] [1][0][1] [1][0][1]</pre>
<p>Veut dire que l'utilisateur à le droit de lire, écrire et exécuter le fichier. Le groupe et les autres n'ont que le droit de le lire et exécuter le fichier.</p>
<p>Si vous mettez ça en base 10, ça donne 7/5/5 (et NON sept-cent-cinquante-cinq car il y a 3 valeurs). Cela  explique le fameux <code>chmod 755</code> que vous voyez dans tous les tutos bash.</p>
<p>Si vous faites :</p>
<pre lang="bash">
chmod g+w fichier
</pre>
<p>Le programme va rajouter la permission d'écrire au groupe. On peut représenter cette opération par l'application d'une opération "OU" (représentée par '|') :</p>
<p>En effet on a 101 pour les permissions du groupe et on veut obtenir 111. Il suffit d'appliquer le masque 010 (qui correspond pile poil à un 1 à la case de la permission voulue) :</p>
<pre lang="python">>>> bin(0b101 | 0b010)
'0b111'</pre>
<h2>Représentation des nombres dans un ordinateur</h2>
<p>Cette partie c'est vraiment pour vos beaux yeux hein, ne vous en faites pas si vous ne pigez pas tout. Je ne vais pas dans le détail car ça demanderait un autre article complet, plus un comparatif des archis, des notions, des systèmes de typages des langages, etc. Et j'ai vraiment pas envie de le faire.</p>
<p>Bon, déjà, la représentation des nombres dans un ordi, c'est une grande source de confusion : en effet, <strong>l’ordinateur ne stocke pas la représentation binaire directe d'un nombre</strong>.</p>
<p>On pourrait se dire : l’ordinateur manipule du binaire, on traduit nos nombres en binaire, on fout tout tel quel dedans, et yala.</p>
<p>Mais un ordinateur a des limitations techniques. Notamment, il possède des plages de mémoires d'un nombre de bits limité. Il faut donc faire tenir la représentation de la valeur sur cet espace limité.</p>
<p>Si votre espace de mémoire pour représenter une valeur est limité à 16 bits et que vous devez stocker un nombre entier dedans, il pourra être au maximum 2^16 - 1 = 65535.</p>
<p>C'est pour cela qu'en C on déclare le type d'une variable qui va contenir un nombre qu'on va manipuler. On dit clairement, "alloue moi cet espace mémoire, mon nombre ne sera jamais plus grand que ça". En Python, c'est automatiquement et transparent.</p>
<p>(C'est aussi pour ça qu'on parle de processeur 16bits, 32bits, 64bits, etc. C'est la taille des jeux d'instructions qu'ils sont capables de traiter en un cycle.)</p>
<p>Mais il se rajoute une autre complexité : un entier peut avoir un signe plus ou un signe moins. Il faut bien le représenter quelque part. On peut le faire en utilisant le premier bit, mais aussi avec un format appelé "le complément à deux". Comme cet article est déjà super long, je vais pas me lancer dans l'explication. J'ai mal aux doigts. Sachez juste qu'on utilise en quelque sorte "l'inverse" du nombre.</p>
<p>Encore une fois, en C, on déclare que l'on va utiliser un "signed int" ou un "unsigned int" à l'initialisation d'une variable.</p>
<p>Enfin, il y a les nombres à virgule, aussi appelés "flottants" (d'où le type "float" en Python).</p>
<p>On pourrait se dire qu'on utilise les puissances de deux négatives :</p>
<p>0.92 se lit en base 10 "0 x 1 + 9 x 10^-1 + 2 x 10^-2"</p>
<p>On garderait la logique des positions.</p>
<p>Donc :</p>
<p>0.11 se lit en base 2 "0 x 1 + 1 x 2^-1 + 1 x 2^-1 + 1 x 2^-2"</p>
<p>A priori on pourrait stocker le nombre en utilisant ce principe. Mais ça ne permet pas de présenter les nombres très grands (tendant vers l'infini) ou très petit (tendant vers zéro). Alors on utilise un autre principe : on représente un nombre avec la formule <code>m x 2^n</code>, très couramment sur 64 bits (ce que fait le type float Python, mais on peut avoir <a href="http://docs.scipy.org/doc/numpy/user/basics.types.html">plus de choix</a> de manoeuvre en utilisant numpy).</p>
<p><code>m</code> est un nombre à virgule compris entre 1 et 2 (ce dernier étant exclus). On appelle ça la mantisse. Ce sera stocké sur 52 bits en utilisant une représentation binaire littérale.</p>
<p><code>n</code> est l'exposant, c'est un nombre entier compris entre -1022 et 1023, stocké sur 11 bits.</p>
<p>On garde le premier bit pour le signe.</p>
<p>Et il y a des exceptions pour 0, l'infini et NaN.</p>
<p>(et je n'ai pas la moindre putain d'idée de comment sont représentés les complexes)</p>
<p>Si vous êtes en manque d'aspirine, tout ça est codifié dans la norme <a href="http://fr.wikipedia.org/wiki/IEEE_754">IEEE 754</a>, que Python respecte scrupuleusement.</p>
<p>Mais ça vous fait une belle jambe pas vrai ?</p>
<p>Tout ça pour dire que même avec une belle précision, le nombre de chiffres stockés après la virgule est limité. Du coup, on a une valeur <strong>approximative</strong> stockée dans l'ordi, ce qui fait que les calculs se font sur des approximations :</p>
<pre lang="python">>>> "{0:.35f}".format(0.9999999999999999999999999999999999999999999999999999999 + 0.000000000000000000001)
u'1.00000000000000000000000000000000000'</pre>
<p>En Python on peut gagner en précision en utilisant le module <code>decimal</code>:</p>
<pre lang="python">>>> from decimal import Decimal
>>> Decimal("0.9999999999999999999999999999999999999999999999999999999") + Decimal("0.000000000000000000001")
Decimal('1.000000000000000000001000000')</pre>
<p>C'est plus lent, mais plus intuitif. Quand on manipule des sous, du temps, des unités de poids, de température, de longueur, etc, c'est utile.</p>
<h2>Représentation du texte</h2>
<p>Pour le texte, c'est encore autre chose. Et là je vous renvoie à l'<a href="http://sametmax.com/lencoding-en-python-une-bonne-fois-pour-toute/">article sur les encodings</a>.</p>
<p>En résumé, le stockage du texte n'a rien à avoir avec l'arithmétique binaire, c'est juste qu'on fait correspondre un nombre (on montre souvent sa représentation binaire pour l'ASCII et sa représentation hexa pour l'unicode, mais ça reste un nombre, point) à un caractère. Il y a un grand tableau en mémoire qui fait cette correspondance de manière totalement arbitraire. </p>
<p><strong>C'est une norme arbitraire de correspondance, c'est tout.</strong></p>
<p>Donc quand on vous dit "ecrivez les mots 'glory hole' en binaire", <strong>ça ne veut rien dire</strong>.</p>
<p>Une bonne consigne serait de dire : "donnez moi la suite de nombres, représentés sous forme binaire, qui corresponde aux caractères qui compose les mots 'glory hole' selon l'encoding ASCII".</p>
<p>On peut obtenir la valeur numérique ASCII en utilisant <code>ord()</code> en Python :</p>
<pre lang="python">>>> for x in 'glory hole':
    print(ord(x))
...
103
108
111
114
121
32
104
111
108
101</pre>
<p>Après, c'est juste du formatage pour afficher le binaire :</p>
<pre lang="python">>>> for x in 'glory hole':
...     print("{:b}".format(ord(x)))
...
1100111
1101100
1101111
1110010
1111001
100000
1101000
1101111
1101100
1100101</pre>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/la-fin-du-mystere-du-binaire-nananere/feed/</wfw:commentRss>
		<slash:comments>52</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">8808</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2014/01/JQXdcds.gif" length="511572" type="image/jpg" />	</item>
	</channel>
</rss>
