<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" >

<channel>
	<title>utf8 &#8211; Sam &amp; Max</title>
	<atom:link href="http://sametmax.com/tag/utf8/feed/" rel="self" type="application/rss+xml" />
	<link>http://sametmax.com</link>
	<description>Du code, du cul</description>
	<lastBuildDate>Thu, 05 Sep 2019 08:22:03 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.7</generator>
<site xmlns="com-wordpress:feed-additions:1">32490438</site>	<item>
		<title>La maison des horreurs de l&#8217;encoding</title>
		<link>http://sametmax.com/la-maison-des-horreurs-de-lencoding/</link>
		<comments>http://sametmax.com/la-maison-des-horreurs-de-lencoding/#comments</comments>
		<pubDate>Sun, 29 Jan 2017 14:58:51 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Philo et culture]]></category>
		<category><![CDATA[encoding]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[unicode]]></category>
		<category><![CDATA[utf8]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=22198</guid>
		<description><![CDATA[En 2017, on se touche la nouille pour savoir qui a son architecture multi-services load balancée web scale à base de NOSQL, de containers orchestrés et de serveurs asynchrones. Mais pour afficher du texte y a plus personne hein…]]></description>
				<content:encoded><![CDATA[<p>Ah, l&#8217;encoding, le truc que tout le monde veut mettre sous le tapis. Il faut dire que c&#8217;est dur à gérer. En fait tellement dur que:</p>
<ul>
<li>Les logiciels et pages web continuent parfois d&#8217;afficher des ?? en 2017. Tous les langages laxistes laissent des données corrompues plutôt que d&#8217;avertir le codeur qui du coup n&#8217;apprend jamais à faire les choses correctement.</li>
<li>PHP a littéralement <a href="http://www.slideshare.net/andreizm/the-good-the-bad-and-the-ugly-what-happened-to-unicode-and-php-6">abandonné la version 6</a> car impossible de trouver une solution propre avec leur design.</li>
<li>Perl a mis 10 ans à sortir la version 6 qui <a href="https://perl6advent.wordpress.com/2015/12/07/day-7-unicode-perl-6-and-you/">gère proprement l&#8217;unicode</a>.</li>
<li>NodeJS <a href="http://stackoverflow.com/questions/14551608/list-of-encodings-that-node-js-supports">ignore juste la question</a>, fout tout en utf8 et vous dit de télécharger une lib externe si vous voulez gérer autre chose.</li>
</ul>
<p>Tout ce bordel amène les devs à essayer d&#8217;ignorer le problème le plus longtemps possible. Ca marche assez bien pour les anglophones car leur environnement est assez homogène, orienté ASCII, et certains peuvent faire une très belle carrière en restant joyeusement ignorant.</p>
<p>Ca marche beaucoup moins bien pour les européens, et pas du tout pour le monde arabe et asiatique. Néanmoins, pas besoin de chercher bien loin pour trouver des échecs critiques.</p>
<p>Naviguez tranquillement sur <a href="http://www.airedefiesta.com/76-pinatas-y-chuches.html">un site espagnol</a> a priori joli, moderne, utilisant des tildes et tout ce qu&#8217;il faut. Maintenant regardez la requête HTTP, vous noterez que le serveur n&#8217;indique pas le charset du contenu. Fort heureusement dans le HTML vous trouvez:</p>
<pre lang="html"><meta http-equiv="Content-Type" content="ISO-8859-1"></pre>
<p>Nickel, récupérons le texte du bouton &#8220;Ver más ideas&#8221;:</p>
<pre lang="python">
>>> import requests
>>> res = requests.get('http://www.airedefiesta.com/76-pinatas-y-chuches.html') 
>>> data = res.content.split(b'http://www.airedefiesta.com/ideas.html?c=76">')[1].split(b'</a>')[0]
>>> data
b'Ver m\xc3\xa1s ideas'</pre>
<p>Une suite de bits comme maman les aime. On décode:</p>
<pre lang="python">>>> data.decode('ISO-8859-1')
'Ver mÃ¡s ideas'</pre>
<div id="attachment_22201" style="width: 510px" class="wp-caption aligncenter"><a href="http://sametmax.com/wp-content/uploads/2017/01/Dl28IBk.gif" class="grouped_elements" rel="tc-fancybox-group22198"><img src="http://sametmax.com/wp-content/uploads/2017/01/Dl28IBk.gif" alt="Chenille dans labyrinthe" width="500" height="216" class="size-full wp-image-22201" /></a><p class="wp-caption-text">Et puis on ne voudrait pas que vous arriviez au château trop vite</p></div>
<p>Enfer et sodomie ! Le charset déclaré n&#8217;est pas celui utilisé. Tentons un truc au hasard:</p>
<pre lang="python">>>> data.decode('utf8')
'Ver más ideas'</pre>
<p>Bref, en 2017, on se touche la nouille pour savoir qui a son architecture multi-services load balancée web scale à base de NoSQL, de containers orchestrés et de serveurs asynchrones. Mais pour afficher du texte y a plus personne hein&#8230;</p>
<p>Vous croyez que ce ne sont que les amateurs qui font ces erreurs. Naaaaaaaaa. Par exemple le standard pour les fichiers zip a une vision <a href="https://marcosc.com/2008/12/zip-files-and-encoding-i-hate-you/">très&#8230; hum&#8230; personnelle</a> du traitement de l&#8217;encoding des noms de fichier.</p>
<p>L&#8217;encoding, c&#8217;est la raison majeur de l’incompatibilité de Python 2 et 3, mais aussi un signe de la bonne santé de la techno puisque c&#8217;est un des rares vieux langages (je rappelle que Python est plus vieux que Java) à gérer la chose correctement. A savoir:</p>
<ul>
<li>Avoir un type haut niveau qui fait abstraction de l&#8217;encoding pour le texte.</li>
<li>Forcer le développeur à spécifier l&#8217;encoding pour les entrées et les sorties.</li>
<li>Eviter toute conversion automatique.</li>
<li>Avoir de l&#8217;utf8 par défaut là où ça a du sens.</li>
<li>Lever des erreurs plutôt que de corrompre les données.</li>
<li>Avoir une API unifiée autour de la notion de &#8220;codec&#8221; qui marche pour le FS, le réseau, les chaînes internes, etc.</li>
</ul>
<p>Python n&#8217;est pas parfait pour autant. Par exemple il garantit un accès 0(1) indexing sur les strings, ce qui à mon sens est inutile. Swift a un meilleur design pour ce genre de choses. Mais globalement c&#8217;est quand même super bon.</p>
<p>Si ne savez toujours pas comment ça marche, on a évidement <a href="http://sametmax.com/lencoding-en-python-une-bonne-fois-pour-toute/">un tuto pour ça</a>.</p>
<p>Alors pourquoi l&#8217;encoding c&#8217;est un truc compliqué ? </p>
<p>Et bien parce que comme pour le temps ou l&#8217;<a href="http://sametmax.com/linternationalisation-cest-long-et-dur-et-ca-racle-le-fond/">i18n</a>, ça touche à la culture, au langage, à la politique, et on a accumulé les problèmes au fil des années. </p>
<div id="attachment_22203" style="width: 466px" class="wp-caption aligncenter"><a href="http://sametmax.com/wp-content/uploads/2017/01/SBygvL4.png" class="grouped_elements" rel="tc-fancybox-group22198"><img src="http://sametmax.com/wp-content/uploads/2017/01/SBygvL4.png" alt="A solid dick from an iron man" width="456" height="390" class="size-full wp-image-22203" /></a><p class="wp-caption-text">Mais je vous jure ça avait du sens y a 40 ans !</p></div>
<p>Par exemple, parlons un peu d&#8217;UTF.</p>
<p>Vous savez, on vous dit toujours d&#8217;utiliser utf8 partout pour être tranquille&#8230;</p>
<p>Mais déjà se pose la question : avec ou sans BOM ?</p>
<p>Le BOM, c&#8217;est une suite d&#8217;octets qui indique en début de fichier qu&#8217;il contient de l&#8217;UTF. Si ça à l&#8217;air pratique, c&#8217;est parce que ça l&#8217;est. Malheureusement, celui-ci n&#8217;est pas obligatoire, certaines applications le requièrent, d&#8217;autres l&#8217;ignorent, et d&#8217;autres plantent face au BOM. D&#8217;ailleurs, <a href="http://www.unicode.org/versions/Unicode5.0.0/ch02.pdf">le standard unicode</a> lui-même ne le recommande pas:</p>
<blockquote><p>Use of a BOM is neither required nor recommended for UTF-8</p></blockquote>
<p>Ca aide vachement à faire son choix.</p>
<p>Perso je ne le mets jamais, sauf si je dois mélanger des fichiers de différents encodings et les différencier plus tard. </p>
<p>Mais Powershell et Excel par exemple, fonctionnent parfois mieux si vous leur passez des données avec le BOM :)</p>
<p>Si vous avez un peu creusé la question, vous savez qu&#8217;il existe aussi UTF16 (par défaut dans l&#8217;API de Windows 7 et 8 et les chaînes de .NET), UTF32 et UTF64. Ils ont des variantes Big et Little Endians, qui ne supportent pas le BOM, et une version neutre qui le supporte, pour faciliter la chose. </p>
<p>Bien, bien, bien.</p>
<p>Mais saviez-vous qu&#8217;il existe aussi UTF-1, 5 et 6 ? Si, si. Et UTF9 et UTF18 aussi, mais sauf que eux ce sont des poissons d&#8217;avril, parce que les gens qui écrivent les RFC sont des mecs trop funs en soirées.</p>
<p>Que sont devenus ces derniers ? Et bien ils ont été proposés comme encoding pour l&#8217;internationalisation des noms de domaine. UTF5 est un encoding en base 32, comme son nom l&#8217;indique. Si, 2 puissance 5 ça fait 32. Funs en soirée, tout ça.</p>
<p>Néanmoins quelqu&#8217;un est arrivé avec une plus grosse bit(e), <a href="https://en.wikipedia.org/wiki/Punycode">punycode</a>, en base 36, et a gagné la partie. J&#8217;imagine que les gens se sont dit qu&#8217;utiliser base64 était déjà trop fait par tout le monde et qu&#8217;on allait pas se priver de cette occasion fabuleuse de rajouter un standard.</p>
<p>Standard qui ne vous dispense pas, dans les URLs, d&#8217;encoder DIFFÉREMMENT ce qui n&#8217;est pas le nom de domaine avec les bons escaping. Et son lot de <a href="http://treerex.blogspot.fr/2013/08/a-url-encoding-horror-story.html">trucs fantastiques</a>. Encoding qui est différent pour les valeurs de formulaire.</p>
<p>Python supporte par ailleurs très bien tout ça:</p>
<pre lang="python">>>> 'Père noël'.encode('punycode')
b'Pre nol-2xa6a'
>>> import urllib
>>> urllib.parse.quote('Père Noël')
'P%C3%A8re%20No%C3%ABl'
>>> urllib.parse.quote_plus('Père Noël')
'P%C3%A8re+No%C3%ABl'
</pre>
<p>En plus, si Punycode est l&#8217;encoding par défaut utilisé dans les noms de domaine, c&#8217;est donc aussi celui des adresses email. Ce qui vous permettra de profiter des interprétations diverses de la spec, comme par exemple le retour de la valeur d&#8217;un HTML input marqué &#8220;email&#8221;, qui <a href="https://www.grepular.com/The_Sad_State_of_HTML_Email_Input_Fields_and_IDNs">diffère selon les navigateurs</a>.</p>
<div id="attachment_22204" style="width: 510px" class="wp-caption aligncenter"><a href="http://sametmax.com/wp-content/uploads/2017/01/f9aqtmt.gif" class="grouped_elements" rel="tc-fancybox-group22198"><img src="http://sametmax.com/wp-content/uploads/2017/01/f9aqtmt.gif" alt="Président faisant un fuck dans idiocracy" width="500" height="281" class="size-full wp-image-22204" /></a><p class="wp-caption-text">If you don&#8217;t encode in Tarrlytons&#8230;fuck you!</p></div>
<p>Pourquoi je vous parle des adresses emails tout à coup ? Ah ah ah ah ah ah ah !</p>
<p>Mes pauvres amis.</p>
<p>Je ne vous avais jamais parlé d&#8217;utf7 ?</p>
<p>Non, je ne me fous pas de votre gueule. Je suis très sérieux.</p>
<p>Figurez-vous que le format email MIME <a href="https://en.wikipedia.org/wiki/UTF-7">accepte l&#8217;utilisation d&#8217;utf7</a> en lieu et place de base64.</p>
<p>Mais ce n&#8217;est pas ça le plus drôle.</p>
<p>Y a mieux, je vous jure.</p>
<p>UTF7 est en effet l&#8217;encoding par défaut pour IMAP, particulièrement les noms des boîtes aux lettres. Vous savez, &#8220;INBOX&#8221;, &#8220;Spams&#8221; et &#8220;Messages envoy&#038;AOk-s&#8221; ;)</p>
<p>Or comme l&#8217;enculerie ne serait pas aussi délicieuse sans un peu de sable&#8230;</p>
<p>La version utilisée maintenant (et pour toujourssssssss) par IMAP est une version d&#8217;UTF7 <a href="https://bugs.python.org/issue5305">non standard et modifiée</a>.</p>
<p>Pourquoi ? Ben parce qu&#8217;allez-vous faire foutre.</p>
<div id="attachment_22202" style="width: 437px" class="wp-caption aligncenter"><a href="http://sametmax.com/wp-content/uploads/2017/01/tvNESh1.jpg" class="grouped_elements" rel="tc-fancybox-group22198"><img src="http://sametmax.com/wp-content/uploads/2017/01/tvNESh1.jpg" alt="The choosen one, crying" width="427" height="231" class="size-full wp-image-22202" /></a><p class="wp-caption-text">The choosen one would soon realize that some things survived outside of the vault. Like bad UI and terrible IT standards. And his &#8216;science&#8217; skills is at 42% and life sucks.</p></div>
<p>Au final je n&#8217;ai fait que parloter d&#8217;UTF, mais souvenez-vous que:</p>
<pre lang="python">>>> import encodings
>>> len(encodings.aliases.aliases)
322
</pre>
<p>Donc on n&#8217;a fait qu&#8217;effleurer la surface de l&#8217;anus boursouflé de la mouche. </p>
<p>J&#8217;espère que la nuit, à 3h du mat, lorsque votre prochaine mise en prod agonisera sur un <code>UnicodeDecodeError</code>, vous penserez à moi et pendant un instant, un sourire se dessinera sous vos larmes.</p>
<div id="attachment_22199" style="width: 310px" class="wp-caption aligncenter"><a href="http://sametmax.com/wp-content/uploads/2017/01/heptapod-writing-in-arrival-300x158.png" class="grouped_elements" rel="tc-fancybox-group22198"><img src="http://sametmax.com/wp-content/uploads/2017/01/heptapod-writing-in-arrival-300x158.png" alt="Ecriture extra-terrestre de the arrival" width="300" height="158" class="size-full wp-image-22199" /></a><p class="wp-caption-text">Militaire : Votre avis ? &#8211; Unicode Consortium : Tuez les tous.</p></div>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/la-maison-des-horreurs-de-lencoding/feed/</wfw:commentRss>
		<slash:comments>13</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">22198</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2017/01/RkYxhXw.jpg" length="65463" type="image/jpg" />	</item>
		<item>
		<title>Toutes les lettres UTF8</title>
		<link>http://sametmax.com/toutes-les-lettres-utf8/</link>
		<comments>http://sametmax.com/toutes-les-lettres-utf8/#comments</comments>
		<pubDate>Wed, 15 Jul 2015 10:38:06 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[unicode]]></category>
		<category><![CDATA[utf8]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=16625</guid>
		<description><![CDATA[Pour l'ascii, on a <code>string.ascii_letters</code>, mais rien de tel pour un autre charset.]]></description>
				<content:encoded><![CDATA[<p>Pour l&#8217;ascii, on a <code>string.ascii_letters</code>, mais rien de tel pour un autre charset.</p>
<p>Voici comment obtenir une string qui contient toutes les lettres en UTF8 :</p>
<pre lang="python">from unicodedata import category

def get_all_unicode_letters(categs=('Lu', 'Ll', 'Lt', 'Lm')):
    # Categores unicode dans lesquelles récupérer les lettres
    # On peut virer 'Lt', 'Lm' si on veut garder des lettres plus
    # proches de notre alphabet
    categs = set(categs) 
    # on prend tous les symboles utf8
    all_unicode = (chr(i) for i in range(65536))
    # on garde ceux qui sont dans une categorie 'lettre'
    return ''.join(c for c in all_unicode if category(c) in categs)

letters = get_all_unicode_letters()</pre>
<p>C&#8217;est quand même bien foutu pour ça unicode : <a href="http://www.fileformat.info/info/unicode/category/index.htm">tout est catégorisé</a> avec les trucs en majuscule, les modifieurs, les nombres, les espaces et tout le bordel.</p>
<p>Par exemple vous voulez voir tous les symboles monétaires :</p>
<pre lang="python">
def pognon():
    all_unicode =  (chr(i) for i in range(65536))
    return ''.join(c for c in all_unicode if category(c) == 'Sc')

print(pognon())
$¢£¤¥֏؋৲৳৻૱௹฿៛₠₡₢₣₤₥₦₧₨₩₪₫€₭₮₯₰₱₲₳₴₵₶₷₸₹₺꠸﷼﹩＄￠￡￥￦
</pre>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/toutes-les-lettres-utf8/feed/</wfw:commentRss>
		<slash:comments>4</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">16625</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2015/07/AU8MY7S.jpg" length="180164" type="image/jpg" />	</item>
		<item>
		<title>assert &#8220;а&#8221; == &#8220;a&#8221; # lol</title>
		<link>http://sametmax.com/assert-%d0%b0-a-lol/</link>
		<comments>http://sametmax.com/assert-%d0%b0-a-lol/#comments</comments>
		<pubDate>Mon, 09 Jun 2014 08:45:51 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[encoding]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[unicode]]></category>
		<category><![CDATA[utf8]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=10433</guid>
		<description><![CDATA[Python 3, le bonheur d'avoir UTF8 comme encoding par défaut !]]></description>
				<content:encoded><![CDATA[<p>Python 3, le bonheur d&#8217;avoir UTF8 comme encoding par défaut !</p>
<p>En plus, ça ajoute un petit potentiel de lulz.</p>
<p>Par exemple, ceci marche très bien :</p>
<pre lang="python">def test():
    print('Youpi')
    print('Youpi')</pre>
<p>Et ceci&#8230;</p>
<pre lang="python">def test():
    print('Arg')
    print('Arg')</pre>
<p>&#8230; provoque une syntaxe error !</p>
<pre lang="python">  File "<stdin>", line 2
       print('Arg')
    ^
SyntaxError: invalid character in identifier</pre>
<p>La raison est que la première ligne print(&#8216;Arg&#8217;) contient le caractère unicode U+0020, qui est un espace inimprimable, mais pas le même que l&#8217;ascii :)</p>
<p>Bon, vous allez-me dire, on pouvait déjà mélanger les tabs et les espaces, s&#8217;amuser avec les espaces insécables, ou simplement déclarer manuellement l&#8217;encoding et faire pareil&#8230;</p>
<p>Allons plus loin. Saviez-vous qu&#8217;on pouvait utiliser des caractères non-ASCII <strong>dans les identifiants</strong> en Python 3 ?</p>
<p>Ceci est donc parfaitement valide :</p>
<pre lang="python">éôà = 1</pre>
<p>Ce qui invite bien entendu a des choses tout à fait amusantes comme :</p>
<pre lang="python">def аttention():
    print('!')

>>> аttention()
!
>>> attention()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'attention' is not defined</pre>
<p>En effet, j&#8217;ai utilisé le caractère &#8220;а&#8221; cyrilique comme première lettre, et non le &#8220;a&#8221; ASCII. Ils n&#8217;ont pas le même code :</p>
<pre lang="python">
>>> ord("а"), ord("a")
(1072, 97)
>>> "а" == "a"
False</pre>
<p>Quand j&#8217;étais au lycée, une bonne blague qu&#8217;on faisait aux profs était de faire une capture d&#8217;écran du bureau de leur ordi, la mettre en fond d&#8217;écran, virer les icônes et régler la barrer des tâches pour se cacher automatiquement. Ils pensaient que leur machine était freezée, et un reboot ne changeait rien. Des heures à s&#8217;arracher les cheveux.</p>
<p>Avec les identifiants unicodes je pense qu&#8217;on peut retrouver cette merveilleuse créativité avec ses collègues.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/assert-%d0%b0-a-lol/feed/</wfw:commentRss>
		<slash:comments>19</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">10433</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2014/06/iyqfDLr.jpg" length="303031" type="image/jpg" />	</item>
		<item>
		<title>En Python 3, le type bytes est un array d&#8217;entiers</title>
		<link>http://sametmax.com/en-python-3-le-type-bytes-est-un-array-dentiers/</link>
		<comments>http://sametmax.com/en-python-3-le-type-bytes-est-un-array-dentiers/#comments</comments>
		<pubDate>Thu, 05 Dec 2013 16:00:32 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[ascii]]></category>
		<category><![CDATA[bytes]]></category>
		<category><![CDATA[encoding]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[str]]></category>
		<category><![CDATA[unicode]]></category>
		<category><![CDATA[utf8]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=8160</guid>
		<description><![CDATA[Le plus gros changement quand on passe de Python 2 à Python 3, c'est la gestion des chaînes de caractères.]]></description>
				<content:encoded><![CDATA[<p>Le plus gros changement quand on passe de Python 2 à Python 3, c&#8217;est la gestion des chaînes de caractères.</p>
<p>Pour rappel :</p>
<ul>
<li>En 2.7, les chaînes sont par défaut des arrays d&#8217;octets, et il faut les décoder pour obtenir de l&#8217;unicode.</li>
<li>En 3, les chaînes sont par défaut de type &#8216;unicode&#8217;, et il faut les encoder pour obtenir de un array d&#8217;octets.</li>
</ul>
<p>Si vous avez besoin d&#8217;une mise à jour sur l&#8217;encoding en Python, on <a href="http://sametmax.com/lencoding-en-python-une-bonne-fois-pour-toute/">a un article pour ça</a>.</p>
<p>Comme toute entrée ou sortie est forcément un flux d&#8217;octets, mais pas forcément dans le même encodage, Python 2.7 pouvait poser problème pour le débutant qui essayait de comprendre pourquoi son programme plantait, bordel de merde.</p>
<p>La version 3 prend plusieurs mesures pour éviter les bugs vicieux liés à l&#8217;encodage de caractères:</p>
<ul>
<li>L&#8217;encodage par défaut du code est UTF8.</li>
<li>L&#8217;encodage par défaut de lecture et d&#8217;écriture est UTF8.</li>
<li>On ne peut plus mélanger &#8216;bytes&#8217; et &#8216;unicode&#8217;.</li>
<li>Les messages d&#8217;erreur expliquent clairement et tôt tout problème.</li>
</ul>
<p>La plupart du temps, quand on va manipuler du texte, on va donc toujours manipuler de l&#8217;unicode, en Python 3. Ce dernier va nous forcer à faire le décodage / encodage au bon moment.</p>
<p>Mais il restera quelques fois le besoin de manipuler du <code>bytes</code>, et ce type a subi un lifting&#8230;</p>
<h2>La base</h2>
<p>Créer un array d&#8217;octets (le type <code>bytes</code>&#8216;, en Python 3) demande de préfixer une chaîne avec &#8216;b&#8217; :</p>
<pre lang="python">>>> s = b'I am evil, stop laughing!'
>>> type(s)
<class 'bytes'>
>>> print(s)
b'I am evil, stop laughing!'</pre>
<p>Première remarque, on ne peut plus utiliser ce type pour afficher quoi que ce soit, puisque l&#8217;affichage est une représentation du type (appel à <code>__repr__</code>), et pas du texte mis en forme. Déjà Python vous indique la couleur : si vous voulez manipulez du texte, n&#8217;utilisez pas ce type.</p>
<p>Comparez avec le type unicode :</p>
<pre lang="python">>>> u = s.decode('utf8')
>>> type(u)
<class 'str'>
>>> print(u)
I am evil, stop laughing!</pre>
<p>L&#8217;affichage marche comme on s&#8217;y attend. Bref, vous êtes forcé de toujours rester sur de l&#8217;unicode (le type <code>str</code> en Python 3, ce qui porte à confusion) si vous manipulez du texte. Heureusement, c&#8217;est quasiment toujours ce que vous aurez.</p>
<p>Par exemple, si vous ouvrez un fichier en Python 3 :</p>
<pre lang="python">>>> content = open('/etc/fstab').read()
>>> type(content)
<class 'str'></pre>
<p>C&#8217;est du texte. A moins de demander qu&#8217;il soit ouvert en mode binaire :</p>
<pre lang="python">>>>> content = open('/etc/fstab', 'rb').read()
>>> type(content)
<class 'bytes'></pre>
<p>Une autre différence MAJEURE, c&#8217;est que, si dans Python 2.7, les arrays d&#8217;octets pouvaient être manipulés comme un array de lettres :</p>
<pre lang="python">>>> s = 'I put the goal in golem...' 
>>> s[0] # en Python 2.7
>>> 'I'</pre>
<p>En Python 3, les array d&#8217;octets sont au mieux manipulables comme un array d&#8217;entiers :</p>
<pre lang="python">>>> s = b'I put the goal in golem...'
>>> s[0] # en Python 3
73</pre>
<p>La représentation sous forme de lettre est gardée pour l&#8217;initialisation pour des raisons pratiques, mais sous le capot, il se passe ça:</p>
<pre lang="python">>>> bytes([73, 32, 112, 117, 116, 32, 116, 104, 101, 32, 103, 111, 97, 108, 32, 105, 110, 32, 103, 111, 108, 101, 109, 46, 46, 46])
b'I put the goal in golem...'</pre>
<p>D&#8217;ailleurs, on ne peut même plus faire d&#8217;opérations de formatage avec des octets comme en Python 2.7 :</p>
<pre lang="python">>>> b"Welcome to the league of %s" % input('')
Draven
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for %: 'bytes' and 'str'</pre>
<p><code>format()</code> ne marche pas non plus. On est assez proche du tableau d&#8217;octets en C, sauf qu&#8217;en plus, on ne peut pas le modifier :</p>
<pre lang="python">>>> s = b"My right arm is a lot stronger than my left arm."
>>> s[0] = 1
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'bytes' object does not support item assignment</pre>
<p>Les arrays d&#8217;octets sont donc maintenant essentiellement des outils de communication avec le monde extérieur.</p>
<h2>Bytearray</h2>
<p>Il existe encore des raisons de manipuler des arrays d&#8217;octets : les applications scientifiques. Typiquement, les algos de crypto opérent sur des arrays d&#8217;octets.</p>
<p>Pour cette raison, Python 3 vient également avec un nouveau type de base : <code>bytearray</code>, un array d&#8217;octets modifiable.</p>
<pre lang="python">>>> s = bytearray(b"this tasted purple !")
>>> s[2:4] = b'at'
>>> print(s)
bytearray(b'that tasted purple !')</pre>
<p>Et on a toutes les opérations de liste dessus, comme <code>append</code>, <code>pop()</code>, etc :</p>
<pre lang="python">>>> for x in b' ,puY':
...     s.insert(0, x)
... 
>>> print(s)
bytearray(b'Yup, that tasted purple !')</pre>
<p>Attention par contre, ces opérations attendent un entier en paramètres et NON un array d&#8217;octets.</p>
<p>Et un dernier détail :</p>
<pre lang="python">
>>> isinstance(bytes, bytearray)
False
>>> isinstance(bytearray, bytes)
False
</pre>
<h2>Différence entre string et array d&#8217;octets</h2>
<p>Il est facile de confondre tout ce merdier.</p>
<p>En Python 2.7, le type <code>str</code> était un array d&#8217;octets, et on le manipulait comme une chaîne, d&#8217;où la difficulté de transition.</p>
<p>En Python 3, bien qu&#8217;on puisse créer un array d&#8217;octets avec une syntaxe utilisant des lettres, ils ne sont plus du tout utilisés pour la manipulation de texte. Si vous voulez manipuler du texte qui vient de l&#8217;extérieur de votre programme, il faudra toujours le décoder pour obtenir un type <code>str</code> (qui est l&#8217;ancien type <code>unicode</code> de Python 2.7).</p>
<p>Le décodage sera fait automatiquement dans la plupart des cas, et plantera si on tombe sur un cas où vous devez le faire à la main et que vous ne le faites pas. Du coup, plus de difficulté à trouver d&#8217;où vient ce bug d&#8217;encoding, car on a toujours l&#8217;erreur à la source. </p>
<p>En ce sens, Python 3 est beaucoup plus clair : les octets d&#8217;un côté, le texte de l&#8217;autre. Bon, tout ça c&#8217;est de la surcouche, au final, tout est octet. Mais on a rarement envie de manipuler un octet directement, sinon on coderait encore en assembleur.</p>
<p>Avec ce système, Python 3 est le langage le plus sain que j&#8217;ai pu rencontrer dans sa gestion de l&#8217;encodage : il ne cache rien, oblige l&#8217;utilisateur à coder avec de bonnes habitudes, facilite le débugage et met sur le devant de la scène la problématique de l&#8217;encoding, qui est le plus souvent cachée vite fait sous le tapis.</p>
<p>L&#8217;alternative intelligente la plus proche étant celle de node.js, qui <a href="https://github.com/joyent/node/blob/master/lib/buffer.js#L126">interdit tout simplement la plupart des encodings dans son API</a>.</p>
<p>La bonne nouvelle ? 99% du temps, vous n&#8217;aurez même pas à vous en soucier, car ASCII est inclus dans UTF8, et ce sont les encodings les plus utilisés. Avec Python 3 forçant UTF8 par défaut partout et des chaînes en unicode dès le départ, il n&#8217;y a presque rien à faire. Je doute que la plupart des gens aient même à manipuler le type <code>bytes</code>.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/en-python-3-le-type-bytes-est-un-array-dentiers/feed/</wfw:commentRss>
		<slash:comments>19</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">8160</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2013/12/CRutQrO.jpg" length="140436" type="image/jpg" />	</item>
		<item>
		<title>Plus besoin d&#8217;images pour les smileys grâce à Unicode</title>
		<link>http://sametmax.com/plus-besoin-dimages-pour-les-smileys-grace-a-unicode/</link>
		<comments>http://sametmax.com/plus-besoin-dimages-pour-les-smileys-grace-a-unicode/#comments</comments>
		<pubDate>Sat, 25 May 2013 14:03:58 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[smiley]]></category>
		<category><![CDATA[smilye]]></category>
		<category><![CDATA[unicode]]></category>
		<category><![CDATA[utf8]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=4014</guid>
		<description><![CDATA[Faut virer les smiley des logiciels de chat. Utilisons des caractères UTF8, ça sera plus léger, et plus interropérable.]]></description>
				<content:encoded><![CDATA[<h2><img src="https://s.w.org/images/core/emoji/2.4/72x72/2639.png" alt="☹" class="wp-smiley" style="height: 1em; max-height: 1em;" /></h2>
<h2><img src="https://s.w.org/images/core/emoji/2.4/72x72/263a.png" alt="☺" class="wp-smiley" style="height: 1em; max-height: 1em;" /></h2>
<h2>☻</h2>
<p>Maintenant ça passe partout ce genre de truc. Et c&#8217;est dingue ce qu&#8217;ils ont réussi à stuffer dans cet encoding. </p>
<p>Des formes géométriques :</p>
<h2>■</h2>
<p>Des tas de faces :</p>
<p>&#8212;&#8212;&#8212;&#8212;&#8212;<br />
<strong><br />
Grace au support absolument minable de l&#8217;encoding de wordpress, cet article est à moité tronqué. Merci codeur PHP de merde qui n&#8217;a jamais su gérer le texte correctement de ta putain de viiiiiiiiiiiiiiie.</p>
<p>Afin de pouvoir lire l&#8217;article en entier, je <a href="http://goo.gl/zbjJo">l&#8217;ai déporté sur 0bin</a>. Putain.</p>
<p>Moralité, non en fait on ne peut pas utiliser ces smileys partout. Les navigateurs les supportent, les fonts sont sur vos systèmes, les OS les supportent. Mais les développeurs sont toujours trop cons. 10 ans bordel, wordpress a 10 ans et des millions de users. Vous pourriez penser qu&#8217;ils font au minimum le traitement des chaînes de caractères correctement, non ? Je sais pas, un blog, le principe, c&#8217;est pas de TRAITER DU PUTAIN DE TEXTE, MERDE ? </p>
<p></strong></p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/plus-besoin-dimages-pour-les-smileys-grace-a-unicode/feed/</wfw:commentRss>
		<slash:comments>28</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">4014</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2013/05/KRid7RS.jpg" length="87002" type="image/jpg" />	</item>
		<item>
		<title>L&#8217;encoding en Python, une bonne fois pour toute</title>
		<link>http://sametmax.com/lencoding-en-python-une-bonne-fois-pour-toute/</link>
		<comments>http://sametmax.com/lencoding-en-python-une-bonne-fois-pour-toute/#comments</comments>
		<pubDate>Sun, 21 Apr 2013 07:02:43 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[ascii]]></category>
		<category><![CDATA[encoding]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[unicode]]></category>
		<category><![CDATA[utf8]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=5824</guid>
		<description><![CDATA[A la fin de cet article, vous saurez vous sortir de toutes les situations merdiques liées aux encodages.]]></description>
				<content:encoded><![CDATA[<p>J&#8217;avais oublié la zik, je rajoute:</p>
<p><iframe width="560" height="315" src="https://www.youtube.com/embed/i-MAErg8q0w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></p>
<p>Vous avez tous un jour eu l&#8217;erreur suivante :</p>
<pre lang="python">UnicodeDecodeError: 'machine' codec can't decode character 'trucmuche' in position x: ordinal not in range(z)</pre>
<p>Et là, pour vous en sortir, vous en avez chié des ronds de pâté.</p>
<p>Le problème vient du fait que la plupart du temps, ignorer l&#8217;encoding marche : nous travaillons dans des environnements homogènes et toujours avec des données dans le même format, ou un format plus ou moins compatible.</p>
<p>Mais le texte, c&#8217;est compliqué, terriblement compliqué, et le jour où ça se gâte, si vous ne savez pas ce que vous faites, vous ne vous en sortirez pas.</p>
<p>C&#8217;est d&#8217;autant plus vrai en Python car :</p>
<ul>
<li>Par défaut, Python plante sur les erreurs d&#8217;encoding là où d&#8217;autres langages (comme le PHP) se débrouillent pour vous sortir un truc (qui ne veut rien dire, qui peut corrompre toute votre base de données, mais qui ne plante pas).</li>
<li>Python est utilisé dans des environnements hétérogènes. Quand vous codez en JS sur le navigateur, vous n&#8217;avez presque jamais à vous soucier de l&#8217;encoding : le browser gère quasiment tout pour vous. En Python dès que vous allez lire un fichier et l&#8217;afficher dans un terminal, cela fait potentiellement 3 encoding différents.</li>
<li>Python 2.7 a des réglages par défaut très stricts, et pas forcément adaptés à notre informatique moderne (fichier de code en ASCII par exemple).</li>
</ul>
<p>A la fin de cet article, vous saurez vous sortir de toutes les situations merdiques liées aux encodages.</p>
<h2>Règle numéro 1 : Le texte brut n&#8217;existe pas.</h2>
<p>Quand vous avez du texte quelque part (un terminal, un fichier, une base de données&#8230;), il est forcément représenté sous forme de 0 et de 1.</p>
<p>La corrélation entre cette suite de 0 et de 1 et la lettre est faite dans un énorme tableau qui contient toutes les lettres d&#8217;un côté, et toutes les combinaisons de 0 et de 1 de l&#8217;autre. Il n&#8217;y a pas de magie. C&#8217;est un énorme tableau stocké quelque part dans votre ordinateur. <strong>Si vous n&#8217;avez pas ce tableau, vous ne pouvez pas lire du texte. Même le texte le plus simple.</strong></p>
<p>Malheureusement, au début de l&#8217;informatique, <strong>presque chaque pays a créé son propre tableau, et ces tableaux sont incompatibles entre eux</strong> : pour la même combinaison de 0 et de 1, ils donnent un caractère différent voire rien du tout.</p>
<p>La mauvaise nouvelle, c&#8217;est qu&#8217;ils sont encore utilisés aujourd&#8217;hui.</p>
<p>Ces tableaux, c&#8217;est ce qu&#8217;on appelle les encodings, et il y en a beaucoup. Voici la liste de ceux que Python gère :</p>
<pre lang="python">>>> import encodings
>>> print ''.join('- ' + e + '\n' for e in sorted(set(encodings.aliases.aliases.values())))
- ascii
- base64_codec
- big5
- big5hkscs
- bz2_codec
- cp037
- cp1026
- cp1140
- cp1250
- cp1251
- cp1252
- cp1253
- cp1254
- cp1255
- cp1256
- cp1257
- cp1258
- cp424
- cp437
- cp500
- cp775
- cp850
- cp852
- cp855
- cp857
- cp858
- cp860
- cp861
- cp862
- cp863
- cp864
- cp865
- cp866
- cp869
- cp932
- cp949
- cp950
- euc_jis_2004
- euc_jisx0213
- euc_jp
- euc_kr
- gb18030
- gb2312
- gbk
- hex_codec
- hp_roman8
- hz
- iso2022_jp
- iso2022_jp_1
- iso2022_jp_2
- iso2022_jp_2004
- iso2022_jp_3
- iso2022_jp_ext
- iso2022_kr
- iso8859_10
- iso8859_11
- iso8859_13
- iso8859_14
- iso8859_15
- iso8859_16
- iso8859_2
- iso8859_3
- iso8859_4
- iso8859_5
- iso8859_6
- iso8859_7
- iso8859_8
- iso8859_9
- johab
- koi8_r
- latin_1
- mac_cyrillic
- mac_greek
- mac_iceland
- mac_latin2
- mac_roman
- mac_turkish
- mbcs
- ptcp154
- quopri_codec
- rot_13
- shift_jis
- shift_jis_2004
- shift_jisx0213
- tactis
- tis_620
- utf_16
- utf_16_be
- utf_16_le
- utf_32
- utf_32_be
- utf_32_le
- utf_7
- utf_8
- uu_codec
- zlib_codec</pre>
<p>Et certains ont plusieurs noms (des alias), donc on pourrait en compter plus:</p>
<pre lang="python">>>> len(encodings.aliases.aliases.keys())
307</pre>
<p>Quand vous affichez du texte sur un terminal avec un simple <code>print</code>, votre ordinateur va implicitement chercher le tableau qu&#8217;il pense être le plus adapté, et fait la traduction. Même pour le texte le plus simple. Même pour un espace tout seul.</p>
<p><strong>Mais surtout, ça veut dire que votre propre code EST dans un encoding. Et vous DEVEZ savoir lequel.</strong></p>
<h2>Règle numéro 2 : utf8 est le langage universel, utilisez-le</h2>
<p>Il existe un encoding qui essaye des regrouper toutes les langues du monde, et il s&#8217;appelle unicode. Unicode est un tableau gigantesque qui contient des combinaisons de 1 et de 0 d&#8217;un côté, et les caractères de toutes la langues possibles de l&#8217;autre : chinois, arabe, français, espagnol, russe&#8230;</p>
<p>Bon, il ne contient pas encore absolument tout, mais il couvre suffisamment de terrain pour éliminer 99.999999999% des problèmes de communications de texte entre machines dans le monde.</p>
<p>Le défaut d&#8217;Unicode est qu&#8217;il est plus lent et prend plus de place que d&#8217;autres représentations du même texte. Aujourd&#8217;hui le téléphone le plus pourri a 10 fois la puissance nécessaire, et ce n&#8217;est plus un souci : il peut être utilisé presque partout (sauf peut-être dans l&#8217;embarqué drastique) sans même réfléchir à la question. Tous les langages les plus importants, tous les services les plus importants, tous les logiciels les plus importants gèrent unicode.</p>
<p>Il y a plusieurs implémentations concrètes d&#8217;unicode, la plus célèbre est &#8220;UTF 8&#8221;.</p>
<p><strong>Moralité, par défaut, utilisez utf-8.</strong></p>
<p>Une fois, à l&#8217;entretien d&#8217;embauche, un mec m&#8217;avait reproché d&#8217;utiliser UTF8 parce que &#8220;ça posait des problèmes d&#8217;encoding&#8221;. Comprenez bien qu&#8217;utf-8 ne pose aucun problème d&#8217;encoding. Ce sont tous les autres codecs du monde qui posent des problèmes d&#8217;encoding. UTF-8 est certainement le seul à justement, ne poser aucun problème.</p>
<p>UTF 8 est le seul encoding vers lequel, aujourd&#8217;hui, on puisse convertir vers et depuis (pratiquement) n&#8217;importe quel autre codec du monde. C&#8217;est un espéranto. C&#8217;est une pierre de rosette. C&#8217;est au texte ce que l&#8217;or est à l&#8217;économie.</p>
<p>Si UTF8 vous pose &#8220;un problème d&#8217;encoding&#8221;, c&#8217;est que vous ne savez pas dans quel encoding votre texte est actuellement ou comment le convertir. C&#8217;est tout.</p>
<p>Il n&#8217;y a presque aucune raison de ne pas utiliser UTF8 aujourd&#8217;hui (à part sur des vieux systèmes ou des systèmes où les ressources sont tellement limitées que vous n&#8217;utiliseriez pas Python de toute façon).</p>
<p><strong>Utilisez utf8. Partout. Tout le temps.</strong></p>
<p>Si vous communiquez avec un système qui ne comprend pas UTF8, convertissez.</p>
<p>Mais gardez votre partie en UTF8.</p>
<h2>Règle numéro 3 : il faut maîtriser l&#8217;encoding de son code</h2>
<p>Le fichier dans lequel vous écrivez votre code est dans un encoding et ce n&#8217;est pas lié à votre OS. C&#8217;est votre éditeur qui s&#8217;en occupe. Apprenez à régler votre éditeur pour qu&#8217;il utilise l&#8217;encoding que vous voulez.</p>
<p>Et l&#8217;encoding que vous voulez est UTF8.</p>
<p><strong>Si vous ne savez pas dans quel encoding est votre code, vous ne pouvez pas manipuler du texte et garantir l&#8217;absence de bug.</strong></p>
<p>Vous ne POUVEZ PAS.</p>
<p>Donc réflexe : vous configurez votre éditeur de texte pour sauvegarder tous vos nouveaux fichiers par défaut en UTF8. Maintenant. Tout de suite.</p>
<p>Regardez dans la doc de l&#8217;éditeur, dans l&#8217;aide ou tapez sur Google, mais faites le.</p>
<p>Puis il faut déclarer cet encoding à la première ligne de chaque fichier de code avec l&#8217;expression suivante :</p>
<pre lang="python"># coding: encoding </pre>
<p>Par exemple :</p>
<pre lang="python"># coding: utf8 </pre>
<p>C&#8217;est une spécificité de Python : si l&#8217;encoding du fichier est différent de l&#8217;encoding par défaut du langage, il faut le déclarer sinon le programme plantera à la première conversion. En Python 2.7, l&#8217;encoding par défaut est ASCII, donc il faut presque toujours le déclarer. En Python 3, l&#8217;encoding par défaut est UTF8 et on peut donc l&#8217;omettre si on l&#8217;utilise. Ce que vous allez faire après la lecture de cet article.</p>
<p>Ensuite, il existe deux types de chaînes de caractères en Python :</p>
<ul>
<li>La chaîne de caractères encodée: type &#8216;str&#8217; en Python 2.7, &#8216;byte&#8217; en Python 3.</li>
<li>La chaîne de caractères décodée: type &#8216;unicode&#8217; en Python 2.7, et &#8216;str&#8217; en python 3 (sic).</li>
</ul>
<p>Illustration :</p>
<pre lang="python">
$ python2.7
Python 2.7.3 (default, Aug  1 2012, 05:14:39) 
[GCC 4.6.3] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> type('chaine') # bits => encodée
<type 'str'>
>>> type(u'chaine') # unicode => décodée
<type 'unicode'>
</pre>
<pre lang="python">
$ python3
Python 3.2.3 (default, Oct 19 2012, 20:10:41) 
[GCC 4.6.3] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> type("chaine") # unicode => decodée
<class 'str'>
>>> type(b"chaine") # bits => encodée

<class 'bytes'>
</pre>
<p>Votre but, c&#8217;est de n&#8217;avoir dans votre code que des chaînes de type &#8216;unicode&#8217;.</p>
<p>En Python 3, c&#8217;est automatique. Toutes les chaînes sont de type &#8216;unicode&#8217; (appelé &#8216;str&#8217; dans cette version, je sais, je sais, c&#8217;est confusionant à mort) par défaut.</p>
<p>En Python 2.7 en revanche, il faut préfixer la chaîne par un <code>u</code>.</p>
<p>Donc, dans votre code, TOUTES vos chaînes doivent être déclarées ainsi :</p>
<pre lang="pyhton">u"votre chaîne"</pre>
<p>Oui, c&#8217;est chiant. Mais c&#8217;est indispensable. Encore une fois, il n&#8217;y a pas d&#8217;alternative (dites le avec la voix de Thatcher si ça vous excite).</p>
<p>Si vous voulez, vous pouvez activer le comportement de Python 3 dans Python 2.7 en mettant ceci au début de CHACUN de vos modules :</p>
<pre lang="python">from __future__ import unicode_literals</pre>
<p>Ceci n&#8217;affecte que le fichier en cours, jamais les autres modules.</p>
<p>On peut le mettre <a href="http://sametmax.com/personnalisez-le-demarrage-dipython/">au démarrage d&#8217;iPython également</a>.</p>
<p>Je résume :</p>
<ul>
<li>Réglez votre éditeur sur UTF8.</li>
<li>Mettez <code># coding: utf8 </code> au début de vos modules.</li>
<li>Préfixez toutes vos chaînes de <code>u</code> ou faites <code>from __future__ import unicode_literals</code> en début de chaque module.</li>
</ul>
<p>Si vous ne faites pas cela, votre code marchera. La plupart de temps. Et un jour, dans une situation particulière, il ne marchera plus. Plus du tout.</p>
<p>Oh, et ce n&#8217;est pas grave si vous avez d&#8217;anciens modules dans d&#8217;autres encodings. Tant que vous utilisez des objets &#8216;unicode&#8217; partout, ils marcheront sans problème ensemble.</p>
<h2>Règle numéro 4 : décodez toutes les entrées de votre programme</h2>
<p>La partie difficile de ce conseil, c&#8217;est de savoir ce qu&#8217;est une entrée.</p>
<p>Je vais vous donner une définition simple : <strong>tout ce qui ne fait pas partie du code de votre programme et qui est traité dans votre programme est une entrée.</strong></p>
<p>Le texte des fichiers, le nom de ces fichiers, le retour des appels système, le retour d&#8217;une ligne de commande parsée, la saisie utilisateur sur un terminal, le retour d&#8217;une requête SQL, le téléchargement d&#8217;une donnée sur le Web, etc.</p>
<p>Ce sont toutes des entrées.</p>
<p><strong>Comme tous les textes du monde, les entrées sont dans un encoding. Et vous DEVEZ savoir lequel.</strong></p>
<p>Comprenez bien, si vous ne connaissez pas l&#8217;encoding de vos entrées, ça marchera la plupart du temps, et un jour, ça va planter.</p>
<p>Il n&#8217;y a pas d&#8217;alternative (bis).</p>
<p>Or, <strong>il n&#8217;y a pas de moyen de détecter un encoding de façon fiable.</strong></p>
<p>Donc, soit le fournisseur de la donnée vous donne cette information (settings dans la base de données, doc de votre logiciel, configuration de votre OS, spec du client, coup de fils au fournisseur&#8230;), soit vous êtes baisés.</p>
<p>On ne peut pas lire un simple fichier si on ne connait pas son encoding. Point.</p>
<p>Si cela a marché jusqu&#8217;ici pour vous, c&#8217;est que vous avez eu de la chance : la plupart de vos fichiers étaient dans l&#8217;encoding de votre éditeur et de votre système. Tant qu&#8217;on travaille sur sa machine, tout va bien.</p>
<p>Si vous lisez une page HTML, l&#8217;encoding est souvent déclaré dans la balise META ou dans un header.</p>
<p>Si vous écrivez dans un terminal, l&#8217;encoding du terminal est accessible avec <code>sys.(stdin|stdout).encoding</code>.</p>
<p>Si vous manipulez des noms de fichier, on peut récupérer l&#8217;encoding du file system en cours avec <code>sys.getfilesystemencoding()</code>.</p>
<p>Mais parfois il n&#8217;y a pas d&#8217;autres moyens d&#8217;obtenir cette information que de demander à la personne qui a produit la donnée. Parfois même, l&#8217;encoding déclaré est faux.</p>
<p>Dans tous les cas, vous avez besoin de cette information.</p>
<p>Et une fois que vous l&#8217;avez, il faut décoder le texte reçu.</p>
<p>La manière la plus simple de faire cela est :</p>
<pre lang="python">votre_chaine = votre_chaine.decode('nom_du_codec')</pre>
<p>Le texte sera de type &#8216;str&#8217;, et <code>decode()</code> retourne (si vous lui fournissez le bon codec ;-)), une version &#8216;unicode&#8217;.</p>
<p>Exemple, obtenir une chaîne &#8216;unicode&#8217; depuis une chaîne &#8216;str&#8217; encodée en utf8 :</p>
<pre lang="python">>>> une_chaine = 'Chaîne' # mon fichier est encodé en UTF8, donc la chaine est en UTF8
>>> type(une_chaine)
<type 'str'>
>>> une_chaine = une_chaine.decode('utf8')
>>> type(une_chaine)
<type 'unicode'>
</pre>
<p>Donc dès que vous lisez un fichier, récupérez une réponse d&#8217;une base de données ou parsez des arguments d&#8217;un terminal, appelez <code>decode()</code> sur la chaîne reçue.</p>
<h2>Règle numéro 5 : encodez toutes les sorties de votre programme</h2>
<p>La partie difficile de ce conseil, c&#8217;est de savoir ce qu&#8217;est une sortie.</p>
<p>Encore une fois, une définition simple : <strong>toute donnée que vous traitez et qui va être lue par autre chose que votre code est une sortie.</strong></p>
<p>Un <code>print</code> dans un terminal est une sortie, un <code>write()</code> dans un fichier est une sortie, un <code>UPDATE</code> en SQL est une sortie, un envoi dans une socket est une sortie, etc.</p>
<p>Le reste du monde ne peut pas lire les objets &#8216;unicode&#8217; de Python. Si vous écrivez ces objets dans un fichier, un terminal ou dans une base de données, Python va les convertir automatiquement en objet &#8216;str&#8217;, et l&#8217;encoding utilisé dépendra du contexte.</p>
<p>Malheureusement, il y a une limite à la capacité de Python à décider du bon encoding.</p>
<p>Donc, tout comme il vous faut connaitre l&#8217;encoding d&#8217;un texte en entrée, il vous faut connaitre l&#8217;encoding attendu par le système avec lequel vous communiquez en sortie : sachez quel est l&#8217;encoding du terminal, de votre base de données ou système de fichiers sur lequel vous écrivez.</p>
<p>Si vous ne pouvez pas savoir (page Web, API, etc), utilisez UTF8.</p>
<p>Pour ce faire, il suffit d&#8217;appelez <code>encode()</code> sur tout objet de type &#8216;unicode&#8217; :</p>
<pre lang="python">
une_chaine = une_chaine.encode('nom_du_codec')
</pre>
<p>Par exemple, pour convertir un objet &#8216;unicode&#8217; en &#8216;str&#8217; utf8:</p>
<pre lang="python">>>> une_chaine = u'Chaîne'
>>> type(une_chaine)
<type 'unicode'>
>>> une_chaine = une_chaine.encode('utf8')
>>> type(une_chaine)
<type 'str'>
</pre>
<h2>Résumé des règles</h2>
<ol>
<li>Le texte brut n&#8217;existe pas.</li>
<li>Utilisez UTF8. Maintenant. Partout.</li>
<li>Dans votre code, spécifiez l&#8217;encoding du fichier et déclarez vos chaînes comme &#8216;unicode&#8217;.</li>
<li>À l&#8217;entrée, connaissez l&#8217;encoding de vos données, et décodez avec <code>decode()</code>.</li>
<li>A la sortie, encodez dans l&#8217;encoding attendu par le système qui va recevoir la données, ou si vous ne pouvez pas savoir, en UTF8, avec <code>encode()</code>.</li>
</ol>
<p>Je sais que ça vous démange de voir un cas concret, alors voici un pseudo programme (<a href="https://github.com/sametmax/codes-des-articles/blob/master/2013/avril/encoding.py">téléchargeable ici</a>) :</p>
<pre lang="python"># coding: utf-8 


# toutes les chaines sont en unicode (même les docstrings)
from __future__ import unicode_literals

"""
    Un script tout pourri qui télécharge plein de page et les sauvegarde
    dans une base de données sqlites.

    On écrit dans un fichier de log les opérations effectuées.
"""

import re
import urllib2
import sqlite3

pages = (
    ('Snippets de Sebsauvage', 'http://www.sebsauvage.net/python/snyppets/'),
    ('Top 50 de bashfr', 'http://danstonchat.com/top50.html'),
)

# création de la base de données
conn = sqlite3.connect(r"backup.db")
c = conn.cursor()

try:
    c.execute('''
        CREATE TABLE pages (
            id INTEGER PRIMARY KEY,
            nom TEXT,
            html TEXT
        )'''
    )
except sqlite3.OperationalError:
    pass

log = open('backup.log', 'wa')

for nom, page in pages:

    # ceci est une manière très fragile de télécharger et
    # parser du HTML. Utilisez plutôt scrapy et beautifulsoup
    # si vous faites un vrai crawler
    response = urllib2.urlopen(page)
    html = response.read(100000)

    # je récupère l'encoding à l'arrache
    encoding = re.findall(r'<meta.*?charset=["\']*(.+?)["\'>]', html, flags=re.I)[0]

    # html devient de l'unicode
    html = html.decode(encoding)

    # ici je peux faire des traitements divers et varié avec ma chaîne
    # et en fin de programme...

    # la lib sqlite convertie par défaut tout objet unicode en UTF8
    # car c'est l'encoding de sqlite par défaut donc passer des chaînes
    # unicode marche, et toutes les chaînes de mon programme sont en unicode
    # grace à mon premier import
    c.execute("""INSERT INTO pages (nom, html) VALUES (?, ?)""", (nom, html))

    # j'écris dans mon fichier en UTF8 car c'est ce que je veux pouvoir lire
    # plus tard
    msg = "Page '{}' sauvée\n".format(nom)
    log.write(msg.encode('utf8'))

    # notez que si je ne fais pas encode(), soit:
    # - j'ai un objet 'unicode' et ça plante
    # - j'ai un objet 'str' et ça va marcher mais mon fichier contiendra
    #   l'encoding de la chaîne initiale (qui ici serait aussi UTF8, mais
    #   ce n'est pas toujours le cas)

conn.commit()
c.close()

log.close()
</pre>
<h2>Quelques astuces</h2>
<p>Certaines bibliothèques acceptent indifféremment des objets &#8216;unicode&#8217; et &#8216;str&#8217; :</p>
<pre lang="python">>>> from logging import basicConfig, getLogger
>>> basicConfig()
>>> log = getLogger()
>>> log.warn("Détécé")
WARNING:root:Détécé
>>> log.warn(u"Détécé")
WARNING:root:Détécé
</pre>
<p>Et ce n&#8217;est pas forcément une bonne chose car si il y a derrière écriture dans un fichier de log, cela peut poser problème.</p>
<p>D&#8217;autres ont besoin qu&#8217;on leur précise:</p>
<pre lang="python">>>> import re
>>> import re
>>> re.search('é', 'télé')
<_sre.SRE_Match object at 0x7fa4d3f77238>
>>> re.search(u'é', u'télé', re.UNICODE)
<_sre.SRE_Match object at 0x7fa4d3f772a0></pre>
<p>Le module <code>re</code> par exemple aura des résultats biaisés sur une chaîne &#8216;unicode&#8217; si on ne précise pas le flag <code>re.UNICODE</code>.</p>
<p>D&#8217;autres n&#8217;acceptent pas d&#8217;objet &#8216;str&#8217;:</p>
<pre lang="python">>>> import io
>>> >>> io.StringIO(u'é')
<_io.StringIO object at 0x14a96d0>
>>> io.StringIO(u'é'.encode('utf8'))
Traceback (most recent call last):
  File "<ipython-input-5-16988a0d4ac4>", line 1, in <module>
    io.StringIO('é'.encode('utf8'))
TypeError: initial_value must be unicode or None, not str</pre>
<p>D&#8217;autres encore n&#8217;acceptent pas d&#8217;objet &#8216;unicode&#8217;:</p>
<pre lang="python">>>> import base64
>>> base64.encodestring('é'.encode('utf8'))
'w6k=\n'
>>> base64.encodestring(u'é')
Traceback (most recent call last):
  File "<ipython-input-3-1714982ca68e>", line 1, in <module>
    base64.encodestring('é')
  File "/usr/lib/python2.7/base64.py", line 315, in encodestring
    pieces.append(binascii.b2a_base64(chunk))
UnicodeEncodeError: 'ascii' codec can't encode character u'\xe9' in position 0: ordinal not in range(128)</pre>
<p>Cela peut être pour des raison de performances (certaines opérations sont plus rapides sur un objet &#8216;str&#8217;), ou pour des raisons historiques, d&#8217;ignorance ou de paresse.</p>
<p>Vous ne pouvez pas le deviner à l&#8217;avance. Souvent c&#8217;est marqué dans la doc, sinon il faut tester dans le shell.</p>
<p>Une bibliothèque bien faite demandera de l&#8217;unicode et vous retournera de l&#8217;unicode, vous libérant l&#8217;esprit. Par exemple, <a href="sametmax.com/sept-petites-libs-qui-changent-la-vie-dun-dev-python/">requests</a> et l&#8217;ORM <a href="http://sametmax.com/quels-gros-sites-sont-faits-en-django/">Django</a> le font, et communiquent avec le reste du monde (en l&#8217;occurence le Web et les bases de données) dans le meilleur encoding possible automatiquement de manière transparente. Quand c&#8217;est possible bien entendu, parfois il faudra forcer l&#8217;encoding car le fournisseur de votre donnée déclare le mauvais. Vous n&#8217;y pouvez rien, c&#8217;est pareil pour tous les langages du monde.</p>
<p>Enfin il existe des raccourcis pour certaines opérations, utilisez-les autant que possible. Par exemple, pour lire un fichier, au lieu de faire un simple <code>open()</code>, vous pouvez faire :</p>
<pre lang="python">from codecs import open

# open() de codec à exactement la même API, y compris avec "with"
f = open('fichier', encoding='encoding')</pre>
<p>Les chaînes récupérées seront automatiquement sous forme d&#8217;objet &#8216;unicode&#8217; au lieu d&#8217;objet &#8216;str&#8217; qu&#8217;il vous aurait fallu convertir à la main.</p>
<h2>Les outils de la dernière chance</h2>
<p>Je vous ai menti, si vous ne connaissez pas l&#8217;encoding de vos entrées ou de vos sorties, il vous reste encore quelques options.</p>
<p>Sachez cependant que ces options sont des hacks, des trucs à tenter quand tout ce qui a été décrit plus haut a foiré.</p>
<p>Si vous faites bien votre boulot, ça ne doit pas arriver souvent. Une à deux fois max dans votre année, sauf environnement de travail très très merdique.</p>
<p>D&#8217;abord, parlons de l&#8217;entrée.</p>
<p>Si vous recevez un objet et qu&#8217;il vous est impossible de trouver l&#8217;encoding, vous pouvez forcer un décodage imparfait avec <code>decode()</code> en spécifiant le paramètre <code>error</code>.</p>
<p>Il peut prendre les valeurs suivantes :</p>
<ul>
<li><code>'strict'</code> : lever une exception en cas d&#8217;erreur. C&#8217;est le comportement par défaut.</li>
<li><code>'ignore'</code> : tout caractère qui provoque une erreur est ignoré.</li>
<li><code>'replace'</code> : tout caractère qui provoque une erreur est remplacé par un point d&#8217;interrogation.</li>
</ul>
<pre lang="python">>>> print 'Père Noël'.decode('ascii')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
UnicodeDecodeError: 'ascii' codec can't decode byte 0xc3 in position 1: ordinal not in range(128)
>>> print 'Père Noël'.decode('ascii', errors='ignore')
Pre Nol
>>> print 'Père Noël'.decode('ascii', errors='replace')
P��re No��l</pre>
<p>Mozilla vient également à la rescousse avec sa lib <a href="https://pypi.python.org/pypi/chardet">chardet</a> qu&#8217;il faut donc <a href="http://sametmax.com/votre-python-aime-les-pip/">installer</a> :</p>
<pre lang="bash">pip install chardet</pre>
<p>Et qui TENTE (du verbe &#8216;tenter&#8217;, &#8220;qui essaye&#8221;, et qui donc peut échouer et se tromper) de détecter l&#8217;encoding utilisé.</p>
<pre lang="python">>>> chardet.detect(u'Le Père Noël est une ordure'.encode('utf8'))
{'confidence': 0.8063275188616134, 'encoding': 'ISO-8859-2'}
>>> chardet.detect(u"Le Père Noël est une ordure j'ai dis enculé".encode('utf8'))
{'confidence': 0.87625, 'encoding': 'utf-8'}</pre>
<p>Cela marche pas trop mal, mais n&#8217;attendez pas de miracles. Plus il y a de texte, plus c&#8217;est précis, et plus le paramètre <code>confidence</code> est proche de 1.</p>
<p>Parlons maintenant de la sortie, c&#8217;est à dire le cas où le système qui va recevoir vos données est une grosse quiche qui plante dès qu&#8217;on lui donne autre chose que de l&#8217;ASCII.</p>
<p>Je ne veux balancer personne, mais mon regard se tourne vers l&#8217;administration américaine. Subtilement. De manière insistante.</p>
<p>D&#8217;abord, <code>encode()</code> accepte les mêmes valeurs pour <code>errors</code> que <code>decode()</code>. Mais en prime, il accepte <code>'xmlcharrefreplace'</code>, très pratique pour les fichiers XML :</p>
<pre lang="python">>>> u"Et là-bas, tu vois, c'est la coulée du grand bronze".encode('ascii', errors='xmlcharrefreplace')
"Et l&#224;-bas, tu vois, c'est la coul&#233;e du grand bronze"</pre>
<p>Enfin, on peut essayer d&#8217;obtenir un texte potable en remplaçant les caractères spéciaux par leur équivalent ASCII le plus proche.</p>
<p>Avec l&#8217;alphabet latin, c&#8217;est très facile :</p>
<pre lang="python">>>> unicodedata.normalize('NFKD', u"éçûö").encode('ascii', 'ignore')
'ecuo'</pre>
<p>Pour des trucs plus avancés comme le cyrilique ou le mandarin, il faut installer <a href="https://pypi.python.org/pypi/Unidecode">unidecode</a> :</p>
<pre lang="bash">pip install unidecode</pre>
<pre lang="python">>>> from unidecode import unidecode
>>> print unidecode(u"En russe, Moscou s'écrit Москва")
En russe, Moscou s'ecrit Moskva</pre>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/lencoding-en-python-une-bonne-fois-pour-toute/feed/</wfw:commentRss>
		<slash:comments>119</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">5824</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2013/04/OxpEP.jpg" length="87049" type="image/jpg" />	</item>
	</channel>
</rss>
