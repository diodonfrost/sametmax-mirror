<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" >

<channel>
	<title>autobahn &#8211; Sam &amp; Max</title>
	<atom:link href="http://sametmax.com/tag/autobahn/feed/" rel="self" type="application/rss+xml" />
	<link>http://sametmax.com</link>
	<description>Du code, du cul</description>
	<lastBuildDate>Thu, 05 Sep 2019 08:22:03 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.7</generator>
<site xmlns="com-wordpress:feed-additions:1">32490438</site>	<item>
		<title>Pendant ce temps, à Vera Cruz</title>
		<link>http://sametmax.com/pendant-ce-temps-a-vera-cruz/</link>
		<comments>http://sametmax.com/pendant-ce-temps-a-vera-cruz/#comments</comments>
		<pubDate>Sun, 10 May 2015 09:29:24 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[autobahn]]></category>
		<category><![CDATA[crossbar]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[wamp]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=16198</guid>
		<description><![CDATA[Pour une fois, ce n&#8217;est pas un article payé par Tavendo, mais bien un truc que je ponds par enthousiasme :) Pendant qu&#8217;on en parle pas, la stack WAMP continue d&#8217;évoluer, des mises à jours significatives ayant été apportées à Crossbar.io, ainsi qu&#8217;aux libs Python et JS d&#8217;autobahn. Parmi les plus intéressantes : Le code [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>Pour une fois, ce n&#8217;est pas un article payé par Tavendo, mais bien un truc que je ponds par enthousiasme :)</p>
<p>Pendant qu&#8217;on en parle pas, la stack WAMP continue d&#8217;évoluer, des mises à jours significatives ayant été apportées à Crossbar.io, ainsi qu&#8217;aux libs Python et JS d&#8217;autobahn. Parmi les plus intéressantes :</p>
<ul>
<li>Le code passe de la licence Apache 2 à la licence MIT, augmentant la compatibilité avec un tas d&#8217;autres licences.</li>
<li>On peut faire un SUB avec un joker, et donc lier un seul callback à plusieurs événements.</li>
<li>On peut faire un register avec un joker également.</li>
<li>On peut choisir la stratégie à appliquer si plusieurs registers sont faits sur le même nom.</li>
<li>Une meta API permet d&#8217;être prévenu quand un client fait quelque chose ou de demander l&#8217;état des nœuds en cours.</li>
</ul>
<p>Inutile de dire que c&#8217;est trop cool.</p>
<p>Pour profiter de tout ça, il suffit de faire :</p>
<pre lang="bash">pip install crossbar autobahn --upgrade</pre>
<p>Et de télécharger la nouvelle version de la <a href="https://autobahn.s3.amazonaws.com/autobahnjs/latest/autobahn.min.jgz">dernière version</a> de la lib JS.</p>
<h2>Licence MIT</h2>
<p>Auparavant le travail de Tavendo était essentiellement sous Licence Apache. Une licence libre, certes, mais qui pouvait poser problème quand on mélangeait tout ça avec d&#8217;autres licences (par exemple, elle n&#8217;est pas compatible avec la GPL2). Avec la version 0.10, le code est maintenant sous licence MIT, beaucoup plus permissive.</p>
<h2>Joker pour les subs</h2>
<p>Supposez que vous faites un système de jeu d&#8217;échec donc chaque coup déclenche un événement &#8220;chess.game.[id_de_partie]&#8221;. C&#8217;est pratique, car seuls les clients intéressés à cette partie vont recevoir les événements. Mais si votre serveur doit enregistrer un log de tous les coups d&#8217;une partie, il faut que chaque client envoie AUSSI les coups au serveur explicitement.</p>
<p>C&#8217;était en tout cas vrai avant cette mise à jour, puisque maintenant on peut spécifier <a href="http://crossbar.io/docs/Pattern-Based-Subscriptions/">des jokers</a> dans les noms des topics au moment de l&#8217;abonnement.</p>
<p>Essentiellement il y a deux modes.</p>
<p>Le mode &#8220;prefix&#8221;, qui match tous les events qui commencent par ce nom :</p>
<pre lang="javascript">session.subscribe("debut.du.nom.du.topic", callback, { match: "prefix" });
# matchera debut.du.nom.du.topic.genial et debut.du.nom.du.topic.trop.cool</pre>
<p>Et le mode &#8220;wildcard&#8221; qui permet, un peu comme les glob Unix (mais on utilise &#8220;..&#8221; au lieu de &#8220;*&#8221;&#8221;), de faire un texte à trou :</p>
<pre lang="javascript">session.subscribe("nom.du.topic..general", callback, { match: "wildcard" });
# matchera "nom.du.topic.moins.general" et "nom.du.topic.oui.mon.general"</pre>
<p>Tous les callbacks qui matchent un topic seront appelés.</p>
<h2>Plusieurs clients pour la même procédure</h2>
<p>On peut utiliser le même principe que pour les sub avec joker, mais pour les procédures.</p>
<pre lang="javascript">session.register("debut.du.nom.de.la.procedure", callback, { match: "prefix" });    
session.register("nom.de.la.procedure..generale", callback, { match: "wildcard" });</pre>
<p>La différence avec le subscribe, c&#8217;est que seule UNE procédure est appelée. Dans les cas simples, un match exact prend le dessus sur un prefix (et le plus long prefix gagne toujours), qui prend le dessus sur un wildcard. Crossbar n&#8217;implemente pas encore de résolution pour deux wildcards en conflits, et je ne sais pas ce qu&#8217;il fait dans ce cas.</p>
<p>Il est aussi possible de <a href="http://crossbar.io/docs/Shared-Registrations/">de définir des règles</a> d&#8217;appels en faisant :</p>
<pre lang="javascript">session.register("nom.de.la.procedure..generale", procedure1, { invoke: "regle"});</pre>
<p>La règle peut être :</p>
<ul>
<li><strong>roundrobin</strong>: on prend la liste de clients, on regarde le dernier appelé, et on utilise le suivant.</li>
<li><strong>random</strong>: on prend un client au hasard.</li>
<li><strong>last</strong>: on prend le dernier client ajouté de la liste.</li>
<li><strong>first</strong>: on prend premier client ajouté à la liste.</li>
</ul>
<p>&#8220;roundrobin&#8221; et &#8220;random&#8221; sont pratiques pour faire du load balancing.</p>
<p>&#8220;last&#8221; et &#8220;first&#8221; sont pratique pour les mises à jour d&#8217;un client sans arrêter le serveur. En gros on rajoute un client, on attend un peu, &#8220;last&#8221; route tout sur le dernier client, donc le nouveau client prend les requêtes, et on peut arrêter le vieux clients sans souci. </p>
<h2>Meta RPC</h2>
<p>Crossbar met automatiquement à notre disposition des procédures distantes toutes faites qui donnent des informations sur l&#8217;état des clients et du routeur. Voici les RPC que vous pouvez maintenant faire :</p>
<ul>
<li><strong>wamp.session.list</strong>: lister les sessions des clients connectés au routeur.</li>
<li><strong>wamp.session.get</strong>: obtenir les infos d&#8217;un session pour un ID en particulier.</li>
<li><strong>wamp.session.count</strong>: obtenir le nombre de client connectés.</li>
<li><strong>wamp.registration.lookup</strong>: absolument aucune idée.</li>
<li><strong>wamp.registration.get</strong>: obtenir des infos sur une procédure distante enregistrée.</li>
<li><strong>wamp.registration.list_callees</strong>: lister les clients ayant enregistré pour une procédure avec ce nom.</li>
<li><strong>wamp.registration.count_callees</strong>: compter les clients ayant enregistré une procédure avec ce nom.</li>
<li><strong>wamp.registration.list</strong>: lister toutes les procédures distantes disponibles.</li>
<li><strong>wamp.registration.remove_callee</strong>: virer un client de la liste de des clients enregistrés pour cet procédure.</li>
<li><strong>wamp.subscription.lookup</strong>: toujours aucune idée.</li>
<li><strong>wamp.subscription.get</strong>: récupérer des infos sur l&#8217;abonnement avec cet ID.</li>
<li><strong>wamp.subscription.list_subscribers</strong>: lister les clients qui sont abonnés à ce sujet.</li>
<li><strong>wamp.subscription.count_subscribers</strong>: compter les clients abonnés à ce sujet.</li>
<li><strong>wamp.subscription.match</strong>: aucune idée.</li>
<li><strong>wamp.subscription.list</strong>: lister tous les sujets d&#8217;abonnement disponibles.</li>
<li><strong>wamp.subscription.remove_subscriber</strong>: </li>
<p> virer un client de la liste des abonnés à ce sujet.</ul>
<p>En gros, si vous voulez faire une admin qui vous permet de killer certains client ou rechercher si des events existent, vous utilisez ça.</p>
<h2>Meta SUB</h2>
<p>De même, le routeur envoie maintenant des publications sur des sujets concernant le cycle son cycle de vie et celui des clients. On peut donc s&#8217;abonner à ces meta topic pour réagir à l&#8217;activité de son système :</p>
<ul>
<li><strong>wamp.session.on_join</strong> : un client s&#8217;est connecté au routeur.</li>
<li><strong>wamp.session.on_leave</strong> : un client s&#8217;est déconnecté du routeur.</li>
<li><strong>wamp.subscription.on_create</strong> : un nouveau topic existe.</li>
<li><strong>wamp.subscription.on_subscribe</strong> : un client s&#8217;est abonné à un topic.</li>
<li><strong>wamp.subscription.on_unsubscribe</strong> : un client s&#8217;est désabonné à un topic.</li>
<li><strong>wamp.subscription.on_delete</strong> : un topic est retiré de la liste des topics disponibles.</li>
<li><strong>wamp.registration.on_create</strong> : une procédure distante porte ce nom pour la première fois.</li>
<li><strong>wamp.registration.on_register</strong> : un client propose ajoute un callable pour ce nom de procédure distante..</li>
<li><strong>wamp.registration.on_unregister</strong> : un client retire son callable pour ce nom de procédure distante. </li>
<li><strong>wamp.registration.on_delete</strong> : le nom de cette procédure n&#8217;a plus aucun callable lié.</li>
<li><strong>wamp.schema.on_define</strong> : aucune idée.</li>
<li><strong>wamp.schema.on_undefine</strong> : kamolox. </li>
</ul>
<p>Ce genre de truc est idéal pour faire un petit outil de monitoring pour son archi et voir ce qui se passe en temps réel.</p>
<h2>Le HTTP bridge est complet</h2>
<p>Le <a href="http://crossbar.io/docs/HTTP-Bridge-Services/">bridge HTTP</a> propose maintenant PUB/SUB, et tout RPC. On peut donc maintenant utiliser crossbar depuis n&#8217;importe quel app qui peut faire du HTTP : flask, pyramid, ruby on rails, du PHP pur, wget en ligne de commande et tout le bordel. C&#8217;est plus verbeux, mais ça dépanne bien.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/pendant-ce-temps-a-vera-cruz/feed/</wfw:commentRss>
		<slash:comments>8</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">16198</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2015/05/uZyph09.gif" length="677811" type="image/jpg" />	</item>
		<item>
		<title>Un petit dashboard de monitoring avec Django et WAMP</title>
		<link>http://sametmax.com/un-petit-dashboard-de-monitoring-avec-django-et-wamp/</link>
		<comments>http://sametmax.com/un-petit-dashboard-de-monitoring-avec-django-et-wamp/#comments</comments>
		<pubDate>Sat, 07 Feb 2015 10:58:43 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[autobahn]]></category>
		<category><![CDATA[crossbar.io]]></category>
		<category><![CDATA[django]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[wamp]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=15872</guid>
		<description><![CDATA[Crossbar.io vient avec un service "HTTP Pusher" qui permet d'envoyer une requête POST qui va se transformer en véritable publish WAMP.

Histoire d'illustrer tout ça, je vais vous montrer comment construire un petit service de monitoring avec Crossbar.io et Django.]]></description>
				<content:encoded><![CDATA[<p><em>Cet article est écrit dans le cadre de ma <a href="http://sametmax.com/full-disclosure/">collaboration</a> avec Tavendo.</em></p>
<p>On a déjà vu que <a href="http://sametmax.com/crossbar-le-futur-des-applications-web-python/">WAMP c&#8217;est cool</a>, mais c&#8217;est asynchrone et nos frameworks Web chéris WSGI <a href="http://sametmax.com/wamp-et-les-outils-de-dev-web-python-existants/">sont synchrones</a>.</p>
<p>J&#8217;ai donné une solution de contournement avec la lib <a href="http://sametmax.com/les-managers-le-detestent-faites-tourner-wamp-dans-django-avec-cette-astuce-insolite/">crochet</a> qui permet de faire tourner du twisted de manière synchrone dans son projet.</p>
<p>Néanmoins, beaucoup sont, j&#8217;en suis certain, à la recherche d&#8217;un truc plus simple. En effet, le bénéfice le plus immédiat de WAMP sont les notifications en temps réel. Et pour ça, crossbar vient avec le <a href="https://github.com/crossbario/crossbar/wiki/HTTP%20Pusher%20Service">HTTP PUSHER service</a> : quelques lignes de JSON dans le fichier de config de crossbar et zou, on peut publier sur un topic WAMP avec une simple requête POST :</p>
<pre lang="javascript"> "transports": [
    {
       "type": "web",
       "endpoint": {
          "type": "tcp",
          "port": 8080
       },
       "paths": {
          ...
          "notify": {
             "type": "pusher",
             "realm": "realm1",
             "role": "anonymous"
          }
       }
    }
 ]</pre>
<p>Et derrière, pour publier un event sur le sujet &#8220;super_sujet&#8221;, on peut faire :</p>
<pre lang="python">import requets
requests.post("http://ip_du_router/pusher",
                  json={
                      'topic': 'super_sujet'
                      'args': [queques, params, a, passer, si, on veut]
                  })</pre>
<p>Ceci va envoyer une requête POST à un service de crossbar qui va transformer ça en véritable publish WAMP.</p>
<p>Histoire d&#8217;illustrer tout ça, je vais vous montrer comment construire un petit service de monitoring avec Crossbar.io et Django. Pour suivre le tuto vous aurez besoin :</p>
<ul>
<li>De connaissances de base en JS.</li>
<li>De connaître le principe de WAMP.</li>
<li>De savoir installer des bibliothèques Python avec extensions sur votre machine. <a href="https://duckduckgo.com/l/?kh=-1&#038;uddg=http%3A%2F%2Fsametmax.com%2Fvotre-python-aime-les-pip%2F">pip</a> et <a href="http://sametmax.com/les-environnement-virtuels-python-virtualenv-et-virtualenvwrapper">virtualenv</a> sont vos amis.</li>
<li>De connaître Django. Même si le concept peut s&#8217;appliquer à Flask, Pyramid, ou autre.</li>
</ul>
<p><iframe class='youtube-player' type='text/html' width='1170' height='689' src='http://www.youtube.com/embed/e9Xtl22x5Sg?version=3&#038;rel=1&#038;fs=1&#038;autohide=2&#038;showsearch=0&#038;showinfo=1&#038;iv_load_policy=1&#038;wmode=transparent' allowfullscreen='true' style='border:0;'></iframe></p>
<h2>Premiers pas</h2>
<p>Le but du jeu est d&#8217;avoir un petit client WAMP qu&#8217;on lance sur chaque machine qu&#8217;on veut monitorer. Celui-ci va, toutes les x secondes, récupérer l&#8217;usage CPU, RAM et disque et faire un publish WAMP.</p>
<div id="attachment_15876" style="width: 600px" class="wp-caption aligncenter"><a href="http://sametmax.com/wp-content/uploads/2015/02/architecture.png" class="grouped_elements" rel="tc-fancybox-group15872"><img src="http://sametmax.com/wp-content/uploads/2015/02/architecture.png" alt="Chaque machine possède un client WAMP" width="590" height="654" class="size-full wp-image-15876" /></a><p class="wp-caption-text">Chaque machine possède un client WAMP</p></div>
<p>A l&#8217;autre bout, on a un site Django qui a un modèle pour chaque machine monitorée, avec des valeurs pour dire si on est intéressé par le CPU, la RAM ou le disque et la valeur de x.</p>
<p>Une page affiche en temps réel tous les relevés pour toutes les machines. Si dans l&#8217;admin de Django on change un modèle, la page reflète ce changement.</p>
<div id="attachment_15877" style="width: 710px" class="wp-caption aligncenter"><a href="http://sametmax.com/wp-content/uploads/2015/02/dashboard.gif" class="grouped_elements" rel="tc-fancybox-group15872"><img src="http://sametmax.com/wp-content/uploads/2015/02/dashboard.gif" alt="Si je déclique &quot;CPU&quot; dans l&#039;admin Django, les CPUs ne sont plus affichés" width="700" height="650" class="size-full wp-image-15877" /></a><p class="wp-caption-text">Si je déclique &#8220;CPU&#8221; dans l&#8217;admin Django, les CPUs ne sont plus affichés</p></div>
<p> On aura donc besoin de django (<code>pip install Django</code>, ça c&#8217;est pas trop dur), requests (<code>pip install requests</code>, jusqu&#8217;ici tout va bien), et <a href="pythonhosted.org/psutil/">psutil</a>.</p>
<p>psutil est la lib Python qui va nous permettre de récupérer toutes le valeurs pour la RAM, le disque et le CPU. Elle utilise des extensions en C, il faut donc un compilateur et les headers Python. Sous Ubuntu, il faut donc faire :</p>
<pre lang="bash">sudo apt-get install gcc python-dev</pre>
<p>Sous CentOS ça donne :</p>
<pre lang="bash">yum groupinstall "Development tools"
yum install python-devel</pre>
<p>Sous Mac, les headers Python devraient être inclus, mais il vous faut aussi GCC. Si vous avez xcode, vous avez déjà un compilateur, sinon, il existe un installeur <a href="https://github.com/kennethreitz/osx-gcc-installer#readme">plus léger</a>.</p>
<p>Sous windows, c&#8217;est un wheel donc rien à faire normalement.</p>
<p>Et reste plus qu&#8217;à <code>pip install psutil</code>.</p>
<p>Enfin il nous faudra, logique, <a href="http://crossbar.io/docs/Local-Installation/">installer crossbar</a>. <code>pip install crossbar</code>, sachant que <a href="http://crossbar.io/docs/Installation-on-Windows/">sous Windows</a> vous aurez besoin de <a href="http://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/">PyWin32</a> et comme toujours, d&#8217;avoir les dossiers <code>C:\Python27\</code> and <code>C:\Python27\Scripts</code> dans votre <a href="http://sametmax.com/ajouter-un-chemin-a-la-variable-denvironnement-path-sous-windows/">PATH</a>.</p>
<h2>Le HTML</h2>
<p>On a besoin que d&#8217;une page. Afin de rendre le tuto agnostique, je l&#8217;ai fait en pur JS, pas de jQuery, pas d&#8217;Angular. Donc c&#8217;est verbeux :)</p>
<pre lang="html">
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />

    <!-- De quoi cacher un bloc facilement -->
    <style type="text/css">
        .hide {display:none;}
    </style>

    <!--
        La lib JS qui permet de parler WAMP .

        Ici je suppose qu'on utilise un navigateur qui support websocket.
        Il est possible de faire du fallback sur flash ou long poll, mais
        ce sont des dépendances en plus.
    -->
    <script src="https://autobahn.s3.amazonaws.com/autobahnjs/latest/autobahn.min.jgz"
           type="text/javascript"></script>


    <!-- Tout notre code client, inline pour faciliter votre lecture -->
    <script type="text/javascript">

      /* Connexion à notre serveur WAMP */
      window.addEventListener("load", function(){
        var connection = new autobahn.Connection({
           url: 'ws://127.0.0.1:8080/ws',
           realm: 'realm1'
        });

        /* Quand la connexion est ouverte, exécuter ce code */
        connection.onopen = function(session) {

          var clients = document.getElementById("clients");

          /* Quand on reçoit l'événement clientstats, lancer cette fonction */
          session.subscribe('clientstats', function(args){
            var stats = args[0];
            var serverNode = document.getElementById(stats.ip);

            /*
                 Créer un li contenant un h2 et un dl pour ce client si
                 il n'est pas encore dans la page.
            */
            if (!serverNode){
                serverNode = document.createElement("li");
                serverNode.id = stats.ip;
                serverNode.appendChild(document.createElement("h2"));
                serverNode.appendChild(document.createElement("dl"));
                serverNode.firstChild.innerHTML = stats.name + " (" + stats.ip + ")";
                clients.appendChild(serverNode);

                // Cacher les infos du serveur si il est désactivé.
                session.subscribe('clientconfig.' + stats.ip, function(args){
                    var config = args[0];
                    if (config.disabled){
                        var serverNode = document.getElementById(config.ip);
                        serverNode.className = "hide";
                    }
                });

            }

            // Remettre à zéro le contenu du li du serveur.
            serverNode.className = "";
            var dl = serverNode.lastChild;
            while (dl.hasChildNodes()) {
                dl.removeChild(dl.lastChild);
            }

            // Si on a des infos sur le CPU, les afficher
            if (stats.cpus){
                var cpus = document.createElement("dt");
                cpus.innerHTML = "CPUs:";
                dl.appendChild(cpus);
                for (var i = 0; i < stats.cpus.length; i++) {
                    var cpu = document.createElement("dd");
                    cpu.innerHTML = stats.cpus[i];
                    dl.appendChild(cpu);
                };
            }

            // Si on a des infos sur l'espace disque, les afficher
            if (stats.disks){
                var disks = document.createElement("dt");
                disks.innerHTML = "Disk usage:";
                dl.appendChild(disks);
                for (key in stats.disks) {
                    var disk = document.createElement("dd");
                    disk.innerHTML = "<strong>" + key + "</strong>: " + stats.disks[key];
                    dl.appendChild(disk);
                };
            }

            // Si on a des infos sur l'usage mémoire, les afficher.
            if (stats.memory){
                var memory = document.createElement("dt");
                memory.innerHTML = "Memory:";
                dl.appendChild(memory);
                var memVal = document.createElement("dd");
                memVal.innerHTML = stats.memory;
                dl.appendChild(memVal);
            }

          });

        };

        // Ouvrir la connexion avec le routeur WAMP.
        connection.open();

      });
    </script>

    <title> Monitoring</title>
</head>
<body>
    <h1> Monitoring </h1>
    <ul id="clients"></ul>
</body>

</html>
</pre>
<p>Comme vous pouvez le voir, c&#8217;est beaucoup de JS ordinaire et du DOM. Les seules parties spécifiques à WAMP sont :</p>
<pre lang="javascript">var connection = new autobahn.Connection({
           url: 'ws://127.0.0.1:8080/ws',
           realm: 'realm1'
        });
connection.onopen = function(session) {
...
}
connection.open();</pre>
<p>Pour se connecter au serveur.</p>
<p>Et :</p>
<pre lang="javascript">session.subscribe('nom_du_sujet', function(args){
...
}</pre>
<p>Pour réagir à la publication d&#8217;un sujet WAMP.</p>
<h2>Le client de monitoring</h2>
<p>C&#8217;est la partie qui va aller sur chaque machine qu&#8217;on veut surveiller.</p>
<pre lang="python"># -*- coding: utf-8 -*-

from __future__ import division

import socket

import requests
import psutil

from autobahn.twisted.wamp import Application
from autobahn.twisted.util import sleep

from twisted.internet.defer import inlineCallbacks

def to_gib(bytes, factor=2**30, suffix="GiB"):
    """ Converti un nombre d'octets en gibioctets.

        Ex : 1073741824 octets = 1073741824/2**30 = 1GiO
    """
    return "%0.2f%s" % (bytes / factor, suffix)

def get_infos(filters={}):
    """ Retourne la valeur actuelle de l'usage CPU, mémoire et disque.

        Ces valeurs sont retournées sous la forme d'un dictionnaire :

            {
                'cpus': ['x%', 'y%', etc],
                'memory': "z%",
                'disk':{
                    '/partition/1': 'x/y (z%)',
                    '/partition/2': 'x/y (z%)',
                    etc
                }
            }

        Le paramètre filter est un dico de la forme :

            {'cpus': bool, 'memory':bool, 'disk':bool}

        Il est utilisé pour décider d'inclure ou non les résultats des mesures
        pour les 3 types de ressource.

    """

    results = {}

    if (filters.get('show_cpus', True)):
        results['cpus'] = tuple("%s%%" % x for x in psutil.cpu_percent(percpu=True))

    if (filters.get('show_memory', True)):
        memory = psutil.phymem_usage()
        results['memory'] = '{used}/{total} ({percent}%)'.format(
            used=to_gib(memory.active),
            total=to_gib(memory.total),
            percent=memory.percent
        )

    if (filters.get('show_disk', True)):
        disks = {}
        for device in psutil.disk_partitions():
            usage = psutil.disk_usage(device.mountpoint)
            disks[device.mountpoint] = '{used}/{total} ({percent}%)'.format(
                used=to_gib(usage.used),
                total=to_gib(usage.total),
                percent=usage.percent
            )
        results['disks'] = disks

    return results

# On créé le client WAMP.
app = Application('monitoring')

# Ceci est l'IP publique de ma machine puisque
# ce client doit pouvoir accéder à mon serveur
# depuis l'extérieur.
SERVER = '172.17.42.1'

# D'abord on utilise une astuce pour connaître l'IP publique de cette
# machine.
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.connect(("8.8.8.8", 80))
# On attache un dictionnaire à l'app, ainsi
# sa référence sera accessible partout.
app._params = {'name': socket.gethostname(), 'ip': s.getsockname()[0]}
s.close()

@app.signal('onjoined')
@inlineCallbacks
def called_on_joinded():
    """ Boucle envoyant l'état de cette machine avec WAMP toutes les x secondes.

        Cette fonction est exécutée quand le client "joins" le router, c'est
        à dire qu'il est connecté et authentifié, prêt à envoyer des messages
        WAMP.
    """
    # Ensuite on fait une requête post au serveur pour dire qu'on est
    # actif et récupérer les valeurs de configuration de notre client.
    app._params.update(requests.post('http://' + SERVER + ':8080/clients/',
                                    data={'ip': app._params['ip']}).json())


    # Puis on boucle indéfiniment
    while True:
        # Chaque tour de boucle, on récupère les infos de notre machine
        infos = {'ip': app._params['ip'], 'name': app._params['name']}
        infos.update(get_infos(app._params))

        # Si les stats sont a envoyer, on fait une publication WAMP.
        if not app._params['disabled']:
            app.session.publish('clientstats', infos)

        # Et on attend. Grâce à @inlineCallbacks, utiliser yield indique
        # qu'on ne bloque pas ici, donc pendant ce temps notre client
        # peut écouter les événements WAMP et y réagir.
        yield sleep(app._params['frequency'])


# On dit qu'on est intéressé par les événements concernant clientconfig
@app.subscribe('clientconfig.' + app._params['ip'])
def update_configuration(args):
    """ Met à jour la configuration du client quand Django nous le demande. """
    app._params.update(args)

# On démarre notre client.
if __name__ == '__main__':
    app.run(url="ws://%s:8080/ws" % SERVER)</pre>
<p>Le plus gros du code est <code>get_infos()</code> qui n&#8217;a rien à voir avec WAMP. C&#8217;est nous, manipulant <code>psutil</code> pour obtenir les relevés de cette machine. Je ne recommande bien évidement pas de faire ça en prod : une grosse fonction monolithique qui prend un dico en param. Mais c&#8217;est pour une démo, et ça me permet de grouper les instructions qui vont ensemble pour faciliter votre compréhension.</p>
<p>La partie qui concerne WAMP :</p>
<pre lang="python">app = Application('monitoring')

@app.signal('onjoined')
@inlineCallbacks
def called_on_joinded():
    ...

    while True:

        ...
        app.session.publish('clientstats', infos)
        ...
        yield sleep(app._params['frequency'])</pre>
<p><code>app = Application('monitoring')</code> créé un client WAMP, et <code>@app.signal('onjoined')</code> nous dit de lancer la fonction quand notre client est connecté et prêt à envoyer des événements. <code>@inlineCallbacks</code> est une spécificité de Twisted qui nous permet d&#8217;écrire du code asynchrone sans avoir à mettre des callback partout : à la place on met des <code>yield.</code></p>
<p>Tout le boulot de notre client a lieu dans la boucle : <code>app.session.publish('clientstats', infos)</code> publie les nouvelles mesures de CPU/RAM/Disque via WAMP, puis attend un certain temps (<code>yield sleep(app._params['frequency'])</code>) avant de le faire à nouveau. L&#8217;attente n&#8217;est pas bloquante car elle se fait avec le <code>sleep</code> de Twisted.</p>
<p>N&#8217;oublions pas :</p>
<pre lang="python">@app.subscribe('clientconfig.' + app._params['ip'])
def update_configuration(args):
    app._params.update(args)</pre>
<p>La fonction <code>update_configuration()</code> sera appelée à chaque fois qu&#8217;une publication WAMP sera faite sur le sujet <code>clientconfig.&lt;ip_du_client&gt;</code>. Notre fonction ne fait que mettre à jour la configuration du client, qui est un dico de la forme :</p>
<pre lang="python">
    {'cpus': True,
    'memory': False,
    'disk': True,
    'disabled': False,
    'frequency': 1}
</pre>
<p>C&#8217;est ce dico qui est utilisé par <code>get_infos()</code> pour choisir quelles mesures récupérer, et aussi par <code>sleep()</code> pour savoir combien de secondes attendre avant la prochaine mesure.</p>
<p>La valeur initiale de ce dico est récupérée au lancement du client, en faisant :</p>
<pre lang="python">
app._params.update(requests.post('http://' + SERVER + ':8080/clients/',
                                    data={'ip': app._params['ip']}).json())</pre>
<p><code>requests.post(url_du_serveur, data={'ip': app._params['ip']}).json()</code> fait en effet une requête POST vers une URL de django qui nous allons voir plus loin, et qui retourne la configuration du client portant cette IP sous forme de JSON.</p>
<p>On utilise donc une fois HTTP pour obtenir les valeurs de départs, et ensuite WAMP pour les mises à jours des futures valeurs. WAMP et HTTP ne s&#8217;excluent pas : ils sont complémentaires.</p>
<p>Petite parenthèse sur :</p>
<pre lang="python">SERVER = '172.17.42.1'

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.connect(("8.8.8.8", 80))
app._params = {'name': socket.gethostname(), 'ip': s.getsockname()[0]}
s.close()</pre>
<p>D&#8217;une part, j&#8217;ai mis l&#8217;IP du serveur qui va contenir Crossbar.io et Django en dur car je suis, je pense que maintenant vous le savez, une grosse feignasse. Mais en prod, vous me faites un paramètre, on est d&#8217;accord ? Ensuite, il faut que j&#8217;identifie mon client, ce que je fais avec l&#8217;adresse IP. Il me faut donc son adresse IP externe, et je l&#8217;obtiens avec une astuce consistant à me connecter à l&#8217;IP 8.8.8.8 (les DNS google \o/) et en fermant la connexion juste derrière. Ce me permet de voir comment les autres machines me voit depuis l’extérieur.</p>
<h2>Le site Django</h2>
<p>Puisque le prérequis de l&#8217;article et de connaître Django, ça va pas être trop dur.</p>
<p>On créé son projet et son app :</p>
<pre lang="bash">django-admin startproject django_project
./manage.py startapp django_app</pre>
<p>On se rajoute un petit modèle qui contient la configuration de chaque client (vous vous souvenez, le fameux dico) :</p>
<pre lang="python"># -*- coding: utf-8 -*-

import requests

from django.db import models
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.forms.models import model_to_dict


class Client(models.Model):
    """ Configuration de notre client. """

    # Pour l'identifier.
    ip = models.GenericIPAddressField()

    # Quelles données envoyer à notre dashboard
    show_cpus = models.BooleanField(default=True)
    show_memory = models.BooleanField(default=True)
    show_disk = models.BooleanField(default=True)

    # Arrêter d'envoyer les données
    disabled = models.BooleanField(default=False)

    # Fréquence de rafraîchissement des données
    frequency = models.IntegerField(default=1)

    def __unicode__(self):
        return self.ip


@receiver(post_save, sender=Client, dispatch_uid="server_post_save")
def notify_server_config_changed(sender, instance, **kwargs):
    """ Notifie un client que sa configuration a changé.

        Cette fonction est lancée quand on sauvegarde un modèle Client,
        et fait une requête POST sur le bridge WAMP-HTTP, nous permettant
        de faire un publish depuis Django.
    """
    requests.post("http://127.0.0.1:8080/notify",
                  json={
                      'topic': 'clientconfig.' + instance.ip,
                      'args': [model_to_dict(instance)]
                  })</pre>
<p>La partie modèle est connue. L&#8217;astuce est dans :</p>
<pre lang="python">@receiver(post_save, sender=Client, dispatch_uid="server_post_save")
def notify_server_config_changed(sender, instance, **kwargs):
    requests.post("http://127.0.0.1:8080/notify",
                  json={
                      'topic': 'clientconfig.' + instance.ip,
                      'args': [model_to_dict(instance)]
                  })</pre>
<p>On utilise ici les signaux Django, une fonctionnalité du framework qui nous permet de lancer une fonction quand quelque chose se passe. Ici on dit &#8220;lance cette fonction quand le modèle <code>Client</code> est modifié&#8221;.</p>
<p>Donc <code>notify_server_config_changed</code> va se lancer quand la config d&#8217;un client est modifiée, par exemple dans l&#8217;admin, et recevoir l&#8217;objet modifié via son paramètre <code>instance</code>.</p>
<p>On fait alors une petite requête POST sur <code>http://127.0.0.1:8080/notify</code>, l&#8217;URL sur laquelle on configurera plus loin notre service de push. En faisant une requête dessus, on va demander à Crossbar.io de transformer la requête HTTP en message publish WAMP, ici sur le sujet &#8216;clientconfig.&lt;ip_du_client&gt;&#8217;. On publie donc un message WAMP, depuis Django.</p>
<p>Ca marche depuis n&#8217;importe où, pas juste Django. Depuis le shell, depuis Flask, n&#8217;importe où on peut faire une requête HTTP vers le service de push de crossbar.</p>
<p>Ce message va être récupéré par notre client, où qu&#8217;il soit, puisqu&#8217;il est aussi connecté au routeur WAMP. Comme, je vous le rappelle, notre client fait ça :</p>
<pre lang="python">@app.subscribe('clientconfig.' + app._params['ip'])
def update_configuration(args):
    app._params.update(args)</pre>
<p>Il va recevoir ce message, et donc le contenu de <code>'args': [model_to_dict(instance)]</code>, c&#8217;est à dire la nouvelle configuration qu&#8217;on a changé en base de donnée. Il se met ainsi à jour immédiatement. La boucle est bouclée.</p>
<p>Comme on veut profiter de notre boucle toute bouclée, on rajoute le modèle dans l&#8217;admin :</p>
<pre lang="python">from django.contrib import admin

# Register your models here.

from django_app.models import Client

admin.site.register(Client)</pre>
<p>Ainsi, les configs des clients seront éditables dans l&#8217;admin, et quand on cliquera sur &#8220;save&#8221;, ça va lancer notre publish WAMP qui mettra à jour le bon client.</p>
<p>Le reste, c&#8217;est du fignolage. Une petite vue pour créer ou récupérer notre configuration de client au démarrage :</p>
<pre lang="python"># -*- coding: utf-8 -*-

import json

from django.http import HttpResponse
from django_app.models import Client
from django.views.decorators.csrf import csrf_exempt
from django.forms.models import model_to_dict


@csrf_exempt
def clients(request):
    """ Récupère la config d'un client en base de donnée et lui envoie."""
    client, created = Client.objects.get_or_create(ip=request.POST['ip'])
    return HttpResponse(json.dumps(model_to_dict(client)), content_type='application/json')</pre>
<p>On désactive la protection CSRF pour la démo, mais encore une fois, en prod, faites ça proprement, avec une jolie authentification pour protéger la vue, et tout, et tout.</p>
<p>Donc, cette vue récupère la configuration d&#8217;un client avec cette IP (la créant au besoin), et la retourne en JSON. Souvenez-vous, cela permet à notre client de faire :</p>
<pre lang="python">    app._params.update(requests.post('http://' + SERVER + ':8080/clients/',
                                    data={'ip': app._params['ip']}).json())</pre>
<p>Au démarrage et se déclarer dans la base de données, tout en récupérant sa config.</p>
<p>On branche tout ça via <code>urls.py</code> :</p>
<pre lang="python">from django.conf.urls import patterns, include, url
from django.contrib import admin
from django.views.generic import TemplateView

urlpatterns = patterns('',
    url(r'^admin/', include(admin.site.urls)),
    url(r'^clients/', 'django_app.views.clients'),
    url(r'^$', TemplateView.as_view(template_name='dashboard.html')),
)</pre>
<p>L&#8217;admin, notre vue toute fraiche, et de quoi servir le HTML du début de l&#8217;article.</p>
<p>Y plus qu&#8217;à :</p>
<pre lang="bash">./manage.py syncdb</pre>
<h2>Crossbar.io</h2>
<p>Finalement, tout ce qu&#8217;il reste, c&#8217;est notre bon crossbar :</p>
<pre lang="bash">
crossbar init
</pre>
<p>Ceci nous pond le dossier <code>.crossbar</code> dans lequel on a le fichier <code>config.json</code> qu&#8217;on édite pour qu&#8217;il ressemble à ça :</p>
<pre lang="javascript">{
   "workers": [
      {
         "type": "router",
         "realms": [
            {
               "name": "realm1",
               "roles": [
                  {
                     "name": "anonymous",
                     "permissions": [
                        {
                           "uri": "*",
                           "publish": true,
                           "subscribe": true,
                           "call": true,
                           "register": true
                        }
                     ]
                  }
               ]
            }
         ],
         "transports": [
            {
               "type": "web",
               "endpoint": {
                  "type": "tcp",
                  "port": 8080
               },
               "paths": {
                  "/": {
                     "type": "wsgi",
                     "module": "django_project.wsgi",
                     "object": "application"
                  },
                  "ws": {
                     "type": "websocket"
                  },
                  "notify": {
                     "type": "pusher",
                     "realm": "realm1",
                     "role": "anonymous"
                  },
                  "static": {
                     "type": "static",
                     "directory": "../static"
                  }
               }
            }
         ]
      }
   ]
}
</pre>
<p>La partie du haut c&#8217;est un peu l&#8217;équivalent du <code>chmod 777</code> de crossbar :</p>
<pre lang="javascript">         "type": "router",
         "realms": [
            {
               "name": "realm1",
               "roles": [
                  {
                     "name": "anonymous",
                     "permissions": [
                        {
                           "uri": "*",
                           "publish": true,
                           "subscribe": true,
                           "call": true,
                           "register": true
                        }
                     ]
                  }
               ]
            }
         ],</pre>
<p>&#8220;Met moi en place un router avec un accès nommé realm1 qui autorise à tous les anonymes de tout faire&#8221;. Un realm est une notion de sécurité dans Crossbar.io qui permet de cloisonner les clients connectés, nous on va tout mettre sur le même realm, c&#8217;est pour une démo je vous dis.</p>
<p>Ensuite on rajoute les transports pour chaque techno qui nous intéresse. On va tout regrouper sur le port 8080 car Twisted peut écouter en HTTP et Websocket sur le même port :</p>
<pre lang="javascript">
"transports": [
{
   "type": "web",
   "endpoint": {
      "type": "tcp",
      "port": 8080
   },</pre>
<p>A la racine, on sert notre app Django :</p>
<pre lang="javascript">
  "/": {
     "type": "wsgi",
     "module": "django_project.wsgi",
     "object": "application"
  },</pre>
<p>Car oui, crossbar peut servir votre app django en prod. Pas besoin de gunicorn. En fait même pas besoin d&#8217;nginx pour un site simple, car ça tient très bien la charge. On a juste à lui indiquer quelle variable (<code>application</code>) de quel fichier WSGI (<code>django_project/wsgi.py</code>) charger, et il s&#8217;occupe du reste.</p>
<p>Sur &#8216;/ws&#8217;, on écoute en Websocket :</p>
<pre lang="javascript">"ws": {
 "type": "websocket"
},</pre>
<p>WAMP passe par là, et c&#8217;est pour ça que nos clients se connectent en faisant <code>app.run(url="ws://%s:8080/ws" % SERVER)</code> et <code>autobahn.Connection({url: 'ws://127.0.0.1:8080/ws', realm: 'realm1'});</code>.</p>
<p>&#8216;/notify&#8217; va recevoir le bridge WAMP-HTTP :</p>
<pre lang="javascript">
"notify": {
     "type": "pusher",
     "realm": "realm1",
     "role": "anonymous"
  }</pre>
<p>Tous les anonymes du <code>realm1</code> peuvent l&#8217;utiliser. Grâce à ça, on a pu faire depuis notre signal Django :</p>
<pre lang="python">    requests.post("http://127.0.0.1:8080/notify",
                  json={
                      'topic': 'clientconfig.' + instance.ip,
                      'args': [model_to_dict(instance)]
                  })</pre>
<p>Et donc publier un message WAMP, via un POST HTTP.</p>
<p>Enfin, on sert les fichiers statiques Django avec Crossbar (oui, il fait aussi ça :):</p>
<pre lang="javascript">
 "static": {
    "type": "static",
    "directory": "../static"
}</pre>
<p>N&#8217;oubliez pas le de spécifier <code>STATIC_ROOT</code> dans le fichier settings et lancer <code>./manage.py collecstatic</code>.</p>
<p>Tout ça en place, on lance notre routeur :</p>
<pre lang="bash">
export PYTHONPATH=/chemin/vers/votre/project
crossbar start
</pre>
<p>(Remplacer <code>export</code> par <code>set</code> sous Windows></p>
<p>La modification de <code>PYTHONPATH</code> est nécessaire pour que crossbar trouve votre fichier WSGI.</p>
<p>On visite <a href="http:127.0.0.1:8080/">http:127.0.0.1:8080/</a>, qui va charger notre template Django <code>dashboard.html</code>.</p>
<p>Chaque machine qui lance un client via <code>python client.py</code> va déclencher l&#8217;apparition des stats sur notre dashboard, qui seront mises à jour en temps réel.</p>
<p>Si on va sur <a href="http:127.0.0.1:8080/admin/">http:127.0.0.1:8080/admin/</a> et qu&#8217;on change la config d&#8217;un client, notre client s&#8217;adapte, et notre dashboard se met à jour automatiquement.</p>
<h2>Conclusion</h2>
<p>Notre projet ressemble à ceci au final :</p>
<pre>
.
├── client.py
├── .crossbar
│   ├── config.json
├── db.sqlite3
├── django_app
│   ├── admin.py
│   ├── __init__.py
│   ├── models.py
│   ├── templates
│   │   └── dashboard.html
│   └── views.py
├── django_project
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
├── static
└── manage.py

</pre>
<p>Vous pouvez récupérer le code <a href="https://github.com/sametmax/codes-des-articles/tree/master/2015/fevrier/tudo_django_wamp">ici</a>.</p>
<p>Finalement, très peu de code WAMP : un peu dans le JS, un peu dans le client. Et la seule chose qui lie WAMP à Django est la config crossbar qui ajoute le service HTTP PUSHER et notre requête POST dans <code>models.py</code></p>
<p>Cette technique n&#8217;est pas limitée à Django, et fonctionne bien pour toutes techno synchrones qui ne peut pas lancer un client WAMP directement en son sein. Pour le moment, le bridge HTTP-WAMP ne propose que PUB, pas de SUB, de pas de RPC. C&#8217;est déjà assez sympa pour avoir les notifications en temps réel un peu partout, et ça Tobias m&#8217;a dit qu&#8217;il ajoutera les autres actions dans un future proche.</p>
<p>En attendant, vous voyez le deal : on peut mélanger allègrement HTTP, WAMP, Python, JS, Client, Serveur, et monter sa petite architecture comme on le souhaite. Crossbar permet de démarrer du WSGI, mais aussi les clients WAMP sur la même machine et même n&#8217;importe quel process en ligne de commande (par exemple NodeJS) si besoin. C&#8217;est Mac Gyver ce truc.</p>
<p>On aurait pu écrire le client en Python 3 puisqu&#8217;il est sur une autre machine. Et en fait, si on lance Django en dehors de crossbar, aussi la partie Django en Python 3. Le code de crossbar n&#8217;est jamais modifié, on touche juste la configuration JSON.</p>
<p>Personnellement j&#8217;ai lancé plusieurs images <a href="http://sametmax.com/le-deploiement-par-conteneurs-avec-docker/">dockers</a> avec un client dedans à chaque fois, et c&#8217;est vraiment sympas de voir les machines se rajouter sur le dashboard en temps réel. On a une super sensation d&#8217;interactivité quand on change une valeur dans l&#8217;admin et qu&#8217;on voit le dashboard bouger.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/un-petit-dashboard-de-monitoring-avec-django-et-wamp/feed/</wfw:commentRss>
		<slash:comments>16</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">15872</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2015/02/eded53891380c2bb5fd43858688b0554.jpg" length="246633" type="image/jpg" />	</item>
		<item>
		<title>Les managers le détestent : faites tourner WAMP dans Django avec cette astuce insolite</title>
		<link>http://sametmax.com/les-managers-le-detestent-faites-tourner-wamp-dans-django-avec-cette-astuce-insolite/</link>
		<comments>http://sametmax.com/les-managers-le-detestent-faites-tourner-wamp-dans-django-avec-cette-astuce-insolite/#comments</comments>
		<pubDate>Sun, 04 Jan 2015 19:45:07 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[autobahn]]></category>
		<category><![CDATA[crochet]]></category>
		<category><![CDATA[crossbar]]></category>
		<category><![CDATA[django]]></category>
		<category><![CDATA[flask]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[twisted]]></category>
		<category><![CDATA[wamp]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=15665</guid>
		<description><![CDATA[On peut utiliser WAMP, <code>directement</code> dans Django.]]></description>
				<content:encoded><![CDATA[<p>Il existe une lib appelée <a href="https://pypi.python.org/pypi/crochet">crochet</a> qui permet de faire marcher des API de twisted entre deux bouts de code bloquants. Certes, ça ne marche qu&#8217;en 2.7 et c&#8217;est pas hyper performant, mais on peut faire des trucs mignons du genre cette démo qui <a href="https://github.com/tavendo/AutobahnPython/tree/master/examples/twisted/wamp/app/crochet/example1">mélange flask et WAMP</a>.</p>
<p>C&#8217;est du pur Python, pas de process externe à gérer, c&#8217;est presque simple.</p>
<p>Bref, si on veut utiliser WAMP avec une app synchrone comme flask, c&#8217;est un bon moyen de s&#8217;y mettre. On aura jamais des perfs fantastiques, mais on peut pusher vers le browser.</p>
<p>Du coup je me suis demandé si on pouvait faire ça avec Django.</p>
<p>Évidement, ça a été un peu plus compliqué car par défaut <code>runserver</code> lance plusieurs workers et fait un peu de magie avec les threads. Mais après un peu de bidouillage, ça marche !</p>
<p>On peut utiliser WAMP, <code>directement</code> dans Django.</p>
<h2>Suivez le guide</h2>
<p>D&#8217;abord, on installe tout le bouzin (python 2.7, souvenez-vous) :</p>
<pre lang="bash">pip install crossbar crochet django</pre>
<p>Il vous faudra un Django 1.7, le tout dernier, car il possède <a href="https://docs.djangoproject.com/en/dev/ref/applications/#django.apps.AppConfig.ready">une fonctionnalité</a> qui nous permet de lancer du code quand tout le framework est chargé.</p>
<p>Vous vous faites votre projet comme d&#8217;hab, et vous ouvrez le fichier de settings et au lieu de mettre votre app dans <code>INSTALLED_APPS</code>, vous rajoutez ça :</p>
<pre lang="python">INSTALLED_APPS = (
    '...',
    'votreapp.app.VotreAppConfig'
)</pre>
<p>Puis dans le module de votre app, vous créez un fichier app.py, qui va contenir ça:</p>
<pre lang="python"># -*- coding: utf-8 -*-

import crochet

from django.apps import AppConfig

# On charge l'objet contenant la session WAMP définie dans la vue
from votreapp.views import wapp

class VotreAppConfig(AppConfig):
    name = 'votreapp'
    def ready(self):
        # On dit a crochet de faire tourner notre app wamp dans sa popote qui
        # isole le reactor de Twisted
        @crochet.run_in_reactor
        def start_wamp():
           # On démarre la session WAMP en se connectant au serveur
           # publique de test
           wapp.run("wws://demo.crossbar.io/ws", "realm1", start_reactor=False)
        start_wamp()</pre>
<p>On passe à urls.py dans lequel on se rajoute des vues de démo :</p>
<pre lang="python">
    url(r'^ping/', 'votreapp.views.ping'),
    url(r'^$', 'votreapp.views.index')
</pre>
<p>Puis dans notre fichier views.py, on met :</p>
<pre lang="python">
# -*- coding: utf-8 -*-

import uuid

from django.shortcuts import render

import crochet

# Crochet se démerde pour faire tourner le reactor twisted de
# manière invisible. A lancer avant d'importer autobahn
crochet.setup()

from autobahn.twisted.wamp import Application

# un objet qui contient une session WAMP
wapp = Application()

# On enrobe les primitives de WAMP pour les rendre synchrones
@crochet.wait_for(timeout=1)
def publish(topic, *args, **kwargs):
   return wapp.session.publish(topic, *args, **kwargs)

@crochet.wait_for(timeout=1)
def call(name, *args, **kwargs):
   return wapp.session.call(name, *args, **kwargs)

def register(name, *args, **kwargs):
    @crochet.run_in_reactor
    def decorator(func):
        wapp.register(name, *args, **kwargs)(func)
    return decorator

def subscribe(name, *args, **kwargs):
    @crochet.run_in_reactor
    def decorator(func):
        wapp.subscribe(name, *args, **kwargs)(func)
    return decorator

# Et hop, on peut utiliser nos outils WAMP !

@register('uuid')
def get_uuid():
    return uuid.uuid4().hex

@subscribe('ping')
def onping():
    with open('test', 'w') as f:
        f.write('ping')

# Et à côté, quelques vues django normales

def index(request):
    # pub et RPC en action côté Python
    publish('ping')
    print call('uuid')

    with open('test') as f:
        print(f.read())
    return render(request, 'index.html')

def ping(request):
    return render(request, 'ping.html')
</pre>
<p>Après, un peu de templating pour que ça marche&#8230;</p>
<p>Index.html :</p>
<pre lang="html">
{% load staticfiles %}
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>
       UUID
    </title>

    <script src="{% static 'autobahn.min.js' %}"></script>
    <script type="text/javascript">
      var connection = new autobahn.Connection({
         url: "ws://localhost:8080/ws",
         realm: "realm1"
      });

     connection.onopen = function (session) {

        session.call("uuid").then(function (uuid) {
          var p = document.getElementById('uuid');
          p.innerHTML = uuid;
        });
     };

     connection.open();
    </script>
</head>
<body>
<h2>UUID</h2>
<p id="uuid"></p>
</body>
</html></pre>
<p>ping.html :</p>
<pre lang="python">{% load staticfiles %}
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>
       Ping
    </title>

    <script src="{% static 'autobahn.min.js' %}"></script>
    <script type="text/javascript">
      var connection = new autobahn.Connection({
         url: "ws://localhost:8080/ws",
         realm: "realm1"
      });

     connection.onopen = function (session) {

        session.subscribe("ping", function () {
          var ul = document.getElementById('ping');
          var li = document.createElement('li');
          li.innerHTML = 'Ping !'
          ul.appendChild(li);
        });
     };

     connection.open();
    </script>
</head>
<body>
<h2>Ping me !</h2>

<ul id="ping">
</ul>
</body>
</html></pre>
<p>On ouvre la console, on lance son routeur :</p>
<pre lang="bash">
    crossbar init
    crossbar start</pre>
<p>On lance dans une autre console son serveur Django :</p>
<pre lang="bash">./manage.py runserver</pre>
<p>Et si on navigue sur <code>http://127.0.0.1:8000</code>, on récupère un UUID tout frais via RCP.</p>
<p>On peut aussi voir dans le shell que ça marche côté Python :</p>
<pre>94cfccf0899d4c42950788fa655b65ed
ping</pre>
<p>D’ailleurs un fichier nommé &#8220;test&#8221; est créé à la racine du projet.</p>
<p>Et si on navigue sur <code>http://127.0.0.1:8000/ping/</code> et qu&#8217;on refresh <code>http://127.0.0.1:8000</code> plusieurs fois, on voit la page se mettre à jour.</p>
<p>Achievement unlock : use WAMP and Django code in the same file.</p>
<h2>A partir de là</h2>
<p>Il y a plein de choses à faire.</p>
<p>On pourrait faire une lib qui wrap tout ça pour pas à avoir à le mettre dans son fichier de vue et qui utilise settings.py pour la configuration.</p>
<p>Il faut tester ça avec des setups plus gros pour voir comment ça se comporte avec gunicorn, plusieurs workers, le logging de Django, etc. Je suis à peu près sûr que les callbacks vont être registrés plusieurs fois et ça devrait faire des erreurs dans les logs (rien de grave ceci dit).</p>
<p>On pourrait aussi adapter le RPC pour qu&#8217;il utilise les cookies d&#8217;authentification Django, et pouvoir les protéger avec @login_required.</p>
<p>Mais un monde d&#8217;opportunités s&#8217;offrent à vous à partir de là.</p>
<p>Moi, ça fait 6 h que je taffe dessus, je vais me pieuter.</p>
<hr>
<p><a href="https://github.com/sametmax/codes-des-articles/tree/master/2015/janvier/wamp_et_django">Télécharger le code de l&#8217;article</a></p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/les-managers-le-detestent-faites-tourner-wamp-dans-django-avec-cette-astuce-insolite/feed/</wfw:commentRss>
		<slash:comments>16</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">15665</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2015/01/index.jpeg" length="10867" type="image/jpg" />	</item>
		<item>
		<title>Présentation de WAMP.ws, round 2</title>
		<link>http://sametmax.com/presentation-de-wamp-round-2/</link>
		<comments>http://sametmax.com/presentation-de-wamp-round-2/#comments</comments>
		<pubDate>Sun, 21 Dec 2014 01:46:55 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[autobahn]]></category>
		<category><![CDATA[crossbar.io]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[wamp.ws]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=12969</guid>
		<description><![CDATA[Dans le cadre de <a href="http://sametmax.com/full-disclosure/">mon travail sur WAMP</a>, j'ai proposé à Tobias de commencer par une présentation générale de la stack techno sous forme de slide show. 

L'idée est de mettre à ça dans le header des sites de WAMP, crossbar.io et autobahn, afin que quand les gens arrivent dessus ils puissent rapidement voir de quoi on parle. Ou alors, si on est sur un forum, on peut linker vers les diapos pour donner un contexte.]]></description>
				<content:encoded><![CDATA[<p>Dans le cadre de <a href="http://sametmax.com/full-disclosure/">mon travail sur WAMP</a>, j&#8217;ai proposé à Tobias de commencer par une présentation générale de la stack techno sous forme de slide show.</p>
<p>L&#8217;idée est de mettre ça dans le header des sites de WAMP, crossbar.io et autobahn, afin que quand les gens arrivent dessus ils puissent rapidement voir de quoi on parle. Ou alors, si on est sur un forum, on peut linker vers les diapos pour donner un contexte.</p>
<p><iframe src="https://www.slideshare.net/slideshow/embed_code/42901476" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> </p>
<div style="margin-bottom:5px"> <strong> <a href="https://www.slideshare.net/sametmax/introduction-wampws-le-protocole-websocket-pour-faire-du-pubsub-et-rpc-over-websocket-en-tempr" title="Présentation de WAMP.ws, le protocole pour faire du PUB/SUB et RPC over Websocket" target="_blank">Présentation de WAMP.ws, le protocole pour faire du PUB/SUB et RPC over Websocket</a> </strong> from <strong><a href="http://www.slideshare.net/sametmax" target="_blank">sametmax</a></strong> </div>
<p>Comme prévu, je fais une première version en français que je poste ici. Puis je vais récolter vos commentaires : qu&#8217;est-ce qu&#8217;on comprend pas, quelles informations manquent, qu&#8217;est-ce qui est flou, ambigüe, etc.</p>
<p>Ensuite je l&#8217;améliorerai lors de la traduction en anglais qui sera ensuite proposée à Tavendo.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/presentation-de-wamp-round-2/feed/</wfw:commentRss>
		<slash:comments>39</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">12969</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2014/12/a-few-words-about-wamp-1-638.jpg" length="24593" type="image/jpg" />	</item>
		<item>
		<title>Full disclosure</title>
		<link>http://sametmax.com/full-disclosure/</link>
		<comments>http://sametmax.com/full-disclosure/#comments</comments>
		<pubDate>Tue, 16 Dec 2014 15:32:26 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Philo et culture]]></category>
		<category><![CDATA[autobahn]]></category>
		<category><![CDATA[crossbar]]></category>
		<category><![CDATA[evangelism]]></category>
		<category><![CDATA[meta]]></category>
		<category><![CDATA[wamp]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=12883</guid>
		<description><![CDATA[On m'a contacté pour me demander si je n'étais pas chaud pour faire de l'évangélisme, rémunéré, autour de WAMP, Autobahn et Crossbar.]]></description>
				<content:encoded><![CDATA[<p>Depuis quelques jours je suis en discussion avec Tobias de Tavendo. Comme vous avez pu le remarquer avec mes précédents articles sur <a href="http://sametmax.com/crossbar-le-futur-des-applications-web-python/">WAMP</a> et <a href="http://sametmax.com/le-potentiel-de-wamp-autobahn-et-crossbar-io/">Crossbar</a> :</p>
<ul>
<li>Ils sont bons techniquement, et nuls pour expliquer ce qu&#8217;ils ont techniqué.</li>
<li>Cette techno est une techno de rêve pour moi. J&#8217;y crois à mort.</li>
<li>Je suis le seul à avoir pondu des explications décentes sur WAMP et Crossbar. Et ça n&#8217;a pas suffit à faire battre un cil.</li>
</ul>
<p>Bref, ils ont embauché des mecs de haute voltige pour la technique (du genre un contributeur PyPy). Et ils m&#8217;ont contacté pour me demander si je n&#8217;étais pas chaud pour faire de l&#8217;évangélisme, rémunéré, autour de WAMP, Autobahn et Crossbar.</p>
<p>L&#8217;idée : écrire des tutos, des articles, améliorer la doc, répondre sur le chan IRC, etc.</p>
<p>J&#8217;adore le concept, vu que j&#8217;aime leur projet et que je le faisais gratos avant, surtout qu&#8217;ils sont pas trop contraignants sur le temps que je vais passer dessus.</p>
<p>Donc voilà le deal : quand je vais pondre des tutos et des articles sur WAMP et Co, je vais d&#8217;abord les faire en français ici. Comme ça j&#8217;aurai les retours des lecteurs du blog qui pourront, comme d&#8217;habitude, me faire part de leurs douces remarques sur à quel point on ne pige rien.</p>
<p>Une fois la prose aiguisée, je traduis et je publie chez Tavendo.</p>
<p>Je disclose donc ici que vous verrez peut-être des prochaines rédactions qui seront attachées à une activité pro. Pas impartial donc. Mais bon, depuis quand je suis impartial ? Javascript c&#8217;est de la merde, et je préfère les rousses.</p>
<p>Par saucisse d&#8217;honnêteté, je signalerai chaque choucroute concernée avec un lien vers ce post.</p>
<p>Enfin, le contrat est pas signé encore, mais vu que je vais commencer à taffer dessus aujourd&#8217;hui, je pense à une première publication demain sous la forme d&#8217;un slide show expliquant avec de jolies diapos ce que sont WAMP, Autobahn et Crossbar. À quoi ça sert et ce qu&#8217;on peut faire avec.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/full-disclosure/feed/</wfw:commentRss>
		<slash:comments>28</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">12883</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2014/12/0vC5kst.jpg" length="194264" type="image/jpg" />	</item>
		<item>
		<title>Petite démo pragmatique d&#8217;un usage de WAMP en Python</title>
		<link>http://sametmax.com/introduction-a-wamp-en-python/</link>
		<comments>http://sametmax.com/introduction-a-wamp-en-python/#comments</comments>
		<pubDate>Thu, 26 Jun 2014 07:27:03 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[autobahn]]></category>
		<category><![CDATA[crossbar]]></category>
		<category><![CDATA[javascript]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[wamp]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=11146</guid>
		<description><![CDATA[Vu que dernièrement je vous ai bien gavé avec WAMP, ça mérite un tuto non ?]]></description>
				<content:encoded><![CDATA[<p><em>L&#8217;API a changé depuis, j&#8217;ai donc mis à jour l&#8217;article pour refléter ces changements</em></p>
<p>Vu que dernièrement je vous ai bien gavé avec <a href="http://sametmax.com/crossbar-le-futur-des-applications-web-python/">WAMP</a>, ça mérite un tuto non ?</p>
<p>Il se trouve que l&#8217;équipe derrière WAMP a publié plus tôt que prévu une version de leurs libs contenant l&#8217;API flaskesque sur laquelle on bosse. L&#8217;idée est que même si on n&#8217;a pas encore les tests unitaires, on peut déjà jouer avec.</p>
<p>Maintenant il me fallait un projet sexy, histoire de donner envie. Donc j&#8217;ai fouillé dans ce qui se faisait côté temps réel (essentiellement du NodeJS et du Tornado, mais pas que) pour trouver l&#8217;inspiration.</p>
<p>Et j&#8217;ai trouvé un truc très sympa : <a href="http://news.softpedia.com/news/YouTube-Will-Turn-Your-Phone-into-a-Smart-TV-Remote-318286.shtml">un player vidéo piloté à distance.</a></p>
<p>En effet, n&#8217;est-il pas chiant de regarder une vidéo en ligne sur son ordi posé sur la commode pendant qu&#8217;on est enfoncé dans le canap ? Si on veut faire pause ou changer le son, il faut se lever, arg.</p>
<p>Les problèmes du tiers monde, c&#8217;est du pipi de chat à côté. Ils ont de la chance, eux, ils ne connaissent pas le streaming.</p>
<p><strong>Voici donc le projet : </strong></p>
<p>Une page avec un player HTML 5 et un QR code.</p>
<div id="attachment_11151" style="width: 335px" class="wp-caption aligncenter"><a href="http://sametmax.com/wp-content/uploads/2014/06/video.png" class="grouped_elements" rel="tc-fancybox-group11146"><img class="size-full wp-image-11151" title="Pour simplifier la démo, on peut cliquer sur le QR code est avoir la télécommande dans un autre tab pour ceux qui n'ont pas de smartphone ou d'app de scan de QRCode." src="http://sametmax.com/wp-content/uploads/2014/06/video.png" alt="Capture d'écran de la démo, côté player" width="325" height="186" /></a><p class="wp-caption-text">Pour simplifier la démo, on peut cliquer sur le QR code et avoir la télécommande dans un autre tab pour ceux qui n&#8217;ont pas de smartphone ou d&#8217;app de scan de QRCode.</p></div>
<p>Si on scanne le QR code avec son téléphone, il vous envoie sur une page avec une télécommande pour contrôler le player sans bouger votre cul :</p>
<div id="attachment_11152" style="width: 306px" class="wp-caption aligncenter"><a href="http://sametmax.com/wp-content/uploads/2014/06/controles.png" class="grouped_elements" rel="tc-fancybox-group11146"><img class="size-full wp-image-11152" title="Évidement, c'est basique. Je vais pas m'amuser à faire un produit complet juste pour un truc dont le code source ne sera même pas regardé par la plupart d'entre vous. Je vous connais, bandes de feignasses !" src="http://sametmax.com/wp-content/uploads/2014/06/controles.png" alt="Capture d'écrand de la démo, côté contrôles" width="296" height="370" /></a><p class="wp-caption-text">Évidement, c&#8217;est basique. Je vais pas m&#8217;amuser à faire un produit complet juste pour un truc dont le code source ne sera même pas regardé par la plupart d&#8217;entre vous. Je vous connais, bandes de feignasses !</p></div>
<p>Et vous allez voir, c&#8217;est même pas dur à faire.</p>
<p>Démo en ligne:</p>
<p style="margin: 1em; text-align: center;"><a style="font-size: 2em;" href="https://demo.crossbar.io/videocontrol/">La démo</a></p>
<p><a href="https://github.com/sametmax/codes-des-articles/tree/master/2014/juin/video_remote">Vous pouvez télécharger le code ici</a>.</p>
<p>Pour comprendre ce qui va suivre, il va vous falloir les bases en prog Javascript et Python, ainsi que bien comprendre la notion de <a href="http://sametmax.com/quest-ce-quun-callback/">callback</a>. Être à l&#8217;aise avec <a href="http://sametmax.com/deferred-future-et-promise-le-pourquoi-le-comment-et-quand-est-ce-quon-mange">promises</a> peut aider.</p>
<p>Et pour bien digérer ce paté, rien ne vaut un peu de son :</p>
<p><iframe class='youtube-player' type='text/html' width='1170' height='689' src='http://www.youtube.com/embed/FU4cnelEdi4?version=3&#038;rel=1&#038;fs=1&#038;autohide=2&#038;showsearch=0&#038;showinfo=1&#038;iv_load_policy=1&#038;wmode=transparent' allowfullscreen='true' style='border:0;'></iframe></p>
<h2>Le Chteumeuleu</h2>
<p>Il va nous falloir deux pages Web, une pour le player vidéo, et une pour la télécommande.</p>
<p>Le player :</p>
<pre lang="html">

<!DOCTYPE html>
<html>
<head>
   <title>Video</title>
   <meta charset='utf-8'>
   <!-- Chargement des dépendances : autobahn pour WAMP
   et qrcode pour générer le QR code. Bien entendu, je
   vous invite à ne pas les hotlinker dans vos projets,
   mais pour la démo c'est plus simple. -->
   <script src="https://autobahn.s3.amazonaws.com/autobahnjs/latest/autobahn.min.jgz"
           type="text/javascript"></script>
   <script src="http://davidshimjs.github.com/qrcodejs/qrcode.min.js"
           type="text/javascript"></script>

   <style type="text/css">
      #vid {
         /* Taille de la video */
         width:427px;
         height:240px;
      }
      /* Centrage avec la méthode Rache */
      #container {
          width:427px;
          margin:auto;
      }
      #ctrllink {
          display:block;
          width:256px;
          margin:auto;
      }
   </style>

</head>
<body>
<div id="container">
  <p>

   <!-- Pareil, je hotlink la video, mais ne faites pas ça
   à la maison les enfants. Surtout que les perfs du
   serveur du W3C sont merdiques et ça bufferise à mort. -->
    <video id="vid"
           class="video-js vjs-default-skin"
           controls preload="auto"
           poster="http://media.w3.org/2010/05/sintel/poster.png" >
    <source id='ogv'
      src="http://media.w3.org/2010/05/sintel/trailer.ogv"
      type='video/ogg'>
    <source id='mp4'
      src="http://media.w3.org/2010/05/sintel/trailer.mp4"
      type='video/mp4'>
    <source id='webm'
      src="http://media.w3.org/2010/05/sintel/trailer.webm"
      type='video/webm'>
    </video>
  </p>
  <p>
    <a id="ctrllink" href="#" target="_blank">
      <span id="qrcode"></span>
    </a>
  </p>
 </div>

</body>
</pre>
<p>Et la télécommande :</p>
<pre lang="html">

<!DOCTYPE html>
<html>
<head>
  <title>Télécommande</title>
  <meta charset='utf-8'>
  <script src="https://autobahn.s3.amazonaws.com/autobahnjs/latest/autobahn.min.jgz"
         type="text/javascript"></script>
  <!-- Zoom du viewport sur mobile pour éviter d'avoir
       à le faire à la main. -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style type="text/css">
    #controls {
      width:350px;
      margin:auto;
    }
    #controls button {
      font-size: 1em;
    }
    #controls input {
      vertical-align:middle;
       width: 200px;
       height:20px;
   }
  </style>
</head>
<body>
  <p id="controls">
    <!-- Marrant de se dire qu'en 2000, le JS inline était
         considéré comme démoniaque, et maintenant avec
         angularjs et cie, c'est exactement ce que tout
         le monde fait...
         Bref, on attache le clic sur nos contrôles à des
         méthodes de notre objet qui va se charger de la
         logique. -->

    <button id="play" onclick="control.togglePlay()">Play</button>
    <input id="volume"
                    onchange="control.volume(this.value)"
                    type="range">
  </p>
</body>
</pre>
<p>Rien d&#8217;incroyable. C&#8217;est du HTML, un peu de CSS, on charge les dépendances en JS. Classique.</p>
<p>Vu qu&#8217;on utilise des ressources hotlinkées par souci de simplicité, <strong>il vous faudra être connecté à Internet.</strong></p>
<h2>Setup du routeur</h2>
<p>On va travailler avec Python 2.7 puisque Crossbar.io est uniquement en 2.7 et que je n&#8217;ai pas envie de vous faire installer deux versions de Python juste pour le tuto.</p>
<p>Il nous faut avant tout un serveur HTTP pour servir les fichiers HTML et un routeur WAMP. On installe donc Crossbar.io :</p>
<pre lang="bash">pip install crossbar</pre>
<p>Ca va aussi installer autobahn, twisted et tout le bordel.</p>
<p>On va ensuite dans le dossier qui contient ses fichiers HTML, et on créé le fichier de config de Crossbar.io avec un petit :</p>
<pre lang="bash">crossbar init</pre>
<p>Vous noterez la création d&#8217;un dossier <code>.crossbar</code> qui contient un fichier <code>config.json</code>. C&#8217;est la config de crossbar. <strong>Videz moi ce fichier</strong>, on va le remplir avec notre config :</p>
<pre lang="javascript">
{
   "workers": [
      {
         "type": "router",
         "realms": [
            {
               "name": "realm1",
               "roles": [
                  {
                     "name": "anonymous",
                     "permissions": [
                        {
                           "uri": "*",
                           "publish": true,
                           "subscribe": true,
                           "call": true,
                           "register": true
                        }
                     ]
                  }
               ]
            }
         ],
         "transports": [
            {
               "type": "web",
               "endpoint": {
                  "type": "tcp",
                  "port": 8080,
                  "interface": "0.0.0.0"
               },
               "paths": {
                  "/": {
                     "type": "static",
                     "directory": ".."
                  },
                  "ws": {
                     "type": "websocket",
                  }
               }
            }
         ]
      }
   ]
}
</pre>
<p>Crossbar est en effet un gestionnaire de processus : il ne gère vraiment rien lui même. Il démarre d&#8217;autres processus, appelés workers, à qui il délègue le travail. </p>
<p>On définit dans ce fichier de config quels processus (les workers) lancer quand Crossbar.io démarre. Les valeurs qu&#8217;on utilise disent de créer un seul worker de type &#8220;router&#8221;, c&#8217;est à dire un worker capable de gérer les entrées et les sorties WAMP. Hey oui, le routeur n&#8217;est qu&#8217;un worker comme les autres :)</p>
<p>Il y a d&#8217;autres sortes de workers, mais aujourd&#8217;hui on s&#8217;en branle.</p>
<p>Dans notre config du worker router, on crée d&#8217;abord un realm, qui est juste un namespace avec des permissions. Si un client WAMP se connecte à ce routeur, il doit choisir un realm (qui est juste un nom), et il ne peut parler qu&#8217;avec les clients du même realm. C&#8217;est une cloture quoi.</p>
<p>Dans un realm, on définit des roles qui déclarent quelles opérations PUB/SUB et RPC on a le droit de faire. Ici on dit que tout le monde (anonymous) a le droit de tout faire sur toutes les urls (&#8220;uri&#8221;:  &#8216;*&#8221;) histoire de pas se faire chier. Si on met en prod, évidement on va se pencher sur la sécurité et faire ça plus proprement.</p>
<pre lang="javascript">
"realms": [
{
   "name": "realm1",
   "roles": [
      {
         "name": "anonymous",
         "permissions": [
            {
               "uri": "*",
               "publish": true,
               "subscribe": true,
               "call": true,
               "register": true
            }
         ]
      }
   ]
}
],</pre>
<p>Puis on définit les transports, c&#8217;est à dire sur quoi notre worker va ouvrir ses oreilles pour écouter les messages entrant :</p>
<pre lang="javascript">"transports": [
            {
               "type": "web",
               "endpoint": {
                  "type": "tcp",
                  "port": 8080,
                  "interface": "0.0.0.0"
               },
               "paths": {
                  "/": {
                     "type": "static",
                     "directory": ".."
                  },
                  "ws": {
                     "type": "websocket",
                  }
               }
            }
        ]
</pre>
<p>Encore une fois on en déclare un seul, de type &#8220;web&#8221;. Ce transport peut écouter HTTP et Websocket sur le même port. On lui dit d&#8217;écouter sur &#8220;0.0.0.0:8080&#8221; :</p>
<p><lang="javascript"><br />
&#8220;endpoint&#8221;: {<br />
  &#8220;type&#8221;: &#8220;tcp&#8221;,<br />
  &#8220;port&#8221;: 8080,<br />
  &#8220;interface&#8221;: &#8220;0.0.0.0&#8221;<br />
},</lang></p>
<p>Ensuite on dit que si quelqu&#8217;un arrive sur &#8220;/&#8221;, on sert en HTTP les fichiers statiques histoire que nos pages Web soient servies :</p>
<pre lang="javascript">"/": {
 "type": "static",
 "directory": ".."
},</pre>
<p>Si on arrive sur &#8220;/ws&#8221;, on route les requêtes WAMP via Websocket :</p>
<pre lang="javascript">"ws": {
 "type": "websocket",
}</pre>
<p>Le routeur est prêt, on lance Crossbar.io :</p>
<pre lang="bash">
$ crossbar start
2015-01-07 20:02:55+0700 [Controller  26914] Log opened.
2015-01-07 20:02:55+0700 [Controller  26914] ============================== Crossbar.io ==============================
    
2015-01-07 20:02:55+0700 [Controller  26914] Crossbar.io 0.9.12-2 starting
2015-01-07 20:02:55+0700 [Controller  26914] Running on CPython using EPollReactor reactor
2015-01-07 20:02:55+0700 [Controller  26914] Starting from node directory /home/sam/Work/sametmax/code_des_articles/2014/juin/video_remote/.crossbar
2015-01-07 20:02:55+0700 [Controller  26914] Starting from local configuration '/home/sam/Work/sametmax/code_des_articles/2014/juin/video_remote/.crossbar/config.json'
2015-01-07 20:02:55+0700 [Controller  26914] Warning, could not set process title (setproctitle not installed)
2015-01-07 20:02:55+0700 [Controller  26914] Warning: process utilities not available
2015-01-07 20:02:55+0700 [Controller  26914] No WAMPlets detected in enviroment.
2015-01-07 20:02:55+0700 [Controller  26914] Starting Router with ID 'worker1' ..
2015-01-07 20:02:55+0700 [Controller  26914] Entering reactor event loop ...
2015-01-07 20:02:55+0700 [Router      26917] Log opened.
2015-01-07 20:02:55+0700 [Router      26917] Warning: could not set worker process title (setproctitle not installed)
2015-01-07 20:02:55+0700 [Router      26917] Running under CPython using EPollReactor reactor
2015-01-07 20:02:56+0700 [Router      26917] Entering event loop ..
2015-01-07 20:02:56+0700 [Router      26917] Warning: process utilities not available
2015-01-07 20:02:56+0700 [Controller  26914] Router with ID 'worker1' and PID 26917 started
2015-01-07 20:02:56+0700 [Controller  26914] Router 'worker1': realm 'realm1' started
2015-01-07 20:02:56+0700 [Controller  26914] Router 'worker1': role 'role1' started on realm 'realm1'
2015-01-07 20:02:56+0700 [Router      26917] Site starting on 8080
2015-01-07 20:02:56+0700 [Controller  26914] Router 'worker1': transport 'transport1' started
</pre>
<h2>Setup du client</h2>
<p>Pour cette démo, le serveur n&#8217;a pas grand chose à faire. On pourrait en fait la faire sans aucun code Python, mais ça va nous simplifier la vie et donner un peut de grain à moudre pour le tuto.</p>
<p>En effet, on a deux problématiques que le serveur va résoudre facilement pour nous : <strong>créer un ID unique pour le player et récupérer l&#8217;IP sur le réseau local.</strong></p>
<p>L&#8217;ID, c&#8217;est simplement que si plusieurs personnes lancent en même temps un player, on ne veut pas que les télécommandes puissent lancer un ordre à un autre player que le sien. On pourrait utiliser un timestamp, mais ils sont contigus, n&#8217;importe quel script kiddies pourrait faire un script pour foutre la merde. On va donc créer un ID unique qui ne soit pas facilement prévisible. Javascript n&#8217;a rien pour faire ça en natif, et c&#8217;est un peu con de charger une lib de plus pour ça alors que Python peut le faire pour nous.</p>
<p>L&#8217;IP, c&#8217;est parce qu&#8217;il faut donner l&#8217;adresse de notre machine contient notre routeur. Et le téléphone qui sert de télécommande doit se connecter à ce routeur. Il faut donc qu&#8217;il connaisse l&#8217;adresse de celui-ci, donc on va la mettre dans notre QR code.</p>
<p>Cela veut dire aussi que le téléphone doit être sur le même réseau local pour que ça fonctionne. <strong>Donc mettez votre téléphone en Wifi, pas en 3G.</strong></p>
<p>Voilà ce que donne notre code WAMP côté serveur :</p>
<pre lang="python"># -*- coding: utf-8 -*-

from autobahn.twisted.wamp import Application

import socket
import uuid

# Comme pour flask, l'objet app
# est ce qui lie tous les éléments
# de notre code ensemble. On lui donne
# un nom, ici "demo"
app = Application('demo')
# Bien que l'app va démarrer un serveur
# pour nous, l'app est bien un CLIENT
# du serveur WAMP. Le serveur démarré
# automatiquement n'est qu'une facilité
# pour le dev. En prod on utiliserait
# crossbar.

# Juste un conteneur pour y mettre notre IP
app._data = {}

# On déclare que cette fonction sera appelée
# quand l'app se sera connectée au serveur WAMP.
# Ceci permet de lancer du code juste après
# le app.run() que l'on voit en bas du fichier.
# '_' est une convention en Python pour dire
# "ce nom n'a aucune importance, c'est du code
# jetable qu'on utilisera une seule fois".
@app.signal('onjoined')
def _():
   # On récupère notre adresse IP sur le réseau local
   # C'est une astuce qui demande de se connecter et donc
   #  à une IP externe, on a besoin d'une connexion internet.
   s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
   s.connect(("8.8.8.8", 80))
   # On stocke l'adresse IP locale dans un conteneur
   # qui sera accessible partout ailleur.
   app._data['LOCAL_IP'] = s.getsockname()[0]
   s.close()

# On déclare que la fonction "ip()" est appelable
# via RCP. Ce qui veut dire que tout autre client
# WAMP peut obtenir le résultat de cette fonction.
# Donc on va pouvoir l'appeler depuis notre navigateur.
# Comme notre app s'appelle "demo" et notre fonction
# s'appelle "ip", un client pourra l'appeler en faisant
# "demo.ip".
@app.register()
def ip():
   # On ne fait que retourner l'IP locale. Rien de fou.
   return app._data['LOCAL_IP']

# Je voulais appeler cette fonction distante "uuid", mais ça
# override le module Python uuid. Ce n'est pas une bonne
# idée. Je l'appelle donc 'get_uuid' mais je déclare le
# namespace complet dans register(). Un client WAMP pourra donc
# bien l'appeler via "demo.uuid".
# Notez que ce namespace doit toujours s'écrire
# truc.machine.bidule. Pas truc/machin ou truc:machin.
# ou truc et bidule.MACHIN.
@app.register('demo.uuid')
def get_uuid():
   # Retourne un UUID, sans les tirets.
   # ex: b27f7e9360c04efabfae5ac21a8f4e3c
   return str(uuid.uuid4()).replace('-', '')

# On lance notre client qui va se connecter au
# routeur.
if __name__ == '__main__':
    app.run(url="ws://127.0.0.1:8080/ws")
# On ne peut rien mettre comme code ici, il faut le
# mettre dans @app.signal('onjoined') si on veut
# entrer du code après que l'app soit lancée.
</pre>
<p>Et on lance notre app dans un autre terminal:</p>
<pre lang="bash">python app.py</pre>
<p>Nous avons maintenant Crossbar.io qui tourne d&#8217;une console, et le client Python qui tourne dans une seconde console, connecté au routeur.</p>
<h2>Le lecteur vidéo</h2>
<p>Il nous faut maintenant définir le comportement de notre lecteur vidéo, un client WAMP Javascript. Il s&#8217;agit essentiellement de se connecter au serveur WAMP, et d&#8217;échanger des messages via RPC ou PUB/SUB :</p>
<pre lang="javascript">  var player = {};
  var url;
  /* On va utiliser du pur JS histoire de pas mélanger
    des notions de jQuery dans le tas. Je ne vais
    PAS utiliser les best practices sinon vous allez
    être noyés dans des détails */

  /* Lancer le code une fois que la page est chargée */
  window.addEventListener("load", function(){

    /* Connexion au serveur WAMP. J'utilise
       les valeurs par défaut du serveur de
       dev. On ouvre explicitement la connection
       à la fin du script. */
    var connection = new autobahn.Connection({
       url: 'ws://' + window.location.hostname + ':8080/ws',
       realm: 'realm1'
    });

    /* Lancer ce code une fois que la connexion
       est réussie. Notez que je ne gère pas
       les erreurs dans dans une APP JS, c'est
       un puits sans fond. */
    connection.onopen = function (session) {

      /* Appel de la fonction ip() sur le serveur */
      session.call('demo.ip')

      /* Une fois qu'on a récupéré l'IP,
         on peut fabriquer l'URL de notre
         projet et on appelle la fonction
         get_uuid() du serveur */
      .then(function(ip){
        url = 'http://' + ip + ':8000';
        return session.call('demo.uuid');
      })

      /* Une fois qu'on a l'UUID, on peut commencer
         à gérer la partie télécommande */
      .then(function(uuid){

        /* Création du QR code avec le lien pointant
           sur la bonne URL. On met l'ID dans le hash. */
        var controlUrl = url + '/control.html#' + uuid;
        var codeDiv = document.getElementById("qrcode");
        new QRCode(codeDiv, controlUrl);
        var ctrllink = document.getElementById("ctrllink");
        ctrllink.href = controlUrl;

        /* Notre travail consiste essentiellement à
           manipuler cet élément */
        var video = document.getElementById("vid");

        /* On attache déclare 4 fonctions comme étant
           appelable à distance. Ces fonctions sont
           appelables en utilisant le nom composé
           de notre ID et de l'action qu'on souhaite
           faire. Ex:
           'b27f7e9360c04efabfae5ac21a8f4e3c.play'
           pour appeler "play" sur notre session. */
        session.register(uuid + '.play', function(){
           video.play();
        });

        session.register(uuid + '.pause', function(){
           video.pause();
        });

        session.register(uuid + '.volume', function(val){
           video.volume = val[0];
        });

        session.register(uuid + '.status', function(val){
          return {
            'playing': !video.paused,
            'volume': video.volume
          };
        });



       /* Quelqu'un peut très bien
           appuyer sur play directement sur cette page.

          Il faut donc réagir si l'utilisateur le fait,
          publier un événement via WAMP pour permettre
          à notre télécommande de se mettre à jour
          */
       video.addEventListener('play', function(){
         /* On publie un message indiquant que
            le player a recommencé à lire la vidéo.
            */
         session.publish(uuid + '.play');
       });

        video.addEventListener('pause', function(){
          session.publish(uuid + '.pause');
        });

        video.addEventListener('volumechange', function(){
          session.publish(uuid + '.volume', [video.volume]);
        });

     });
    };

    /* Ouverture de la connection une fois que tous les
       callbacks sont bien en place.*/
    connection.open();
  });

</pre>
<h2>Code de la télécommande</h2>
<p>La télécommande est notre dernier client WAMP (on peut avoir plein de clients WAMP, ne vous inquiétez, ça tient 6000 connections simultanées sur un tout petit Raspberry PI). </p>
<p>Son code a pour but d&#8217;envoyer des ordres au player HTML5, mais aussi de mettre à jour son UI si le player change d&#8217;état.</p>
<pre lang="javascript">/* L'objet qui se charge de la logique de nos
   controles play/pause et changement de
   volume.
   Rien de fou, il change l'affichage
   du bouton et du slider selon qu'on
   est en pause/play et la valeur du
   volume.
   */
var control = {
   playing: false,
   setPlaying: function(val){
      control.playing = val;
      var button = window.document.getElementById('play');
      if (!val){
         button.innerHTML = 'Play'
      } else {
         button.innerHTML = 'Pause';
      }
   },
   setVolume: function(val){
      var slider = window.document.getElementById('volume');
      slider.value = val;
   }
};
window.onload = function(){
  var connection = new autobahn.Connection({
    url: 'ws://' + window.location.hostname + ':8080/ws',
    realm: 'realm1'
  });

  connection.onopen = function (session) {

    /* Récupération de l'ID dans le hash de l'URL */
    var uuid = window.location.hash.replace('#', '');

    /* Mise à jour des controles selon le status actuel
       du player grace à un appel RPC vers notre autre
       page. */
    session.call(uuid + '.status').then(function(status){

      control.setPlaying(status['playing']);
      control.setVolume(status['volume'])

      /* On attache l'appui sur les contrôles à
         un appel de la fonction play() sur le
         player distant. L'uuid nous permet
         de n'envoyer l'événement que sur le
         bon player. */
      control.togglePlay = function() {
        if (control.playing){
          session.call(uuid + '.pause');
          control.setPlaying(false);
        } else {
          session.call(uuid + '.play');
          control.setPlaying(true);
        }
      };

      control.volume = function(val){
        session.call(uuid + '.volume', [val / 100]);
      };

      /* On ajoute un callback sur les événements
         de changement de status du player. Si
         quelqu'un fait play/pause ou change le
         volume, on veut mettre à jour la page. */
      session.subscribe(uuid + '.play', function(){
        control.setPlaying(true);
      });

      session.subscribe(uuid + '.pause', function(){
        control.setPlaying(false);
      });

      session.subscribe(uuid + '.volume', function(val){
        control.setVolume(val[0] * 100);
      });
    });
  };

  connection.open();
};
</pre>
<h2>En résumé</h2>
<p>Voici à quoi ressemble le projet final :</p>
<pre>.
├── app.py
├── control.html
├── .crossbar
│   └── config.json
└── index.html
</pre>
<div id="attachment_11173" style="width: 499px" class="wp-caption aligncenter"><a href="http://sametmax.com/wp-content/uploads/2014/06/demo_video_wamp.png" class="grouped_elements" rel="tc-fancybox-group11146"><img class="size-full wp-image-11173" title="Bien que l'app Python lance le serveur automatiquement et de manière invisible, c'est bien un composant à part." src="http://sametmax.com/wp-content/uploads/2014/06/demo_video_wamp.png" alt="Schéma de fonctionnement de la démo" width="489" height="346" /></a><p class="wp-caption-text">Bien que l&#8217;app Python lance le serveur automatiquement et de manière invisible, c&#8217;est bien un composant à part.</p></div>
<p>Pour ce projet, on aura utilisé :</p>
<ul>
<li><a href="http://wamp.ws/">WAMP</a>: le protocole qui permet de faire communiquer en temps réel des parties d&#8217;application via RPC et PUB/SUB.</li>
<li><a href="http://autobahn.ws/js/">Autobahn.js</a>: une lib pour créer des clients WAMP en javascript.</li>
<li><a href="http://autobahn.ws/python/">Autobahn.py</a>: une lib pour créer des clients WAMP en Python.</li>
<li><a href="http://crossbar.io/">Crossbar.io</a>: un routeur WAMP.</li>
</ul>
<p>Il y a pas mal de notions à prendre en compte.</p>
<p>D&#8217;abord, le <strong>RPC</strong>.</p>
<p>Cela permet à un client de dire &#8220;les autres clients peuvent appeler cette fonction à distance&#8221;. On l&#8217;utilise pour exposer <code>ip()</code> et <code>get_uuid()</code> sur notre serveur et notre Javascript peut donc les appeler. Mais on l&#8217;utilise AUSSI pour qu&#8217;une des pages (le player) expose <code>play()</code>, <code>pause()</code> et <code>volume()</code> et que l&#8217;autre page (notre télécommande) puisse les utiliser.</p>
<p>La grosse différence, c&#8217;est que <code>ip()</code> peut être appelé par tous les clients en utilisant &#8220;demo.ip&#8221; alors que <code>play()</code> ne peut être appelé que par les clients qui connaissent l&#8217;ID du player, puisqu&#8217;il faut utiliser &#8220;&lt;id&gt;.play&#8221;.</p>
<p>Ensuite, il y a le <strong>PUB/SUB</strong>.</p>
<p>Cela permet à un client de dire &#8220;j&#8217;écoute tous les messages adressés à ce nom&#8221;. Et un autre client peut envoyer un message (on appelle ça aussi un événement, c&#8217;est pareil) sur ce nom, de telle sorte que tous les clients abonnés le reçoivent.</p>
<p>On l&#8217;utilise pour que notre télécommande dise &#8220;j&#8217;écoute tous les messages qui concernent les changements de status du player.&#8221; De l&#8217;autre côté, quand on clique sur un contrôle du player, on envoie un message précisant si le volume a changé, ou si on a appuyé sur play/pause. La télécommande peut ainsi mettre son UI à jour et refléter par exemple, la nouvelle valeur du volume.</p>
<p>Cela résume bien les usages principaux de ces deux outils :</p>
<ul>
<li>RPC permet de donner un ordre ou récupérer une information.</li>
<li>PUB/SUB permet de (se) tenir au courant d&#8217;un événement.</li>
</ul>
<p>Voici le workflow de notre projet :</p>
<ul>
<li>On lance un serveur WAMP.</li>
<li>On connecte des clients dessus (du code Python ou Js dans notre exemple).</li>
<li>Les clients déclarent les fonctions qu&#8217;ils exposent en RPC et les événements qu&#8217;ils écoutent en PUB/SUB.</li>
<li>Ensuite on réagit aux actions utilisateurs et on fait les appels RPC et les publications PUB/SUB en conséquence.</li>
</ul>
<p><strong>Si vous virez tous les commentaires, vous verrez que le code est en fait vraiment court pour une application aussi complexe.</strong></p>
<p>Encore une fois, il est possible de le faire sans WAMP, ce sera juste plus compliqué. Je vous invite à essayer de le faire pour vous rendre compte. Avec PHP, Ruby ou une app WSGI, c&#8217;est pas marrant du tout. Avec NodeJs, c&#8217;est plus simple, mais il faut quand même se taper la logique de gestion RPC et PUB/SUB à la main ou installer pas mal de libs en plus.</p>
<p>WAMP rend ce genre d&#8217;app triviale à écrire. Enfin triviale parce que là j&#8217;ignore tous les edge cases, évidemment. Pour un produit solide, il faut toujours suer un peu.</p>
<h2>Les limites du truc</h2>
<p>C&#8217;est du Python 2.7. Bientôt on pourra le faire avec asyncio et donc Python 3.4, mais malheureusement sans le serveur de dev.</p>
<p>Heureusement, Twisted est en cours de portage vers Python 3, et donc tout finira par marcher en 3.2+.</p>
<p>C&#8217;est du HTML5, mais bien entendu, rien ne vous empêche de faire ça avec du Flash si ça vous amuse.</p>
<p>C&#8217;est du WebSocket, mais on peut utiliser un peu de Flash pour <a href="https://github.com/gimite/web-socket-js">simuler WebSocket</a> pour les vieux navigateurs qui ne le supportent pas.</p>
<p>Non, la vraie limite c&#8217;est encore la jeunesse du projet : pas d&#8217;autoreload pour le serveur (super chiant de devoir le faire à la main à chaque fois qu&#8217;on modifie le code) et les erreurs côté serveur se lisent dans la console JS, et pas dans le terminal depuis lequel on a lancé le serveur. Plein de petits détails comme ça.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/introduction-a-wamp-en-python/feed/</wfw:commentRss>
		<slash:comments>47</slash:comments>
<enclosure url="http://media.w3.org/2010/05/sintel/trailer.ogv" length="12965718" type="video/ogg" />
<enclosure url="http://media.w3.org/2010/05/sintel/trailer.mp4" length="4372373" type="video/mp4" />
<enclosure url="http://media.w3.org/2010/05/sintel/trailer.webm" length="3091780" type="video/webm" />
	<post-id xmlns="com-wordpress:feed-additions:1">11146</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2014/06/FqebLW21.png" length="439958" type="image/jpg" />	</item>
		<item>
		<title>Le potentiel de WAMP, autobahn et crossbar.io</title>
		<link>http://sametmax.com/le-potentiel-de-wamp-autobahn-et-crossbar-io/</link>
		<comments>http://sametmax.com/le-potentiel-de-wamp-autobahn-et-crossbar-io/#comments</comments>
		<pubDate>Sun, 01 Jun 2014 10:09:32 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[autobahn]]></category>
		<category><![CDATA[crossbar]]></category>
		<category><![CDATA[flask]]></category>
		<category><![CDATA[http]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[wamp]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=10380</guid>
		<description><![CDATA[Je sais, je sais, je vous fais chier avec <a href="http://sametmax.com/crossbar-le-futur-des-applications-web-python/">crossbar</a> et <a href="http://sametmax.com/un-petit-gout-de-meteor-js-en-python/">autobahn</a>.

Mais ça me tue de ne pas voir plus de monde exploiter cette techno.]]></description>
				<content:encoded><![CDATA[<p>Je sais, je sais, je vous fais chier avec <a href="http://sametmax.com/crossbar-le-futur-des-applications-web-python/">crossbar</a> et <a href="http://sametmax.com/un-petit-gout-de-meteor-js-en-python/">autobahn</a>.</p>
<p>Mais ça me tue de ne pas voir plus de monde exploiter cette techno.</p>
<p>Pendant que Max fait la sieste, j&#8217;ai pris mon stylo et j&#8217;ai fait la liste des besoins d&#8217;une app Web actuelle. Quels sont les composants qu&#8217;on utilise presque systématiquement, mais en agrégeant divers bouts de trucs à droite et à gauche ?</p>
<p>Ensuite j&#8217;ai regardé les possibilités des outils WAMP :</p>
<ul>
<li>PUB/SUB et RPC.</li>
<li>Asynchrone.</li>
<li>Gestionnaire de process intégré.</li>
<li>Serveur stand alone qui n&#8217;a pas besoin d&#8217;un proxy pour être en prod.</li>
</ul>
<p>M&#8217;inspirant de cela, et du travail que je suis en train de faire avec l&#8217;équipe de Tavendo pour faire une API flaskesque pour autobahn, j&#8217;ai prototypé une API d&#8217;un framework Web qu&#8217;on pourrait coder au dessus de cette techno.</p>
<p>Voilà ce que ça donne&#8230;</p>
<p>Une API qui mélange flask et nodejs pour le Web</p>
<pre lang="python">app = Application('YourProjectName')

# Envoyer et recevoir des requêtes HTTP
@app.http.post(r'/form')
def _(req, res):
    res.json({'data': 'pouet'})

@app.http.get(r'/user/:id/')
def _(req, res):
    res.render('index.html', {'data': 'pouet'})

# Servir des fichiers statiques
@app.http.serve('uri', '/path/to/dir', [allow_index])

app.run()</pre>
<p>Comme c&#8217;est asynchrone, on a de très bonnes perfs. Comme c&#8217;est basé sur Twisted, on a pas besoin d&#8217;un serveur wsgi (gunicorn, uwsgi, etc) ni d&#8217;un proxy (nginx) devant. On peut le mettre en prod tel quel.</p>
<p>Parti de ce principe, on peut ajouter la gestion du PUB/SUB et du RPC pour WAMP :</p>
<pre lang="python"># Callback attendant l'événement
@app.wamp.event('auth.signedin')
def _(ctx, a, b, c):
    pass

# déclenchement de l'événément
app.wamp.pub('auth.signedin')

# Déclaration du fonnction appelable à distance
@app.wamp.remote('auth.signin')
def _(ctx, a, b, c):
    pass

# appel de la fonnction
app.wamp.call('auth.signin')</pre>
<p>On est souvent perdu quand on fait de l&#8217;asynchrone pour la première fois avec Python car on ne sait pas comment lancer du code après <code>.run()</code>. On peut régler la question proposant des hooks pour les instants clés de l&#8217;app.</p>
<pre lang="python"># Callback à lancer quand l'app est prête
@app.on('app.ready')
def _(ctx, args):
    pass

# Signalement que l'app est prête (fait automatiquement en interne
# pour les moments les plus importants)
app.emit('app.ready')</pre>
<p>Et tant qu&#8217;on y est, puisqu&#8217;on a une event loop, profitons en pour proposer du CRON intégré à l&#8217;app. C&#8217;est moins chiant à déployer qu&#8217;un script CRON, c&#8217;est cross plateforme, et on a accès facilement à toute sa stack.</p>
<pre lang="python"># Lancer du code tous les x temps ou a une date précise
@app.cron(every=seconds)
@app.cron(every=timedelta, overlap=False)
@app.cron(hour=7, minute=30, day_of_week=1)
@app.cron(when=datetime)
def _(ctx, args):
    pass

</pre>
<p>Pourquoi s&#8217;arrêter là ? Event loop + message passing + safe queues + workers = tasks queues !</p>
<pre lang="python"># Créer une file d'attente
queue = @app.queue('name', [workers], [result_backend])

# Callback appelé par un worker quand il depop ce 
# message dans la file
@queue.task('encode.video')
def _(ctx, data):
    pass

# Envoie d'une tache dans la queu
queue.append('encode.video', data)
</pre>
<p>Comme on utilise Twisted, on a accès à une chiée de protocoles, et on peut aussi créer les siens. On peut donc imaginer un système de plugins qui rajoute des protocoles supportés :</p>
<pre lang="python">app = Application('YourProjectName')
app.plug('lib.ajoutant.sms', [namespace])</pre>
<p>Si on en a beaucoup et que le namespace nous convient :</p>
<pre lang="python">app = Application('YourProjectName', plugins=('lib1', 'lib2', 'etc'))</pre>
<p>Exemples de plugins possibles :</p>
<pre lang="python"># Recevoir et envoyer des SMS (via un service type twilio, une gateway kannel ou
# un modem physique)
@app.sms.receive(r'LOVE \w+ \w+')
def _(ctx, args):
    pass
app.sms.send('test', [contact])


# Envoyer et recevoir des emails (via un server SMTP ou IMAP)
@app.email.receive(src=r'.*@sametmax.com', dest=r'spam.*@*.')
def _(ctx, args):
    pass
app.email.send('test', [contact, title, attachments])


# techniquement n'importe quel service de message pour lequel on peut écrire
# un backend
@app.tweet.receive(r'Chat')
@app.fb.receive(r'Like')
@app.instagram.receive(r'Bouffe')
@app.irc.message(r'dtc')
def _(ctx, args):
    pass</pre>
<p>Le problème des apps centrées sur un objet, c&#8217;est qu&#8217;elles ont souvent un design monolithique. Ce n&#8217;est pas un problème du concept d&#8217;app, c&#8217;est juste que les auteurs ont pensé &#8220;point d&#8217;entrée&#8221;, et pas &#8220;élément composable&#8221;.</p>
<p>Si besoin, on doit pouvoir composer une app via plusieurs sous-app :</p>
<pre lang="python">app = Application()
app.embed('autre.app')</pre>
<p>ou</p>
<pre lang="python">app = Application(embed=['app1', 'app2', 'app3'])</pre>
<p>Il faut des hooks pour overrider la configuration, mais vous avez compris le principe.</p>
<p>Un autre problème avec les plateformes comme NodeJS, c&#8217;est qu&#8217;il est difficile d&#8217;utiliser plusieurs coeurs. C&#8217;est une des raisons du succès de Go.</p>
<p>Or, Crossbar encourage la division en plusieurs process qui communiquent entre eux (un peu comme les channels). Créons aussi une API pour ça :</p>
<pre lang="python">p1 = app.process()
p2 = app.process()

# Déclarer et appeler une procédure dans process 1
@p1.wamp.remote('auth.signin')
def _(ctx, args):
    pass

# Déclarer et appeler une procédure dans process 2
@p2.wamp.event('auth.signedin')
def _(ctx, args):
    pass</pre>
<p>Ainsi on profite enfin de plusieurs CPU. La même chose en plus facile à changer:</p>
<pre lang="python"># Déclarer et appeler une procédure
@app.wamp.remote('auth.signin')
def _(ctx, args):
    pass

# Déclarer et appeler une procédure
@app.wamp.event('auth.signedin')
def _(ctx, args):
    pass

app.processes({
    1: ['wamp.remote:auth.signin']
    2: ['wamp.event:auth.signedin']
})</pre>
<p>En bonus, on fait la nique au GIL.</p>
<p>Mieux, on peut bouger ses process sur plusieurs machines :</p>
<p>Machine 1 (routeur):</p>
<pre lang="python">
router = Application(endpoint="0.0.0.0:8080")
router.run()
</pre>
<p>Machine 2 (authentification):</p>
<pre lang="python">
# IP du router
auth = Application('auth', connect_to="182.64.1.15:8080")

# Nommage automatique en fonction du nom de la fonction
# et de l'app, avec possibilité d'annuler ou overrider le prefix.
# Ici du coup la fonction s'appellera en RPC via 'auth.signin'
@auth.wamp.remote()
def signin(ctx, args):
    pass

auth.run()
</pre>
<p>Machine 3 (API REST):</p>
<pre lang="python">
web = Application('site', connect_to="182.64.1.15:8080")

@web.http.post(r'api/auth/')
def _(req, res):
    user = yield res.wamp.call('auth.signin',
                               req.POST['username'],
                               req.POST['password'])*
    if user
        user = yield res.wamp.pub('auth.signedin', user.userid)
        res.json({'token': user.token})
    else:
        res.json({'error': 'nope'})


@web.http.get(r'api/stuff/')
def _(req, res):
    res.json(get_stuff())

@web.http.serve('uri', '/path/to/dir', [allow_index])

web.run()
</pre>
<p>Et vous savez le plus beau dans tout ça ? En Python on a plein de libs qui sont encore bloquantes. En théorie on ne peut pas les utiliser dans les apps asynchrones. Quand on a toute sa logique métiers dans des classes d&#8217;ORM, c&#8217;est balot. Mais pas ici ! On met un process avec tous ces appels bloquants, et on les appelle depuis des process non bloquant en RPC de manière asynchrone. Pif, paf, pouf, problème isolé.</p>
<p>Après, libre à son imagination de rajouter des fonctionnalités de confort&#8230;</p>
<p>Callback qui sera appelé seulement x fois :</p>
<pre lang="python"># Déclarer et appeler une procédure
@p1.wamp.event('auth.signedin', options={'limit_calls': x} )
def _(ctx, args):
    pass</pre>
<p>Raccourcis pour les opérations courantes :</p>
<pre lang="python"># Recevoir et envoyer un événement
@app.sub('auth.signin')
def _(ctx, *args):
    # ctx.pub
@app.pub('auth.signedin')

# Déclarer et appeler une procédure
@app.proc('auth.signedin')
def _(ctx, args):
    # ctx.call
app.rpc()</pre>
<p>Comme je vous l&#8217;avais expliqué, crossbar peut gérer le cycle de vie de services externes à votre application au démarrage. Autant exposer cette API programativement :</p>
<pre lang="python">@app.service(['/urs/bin/nodejs', 'script.js'], [user], [group])</pre>
<p><code>.run()</code>, c&#8217;est cool, mais si on veut changer des options via la ligne de commande, faut se taper tout le boulot alors que ça pourrait très bien se générer automatiquement :</p>
<pre lang="python">@app.cmd_run()</pre>
<p>Et si vous faites : <code>python sites.py --debug=true --endpoint=0.0.0.0:5252</code>, ça le prend automatiquement en compte. Y a pas de raison de se faire chier.</p>
<p>En parlant de générer automatiquement des trucs, le fichiers de configs pour les services externes sur lesquels on peut avoir envie de brancher notre app, c&#8217;est toujours galère. Autant fournir un exemple de base qui est sûr de toujours marcher, généré avec les paramètres de notre app :</p>
<pre lang="bash">python site.py template centos:nginx
python site.py template ubuntu:upstart
python site.py template bsd:systemd # :D</pre>
<p>On peut partir très loin dans le délire &#8220;battery included&#8221;. Typiquement, on peut fournir des services externes nous même puisque crossbar nous le propose, et coder des versions moins bien, mais compatibles (et suffisantes pour les petits sites), de projets toujours utilses :</p>
<ul>
<li>cache (compatible redis)</li>
<li>live settings (compatible etcd) mais avec en prime un event wamp propagé à chaque</li>
<p>  changement de valeur</p>
<li>build (compatible, heu, j&#8217;en sais rien) qui s&#8217;occupe en tâche de fond de surveiller le >système de fichier et lancer les compilations, les minifications, les copies, les tests unittaires, etc.</li


<li>logging centralisé (compatible sentry).</li>
<li>Un bridge WAMP/REST qui permet d&#8217;envoyer et recevoir des events WAMP sur votre app Django ou flask en utilisant HTTP.</li>
</ul>
<p>On plug tout ça a une admin Web.</p>
<p>J&#8217;espère que je vous ai donné maintenant l&#8217;envie de vous plonger un peu plus dans cette techno, et peut être coder quelque chose avec.</p>
<p>Il n&#8217;y a plus d&#8217;excuses pour ne pas avoir de framework web next gen, ultime de la mort qui tue en Python. A part le fait qu&#8217;on soit des feignasses.</p>
<p>Ah, merde, on est foutus.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/le-potentiel-de-wamp-autobahn-et-crossbar-io/feed/</wfw:commentRss>
		<slash:comments>29</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">10380</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2014/06/tumblr_n3hz135rRO1r539hzo1_500.jpg" length="48460" type="image/jpg" />	</item>
		<item>
		<title>Crossbar, le futur des applications Web Python ?</title>
		<link>http://sametmax.com/crossbar-le-futur-des-applications-web-python/</link>
		<comments>http://sametmax.com/crossbar-le-futur-des-applications-web-python/#comments</comments>
		<pubDate>Sun, 25 May 2014 10:24:36 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[autobahn]]></category>
		<category><![CDATA[crossbar.io]]></category>
		<category><![CDATA[javascript]]></category>
		<category><![CDATA[nodejs]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[twisted]]></category>
		<category><![CDATA[wamp]]></category>
		<category><![CDATA[websocket]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=10329</guid>
		<description><![CDATA[Je suis <a href="http://crossbar.io/">crossbar.io</a> depuis quelques temps maintenant, et je suis très, très étonné de ne pas plus en entendre parler dans la communauté Python.]]></description>
				<content:encoded><![CDATA[<p>Je suis <a href="http://crossbar.io/">crossbar.io</a> depuis quelques temps maintenant, et je suis très, très étonné de ne pas plus en entendre parler dans la communauté Python.</p>
<p>Bon, en fait, à moitié étonné.</p>
<p>D&#8217;un côté, c&#8217;est une techno qui, à mon sens, représente ce vers quoi Python doit se diriger pour faire copain-copain avec Go/NodeJs et proposer une &#8220;killer feature&#8221; dans le monde des applications serveurs complexes.</p>
<p>De l&#8217;autre, hum, leur page d&#8217;accueil explique à quoi ça sert de cette manière :</p>
<blockquote><p>Crossbar.io is an application router which implements the Web Application Messaging Protocol (WAMP). WAMP provides asynchronous Remote Procedure Calls and Publish &amp; Subscribe (with <a title="WebSocket" href="http://fr.wikipedia.org/wiki/WebSocket" target="_blank">WebSocket</a> being one transport option) and allows to connect application components in distributed systems</p></blockquote>
<p>Moui, moui, moui monseigneur, mais concrètement, là, hein, je peux faire quoi avec ?</p>
<p>C&#8217;est toujours le problème avec les gens intelligents (hein Cortex ?) : ils font des trucs super cool, et personne ne comprend à quoi ça sert parce qu&#8217;il ne sont pas foutus de l&#8217;expliquer.</p>
<p>Moi je suis un peu con, alors je vais profiter qu&#8217;on soit tous au même niveau pour vous faire passer le message.</p>
<p>J&#8217;étais persuadé d&#8217;avoir mis la musique habituelle&#8230; Je la remets :</p>
<p><iframe class='youtube-player' type='text/html' width='1170' height='689' src='http://www.youtube.com/embed/v3ckHzJgw4k?version=3&#038;rel=1&#038;fs=1&#038;autohide=2&#038;showsearch=0&#038;showinfo=1&#038;iv_load_policy=1&#038;wmode=transparent' allowfullscreen='true' style='border:0;'></iframe></p>
<h2>Web Application Message Protocol</h2>
<p>Je vous avais parlé d&#8217;<a href="http://sametmax.com/un-petit-gout-de-meteor-js-en-python/">autobahn</a> dernièrement, un client WAMP qui embarque aussi un routeur basique. Crossbar est la partie serveur, un routeur WAMP plus sérieux.</p>
<p>Crossbar permet à tous les clients d&#8217;échanger des messages WAMP à travers lui. Bien entendu, un client WAMP peut parler au serveur Crossbar et inversement comme un client HTTP peut parler à un serveur Apache/Nginx et inversement. Mais plus que ça, <strong>les clients peuvent parler entre eux, de manière transparente et simple.</strong> Comme un client <a title="Advanced Message Queuing Protocol" href="http://fr.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol" target="_blank">AMQP</a> peut parler aux autres à travers un serveur <a title="RabbitMQ" href="http://en.wikipedia.org/wiki/RabbitMQ" target="_blank">RabbitMQ</a>.</p>
<p>Cependant ça ne vous avance pas si vous ne savez pas ce qu&#8217;est WAMP ou à quoi ça sert. La charrue avec la peau de l&#8217;ours, tout ça.</p>
<p>WAMP est un <a href="http://wamp.ws/spec/">protocole standardisé</a> pour échanger des messages entre deux systèmes. Ce n&#8217;est pas particulièrement lié à Python, on peut parler <strong>WAMP dans n&#8217;importe quel langage.</strong></p>
<p>Il fonctionne en effet, principalement, au dessus de Websocket, donc <strong>on peut l&#8217;utiliser directement dans le navigateur</strong>, dans Firefox, Chrome, Opera, Safari et même IE10, via une lib Javascript. Qui est en fait juste un gros wrapper autour de l&#8217;API websocket standardisant la manière d&#8217;envoyer des données. Il n&#8217;y a rien de magique derrière, pas de formats compliqués, pas de binaire, c&#8217;est vraiment juste des appels websocket contenant des données formatées en JSON avec une certaine convention. <strong>En ce sens il fait penser à <a title="sockjs" href="http://fr.slideshare.net/ngocdaothanh/sockjs-intro" target="_blank">SockJS</a></strong> et (feu) socket.io.</p>
<p>Seulement contrairement aux solutions type SocketJS, <strong>il n&#8217;est pas limité au navigateur</strong>. Il y a <a href="http://wamp.ws/implementations/">des libs</a> pour l&#8217;utiliser dans un code serveur Python, C++ ou NodeJS, dans une app Android et même directement depuis les entrailles de Nginx ou d&#8217;une base de données Oracle (en SQL) avec certains routeurs.</p>
<div id="attachment_10340" style="width: 567px" class="wp-caption aligncenter"><a href="http://sametmax.com/wp-content/uploads/2014/05/general1.png" class="grouped_elements" rel="tc-fancybox-group10329"><img class="size-full wp-image-10340" title="Comme HTTP, WAMP est juste un moyen de faire parvenir des données d'un point A à un point B. Mais contrairement à HTTP, WAMP permet aux clients de parler entre eux, et pas juste au serveur." src="http://sametmax.com/wp-content/uploads/2014/05/general.png" alt="Schéma général du fonctionnement de WAMP" width="557" height="538" /></a><p class="wp-caption-text">Comme HTTP, WAMP est juste un moyen de faire parvenir des données d&#8217;un point A à un point B. Mais contrairement à HTTP, WAMP permet aux clients de parler entre eux, et pas juste au serveur.</p></div>
<p><strong>Comprenez bien, ça veut dire qu&#8217;on peut envoyer et recevoir des données arbitraires, en temps réel, entre tous ces systèmes, sans se prendre la tête, et de manière transparente.</strong></p>
<p>WAMP c&#8217;est donc comme, mais mieux que :</p>
<ul>
<li>des requêtes HTTP, car c&#8217;est du push, asynchrone et temps réel;</li>
<li>des requêtes websocket via SocketJS car c&#8217;est un standard, qui fonctionne SUR et ENTRE plusieurs services côté serveurs malgré les différents langages;</li>
<li>des messages AMQP car ça marche dans le navigateur et ça se configure facilement.</li>
</ul>
<p>Bien utilisé, Crossbar permet d&#8217;amener Python dans la cour de frameworks &#8220;temps réel&#8221; novateurs comme <a title="Meteor" href="http://fr.wikipedia.org/wiki/Meteor_(framework)" target="_blank">MeteorJS</a>, et potentiellement les dépasser.</p>
<p>Car WAMP permet de faire deux choses. Simplement. Et bien.</p>
<h3>1 &#8211; Du PUB/SUB</h3>
<p>Donc de dire dans son code &#8220;appelle cette fonction quand cet événement arrive&#8221;. <strong>C&#8217;est comme les signaux de Django ou QT, mais ça marche à travers le réseau.</strong> On le fait souvent avec Redis ces temps-ci. Avec WAMP et Javascript, ça donne :</p>
<pre lang="javascript">// connection au routeur WAMP (par exemple, crossbar.io)
ab.connect("ws://localhost:9000", function(session) {
    // je m'inscris à un événement
    session.subscribe('un_evenement_qui_vous_plait', function(topic, evt){
        // faire un truc avec les données reçues
        // à chaque fois que l'événement est envoyé
        // par exemple mettre la page à jour
    });
});
</pre>
<div id="attachment_10343" style="width: 571px" class="wp-caption aligncenter"><a href="http://sametmax.com/wp-content/uploads/2014/05/sub.png" class="grouped_elements" rel="tc-fancybox-group10329"><img class="size-full wp-image-10343" title="Des client SUBscribe à un événément. Un événément est un nom arbitrairement choisit par le programmeur, et qu'il va déclencher lui-même quand il pense qu'il se passe quelque chose d'important auquel il faut que le reste du signal réagisse. " src="http://sametmax.com/wp-content/uploads/2014/05/sub.png" alt="Schéma de fonctionnement du subscribe de WAMP" width="561" height="572" /></a><p class="wp-caption-text">Des client SUBscribe à un événément. Un événément est un nom arbitrairement choisit par le programmeur, et qu&#8217;il va déclencher lui-même quand il pense qu&#8217;il se passe quelque chose d&#8217;important auquel il faut que le reste du signal réagisse.</p></div>
<p>Et ailleurs, dans une autre partie du fichier, ou même sur un autre navigateur Web :</p>
<pre lang="javascript">ab.connect("ws://localhost:9000", function(session) {
    // création d'un événement auquel on attache des données
    session.publish('un_evenement_qui_vous_plait', ['des données']);
</pre>
<div id="attachment_10344" style="width: 565px" class="wp-caption aligncenter"><a href="http://sametmax.com/wp-content/uploads/2014/05/pub.png" class="grouped_elements" rel="tc-fancybox-group10329"><img class="size-full wp-image-10344" title="Le programmeur décide que quelque chose d'important arrive (création d'un contenu, login d'un utilisateur, notification), et PUBlish l'événement" src="http://sametmax.com/wp-content/uploads/2014/05/pub.png" alt="Schéma de fonctionnement de PUB avec WAMP" width="555" height="452" /></a><p class="wp-caption-text">Le programmeur décide que quelque chose d&#8217;important arrive (création d&#8217;un contenu, login d&#8217;un utilisateur, notification), et PUBlish l&#8217;événement</p></div>
<p>Et oui, c&#8217;est tout. On se connecte à crossbar, et on discute. La fonction du <code>subscribe</code> sera alors appelée avec les données du <code>publish</code>. Même si il y a 3000 km entre les deux codes. Même si le code A est sur un navigateur et le B sur un autre, ou sur un serveur NodeJS, ou une app Android.</p>
<p>Ce qui fait peur au début, c&#8217;est qu&#8217;il y a TROP de flexibilité :</p>
<ul>
<li>Je dois attendre quoi comme événements ?</li>
<li>Qu&#8217;est-ce que je passe comme données ?</li>
<li>Est-ce que c&#8217;est rapide ? Léger ?</li>
</ul>
<p>Mais en fait c&#8217;est super simple : un événement c&#8217;est juste une action de votre application comme un élément (un post, un commentaire, un utilisateur&#8230;) ajouté, supprimé ou modifié. Finalement c&#8217;est le bon vieux <a title="CRUD" href="http://fr.wikipedia.org/wiki/CRUD" target="_blank">CRUD</a>, mais en temps réel, et en push, au lieu du pull. Vous choisissez un nom qui représente cette action, vous attachez des données à ce nom, voilà, c&#8217;est un événement que tous les abonnés peuvent recevoir.</p>
<p>Avec un bonus : ça marche sur le serveur aussi ! Votre code Python reçoit &#8220;ajouter un commentaire&#8221; comme événement ? Il peut ajouter le commentaire en base de données, envoyer un message à un service de cache ou à un autre site en NodeJS pour le mettre à jour, renvoyer un événement pour mettre à jour les pages Web et l&#8217;app Android, etc.</p>
<p>On peut passer n&#8217;importe quelles données qui peut se JSONiser. En gros n&#8217;importe quoi qu&#8217;on enverrait via HTTP. Donc des données très structurées, imbriquées et complexes comme des données géographiques, ou très simples comme des notifications</p>
<p><strong>Avec PUB / SUB, WAMP remplace tout ce qu&#8217;on ferait normalement avec des appels AJAX dans le browser, et tout ce qu&#8217;on ferait avec des files de message côté serveur. </strong>Plus puissant encore, il permet de relier ces deux mondes.</p>
<p>Et même si on atteint pas les perfs de <a title="ZeroMQ" href="http://en.wikipedia.org/wiki/%C3%98MQ" target="_blank">ZeroMQ</a> (qui n&#8217;a pas de serveur central), c&#8217;est très <a href="https://into.aalto.fi/download/attachments/12324178/Huang_Fuguo_thesis_2.pdf?version=1&amp;modificationDate=1383290628000">performant et léger</a>.</p>
<h3>2 &#8211; Du RPC</h3>
<p>Appeler une fonction située ailleurs que dans son code. C&#8217;est vieux comme le monde (si vous avez des souvenirs douloureux de CORBA et SOAP, levez la main), et c&#8217;est extrêmement pratique. Pour faire simple, continuons avec un exemple en Javascript, mais rappelez-vous que ça marche pareil en C++ ou Python :</p>
<pre lang="javascript">ab.connect("ws://localhost:9000", function(session) {
   function une_fonction(a, b) {
      return a + b;
   }
   // on déclare que cette fonction est appelable à distance
   session.register('une_fonction', une_fonction);
});
</pre>
<div id="attachment_10347" style="width: 575px" class="wp-caption aligncenter"><a href="http://sametmax.com/wp-content/uploads/2014/05/register1.png" class="grouped_elements" rel="tc-fancybox-group10329"><img class=" wp-image-10347" title="RPC marche à l'envers de PUB/SUB. Un client expose du code, et un autre demande explicitement qu'il soit exécuté." src="http://sametmax.com/wp-content/uploads/2014/05/register.png" alt="Schéma expliquant register avec WAMP" width="565" height="470" /></a><p class="wp-caption-text">RPC marche à l&#8217;envers de PUB/SUB. Un client expose du code, et un autre demande explicitement qu&#8217;il soit exécuté.</p></div>
<p>Côté appelant :</p>
<pre lang="javascript">ab.connect("ws://localhost:9000", function(session) {
    // on appelle la fonction à distance, on récupère une
    // promise qui nous permet de travailler sur le résultat
   session.call('une_fonction', 2, 3).then(
      function (res) {
         console.log(res);
      }
   );
</pre>
<div id="attachment_10348" style="width: 552px" class="wp-caption aligncenter"><a href="http://sametmax.com/wp-content/uploads/2014/05/call.png" class="grouped_elements" rel="tc-fancybox-group10329"><img class="size-full wp-image-10348" title="Contrairement à PUB/SUB, RPC ne concerne que deux clients à la fois. Mais ça reste asynchrone. Le client demandeur n'attend pas le résultat de l'appel de la fonction. Il est signalé par le serveur quand il est prêt." src="http://sametmax.com/wp-content/uploads/2014/05/call.png" alt="Schéma expliquant CALL en WAMP" width="542" height="548" /></a><p class="wp-caption-text">Contrairement à PUB/SUB, RPC ne concerne que deux clients à la fois. Mais ça reste asynchrone. Le client demandeur n&#8217;attend pas le résultat de l&#8217;appel de la fonction. Il est signalé par le serveur quand il est prêt.</p></div>
<p>Pareil que pour le PUB/SUB, les gens ont du mal à voir l&#8217;utilité à cause du trop de flexibilité que ça apporte. Imaginez que votre projet soit maintenant éclaté en de nombreux petits services qui tournent et qui sont indépendants :</p>
<ul>
<li>Un service pour le site Web.</li>
<li>Un service d&#8217;authentification.</li>
<li>Un service pour l&#8217;API.</li>
<li>Un service pour les tâches longues.</li>
<li>Un service de monitoring et administration technique.</li>
</ul>
<p>Tous ces services peuvent ainsi communiquer entre eux via RPC, mais n&#8217;ont pas besoin d&#8217;être dans le même processus. On peut profiter pleinement de tous les cœurs de sa machine, on peut même les mettre sur des serveurs séparés.</p>
<p>Mieux, avoir un service bloquant ne pénalise pas tout le système. En effet, un problème avec les systèmes asynchrones en Python est que beaucoup de libs sont encore bloquantes (typiquement les ORMs). <strong>Avec ce genre d&#8217;architecture, on peut créer un service qui ne fait que les appels bloquant et laisser les autres services non bloquant l&#8217;appeler de manière asynchrone.</strong> Pendant qu&#8217;il bloque, le reste du système peut traiter d&#8217;autres requêtes.</p>
<h2>Crossbar, plus qu&#8217;un routeur WAMP</h2>
<p>L&#8217;idée des concepteurs de crossbar est de permettre de créer des systèmes avec des services composables qui communiquent entre eux plutôt que tout dans un gros processus central. Ils ne se sont donc pas arrêtés au routing.</p>
<p>Crossar est également un gestionnaire de processus, comme <a href="https://pypi.python.org/pypi/supervisor/3.0">supervisor</a> ou, plus légitimement, <a href="https://pypi.python.org/pypi/circus/0.11.1">circus</a> (Tarek, fait une pause, vient ici !) et sa communication ZeroMQ.</p>
<p>Il se configure avec un simple fichier JSON, et on peut y définir des classes Python qui seront lancées dans un processus séparé et pourront discuter avec les autres clients via WAMP :</p>
<pre lang="javascript">{
   "processes": [
      { // premier processus
         "type": "worker",
         "modules": [
            {
               un_worker.Classe
            },
            {
               un_autre_worker.Classe
            }
         ]
      },
      {  // second processus
         "type": "worker",
         "modules": [
            {
               un_autre_worker_dans_un_autre_process.Classe
            }
         ]
      }
   ]
}</pre>
<p>Mais si ça ne suffit pas, on peut également lancer des programmes extérieurs non Python dont crossbar va gérer le cycle de vie :</p>
<pre lang="javascript">{
   "processes": [
      {
         "type": "guest",
         "executable": "/usr/bin/node",
         "arguments": ["votre_script.js"],
         "stdout": "log"
      }
   ]
}</pre>
<p>Vous avez donc ainsi les deux atouts pour avoir <strong>une architecture découplée, scalable, exploitant plusieurs cœurs, et compensant en partie les bibliothèques bloquantes</strong> :</p>
<ul>
<li>Un protocole flexible, simple, qui permet à tout le monde se parler entre eux (WAMP).</li>
<li>Une API qui permet soit de réagir à un changement (PUB/SUB), soit de demander une action (RPC).</li>
<li>Un programme qui gère cette communication, et le cycle de vie des composants qui parlent entre eux.</li>
</ul>
<h2>Cas concret</h2>
<p>WAMP est typiquement le genre de techno qui ne permet PAS de faire quelque chose qu&#8217;on ne faisait pas avant. Ce n&#8217;est pas nouveau.</p>
<p>En revanche, WAMP permet de le faire mieux et plus facilement.</p>
<p>Prenez le cas d&#8217;un utilisateur qui se connecte sur un forum. Il va sur un formulaire, il poste ses identifiants, ça recharge la page, il est connecté. Si les autres utilisateurs rechargent leurs pages, ils verront un utilisateur de plus connecté.</p>
<p>Si on veut rendre ça plus dynamique, il faut utiliser de l&#8217;AJAX, et si on veut avoir une mise à jour presque en temps réel, il faut faire des requêtes Ajax régulières. Ce qui est assez bancal et demande beaucoup de travail manuel.</p>
<p>Certains sites modernes utilisent Websocket, et des serveurs asynchrones comme NodeJS, et un routeur PUB/SUB comme Redis, pour faire cela de manière rapide et plus facile. L&#8217;application est très réactive. Mais le système est hétéroclite. Et si on veut envoyer des messages entre des composants serveurs, ça demande encore quelque chose de différent.</p>
<p>WAMP unifie tout ça. Un coup de RPC pour le login pour effectuer l&#8217;action:</p>
<div id="attachment_10351" style="width: 552px" class="wp-caption aligncenter"><a href="http://sametmax.com/wp-content/uploads/2014/05/rpc_concret.png" class="grouped_elements" rel="tc-fancybox-group10329"><img class="size-full wp-image-10351" title="Notez que le RPC marche de n'importe quel client à n'importe quel client. Il n'y a pas de sens obligatoire. Le login est un exemple simple mais on peut faire des choses bien plus complexes." src="http://sametmax.com/wp-content/uploads/2014/05/rpc_concret.png" alt="Schéma d'un exemple concret de RPC WAMP" width="542" height="592" /></a><p class="wp-caption-text">Notez que le RPC marche de n&#8217;importe quel client à n&#8217;importe quel client. Il n&#8217;y a pas de sens obligatoire. Le login est un exemple simple mais on peut faire des choses bien plus complexes.</p></div>
<p>Et un coup de PUB/SUB pour prévenir tout le monde que quelque chose s&#8217;est passé :</p>
<div id="attachment_10352" style="width: 549px" class="wp-caption aligncenter"><a href="http://sametmax.com/wp-content/uploads/2014/05/pub_sub_concret.png" class="grouped_elements" rel="tc-fancybox-group10329"><img class="size-full wp-image-10352" title="Je n'ai mis que des clients légers ici, mais je vous rappelle qu'un client peut être un serveur NodeJS, une base de données, un code C++..." src="http://sametmax.com/wp-content/uploads/2014/05/pub_sub_concret.png" alt="Schéma d'exemple concret de PUB/SUB avec WAMP" width="539" height="626" /></a><p class="wp-caption-text">Je n&#8217;ai mis que des clients légers ici, mais je vous rappelle qu&#8217;un client peut être un serveur NodeJS, une base de données, un code C++&#8230;</p></div>
<p>Bien entendu, on pourrait faire ça avec les technos existantes. C&#8217;est juste moins pratique.</p>
<p>Notez également que Crossbar encourage à avoir un service qui ne se charge que du login, sans avoir à faire une usine à gaz pour cela. Si demain votre service de login a besoin d&#8217;être sur un coeur/serveur/une VM séparé pour des raisons de perfs ou de sécurité, c&#8217;est possible. Crossbar encourage ce genre de design.</p>
<h2>Voici où est le piège</h2>
<p>Car évidement, il y en a toujours un, putain de métier à la con.</p>
<p><strong>Et c&#8217;est la jeunesse du projet.</strong></p>
<p>Le projet est stable, le code marche, et les sources sont propres.</p>
<p>Mais la doc, mon dieu la doc&#8230; Les exemples sont pas à jour, il y a deux versions qui se battent en duel, on sait pas trop quelle partie sert à quoi.</p>
<p>Et comme tout projet jeune, l&#8217;API n&#8217;a pas été assez étudiée. Or la partie Python est basée sur Twisted, sans polish. Twisted, c&#8217;est puissant, c&#8217;est solide, et c&#8217;est aussi une API dégueulasse.</p>
<p>Un exemple ? Comment écouter un événement :</p>
<pre lang="python"># Des imports légers
from twisted.python import log
from twisted.internet.defer import inlineCallbacks

from autobahn.twisted.wamp import ApplicationSession
from autobahn.twisted.wamp import ApplicationRunner

# Une bonne classe bien subtile pour copier Java
class ListenForEvent(ApplicationSession):

    # Deux méthodes de boiler plate obligatoires
    # et parfaitement soulantes pour l'utilisateur
    # final. Cachez moi ça bordel !
    def __init__(self, config):
        ApplicationSession.__init__(self)
        self.config = config

    def onConnect(self):
        self.join(self.config.realm)

    # Bon, on se décide, soit on fait une classe avec des noms
    # de méthode conventionnés, soit on met des décorateurs, 
    # mais pas les deux, pitié !
    @inlineCallbacks
    def onJoin(self, details):
        callback = lambda x: log.msg("Received event %s" % x)
        yield self.subscribe(callback, 'un_evenement')

# Python doit lancer explicitement un event loop.
# Ca pourrait (devrait) aussi être embeded dans une
# sousclasse de ApplicationSession.
# /me prend un colt. BANG !
if __name__ == '__main__':
   runner = ApplicationRunner(endpoint="tcp:127.0.0.1:8080",
                              url="ws://localhost:8080/ws",
                              realm="realm1")
   runner.run(ListenForEvent)
</pre>
<p>C&#8217;est la raison pour laquelle je vous ai montré le code JS et pas Python pour vous vendre le truc. Sur sametmax.com, on aura tout vu :(</p>
<p>Voilà à quoi devrait ressembler le code Python si l&#8217;API était mature :</p>
<pre lang="python">from autobahn.app import App

app = App(url="ws://localhost:8080/ws")

@event("un_evenement")
def handle(details):
    app.log("Received event %s" % x)

if __name__ == '__main__':
   app.run()</pre>
<p>Chose que je vais proposer sur <a href="https://groups.google.com/forum/#!forum/autobahnws">la mailing list</a> (ils sont réactifs et sympas, vive les allemands !) dans pas longtemps. Et si ils n&#8217;ont pas le temps de le faire, il est possible que je m&#8217;y colle. Ca me fait mal aux yeux.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/crossbar-le-futur-des-applications-web-python/feed/</wfw:commentRss>
		<slash:comments>32</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">10329</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2014/05/GVHFg8t.jpg" length="39594" type="image/jpg" />	</item>
		<item>
		<title>Un petit goût de meteor.js en Python</title>
		<link>http://sametmax.com/un-petit-gout-de-meteor-js-en-python/</link>
		<comments>http://sametmax.com/un-petit-gout-de-meteor-js-en-python/#comments</comments>
		<pubDate>Thu, 06 Mar 2014 10:37:34 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[autobahn]]></category>
		<category><![CDATA[html]]></category>
		<category><![CDATA[javascript]]></category>
		<category><![CDATA[meteojs]]></category>
		<category><![CDATA[pub/sub]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[websocket]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=9703</guid>
		<description><![CDATA[Depuis quelques temps, un standard est en train d'émerger autour du RPC et PUB/SUB entre navigateurs et serveurs : <a href="http://wamp.ws/">WAMP</a>. Il existe du coup des implémentations du protocole en plusieurs langages, donc une en Python avec <a href="http://autobahn.ws/python/">autobahn</a>.]]></description>
				<content:encoded><![CDATA[<p>Je n&#8217;ai jamais caché ma jalousie envers les codeurs Javascript sous <a href="https://www.meteor.com/">meteor.js</a>. C&#8217;est à mon sens la techno la plus révolutionnaire en matière de dev Web depuis l&#8217;invention des frameworks HTTP.</p>
<p>Ca permet notamment de faire du PUB/SUB entre le navigateur et le serveur. C&#8217;est à dire qu&#8217;un navigateur déclenche un événement, le serveur le reçoit, et tous les browsers abonnés le reçoivent aussi. Du coup, on modifie une page, toutes les autres pages sont modifiées en temps réel.</p>
<p>Dommage que ce soit codé dans un langage pourri.</p>
<p>Heureusement depuis quelques temps, un standard est en train d&#8217;émerger autour du RPC et PUB/SUB entre navigateurs et serveurs : <a href="http://wamp.ws/">WAMP</a>. Il existe du coup des implémentations du protocole en plusieurs langages, donc une en Python avec <a href="http://autobahn.ws/python/">autobahn</a>.</p>
<p>Ca s&#8217;utilise ainsi : <code><a href="http://sametmax.com/votre-python-aime-les-pip/">pip</a> install autobahn</code>.</p>
<p>Puis, un petit coup de Python :</p>
<pre lang="python">import sys

from twisted.python import log
from twisted.internet import reactor

from autobahn.twisted.websocket import listenWS

from autobahn.wamp1.protocol import WampServerFactory, WampServerProtocol


class MyPubSubServerProtocol(WampServerProtocol):
    def onSessionOpen(self):
        # On choisit un namespace pour enregistrer ses events PUB/SUB
        self.registerForPubSub("http://example.com/events/bam")

if __name__ == '__main__':
   # on lance notre serveur avec moult verbosité
   log.startLogging(sys.stdout)
   wampFactory = WampServerFactory("ws://127.0.0.1:9000", debugWamp=True)
   wampFactory.protocol = MyPubSubServerProtocol
   listenWS(wampFactory)
   reactor.run()</pre>
<p>On lance le serveur directement :</p>
<pre lang="bash">python votre_script.py</pre>
<p>Côté client (pas besoin de serveur, on peut l&#8217;ouvrir dans le browser cash pistache) :</p>
<pre lang="html"><!DOCTYPE html>
<html>
  <head>
    <script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
    <script src="https://raw.github.com/tavendo/AutobahnPython/master/examples/twisted/wamp1/pubsub/simple/example1/autobahn.min.js"></script>
    <script type="text/javascript">

    $(function(){
        ab.connect("ws://localhost:9000", function(session) {

            $('#foo').click(function(){
                // au clic sur le bouton, on envoit un evenement BAM
                session.publish('http://example.com/events/bam', ['bam']);

                // On ajoute bam à la liste en local car le publisher ne
                // reçoit pas ses propres events
                $('#doh').append('<li>bam</li>');
            });

            session.subscribe('http://example.com/events/bam', function(topic, evt){
                // on s'inscrit pour recevoir l'event quand il est
                // déclenché. Ceci marchera dans tout autre tab que celui
                // qui a déclenché l'event
                $('#doh').append('<li>bam</li>');
            });
        })

    });

    </script>

</head>

<body>

<!-- Notre liste qui va se remplir de bam ! -->
<ul id="doh"></ul>
<button id="foo" value="Bam">Bam</button>

</body>
</html></pre>
<p>Ce qui ce passe, c&#8217;est que quand j&#8217;appuie sur le bouton &#8220;Bam&#8221;, ça envoit un événement Bam au serveur via Websocket, qui propage l&#8217;événement à tous les clients. Donc tous les tabs ouverts sur cette page récupèrent l&#8217;événement et peuvent y réagir. Ici, les deux pages sont mises à jour en simultané. </p>
<div id="attachment_9705" style="width: 610px" class="wp-caption aligncenter"><a href="http://sametmax.com/wp-content/uploads/2014/03/out.gif" class="grouped_elements" rel="tc-fancybox-group9703"><img src="http://sametmax.com/wp-content/uploads/2014/03/out.gif" alt="Mise à jour de deux pages web en simultané avec autobahn" title="Chez moi ça marche" width="600" height="160" class="size-full wp-image-9705" /></a><p class="wp-caption-text">Chez moi ça marche</p></div>
<p>Bien entendu, ceci est un exemple très basique fait pour vous donner un avant goût de la techno. D&#8217;ailleurs, meteor.js, c&#8217;est bien plus que du PUB/SUB. Il y a de la gestion de la deco, la synchro de la base côté client, le hot push de code, etc. Ils ont fait un vrai travail de fond sur les problématiques concrètes. </p>
<p>Donc on en est encore loin, surtout que même leur techno est toujours expérimentale. Mais on a enfin de quoi rattraper le temps perdu. Et avec asyncio, îl n&#8217;y aura même pas besoin de dépendre de twisted pour ce faire. 2014 va être trop fun !</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/un-petit-gout-de-meteor-js-en-python/feed/</wfw:commentRss>
		<slash:comments>30</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">9703</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2014/03/out.gif" length="52202" type="image/jpg" />	</item>
	</channel>
</rss>
