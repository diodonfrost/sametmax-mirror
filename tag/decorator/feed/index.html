<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" >

<channel>
	<title>decorator &#8211; Sam &amp; Max</title>
	<atom:link href="http://sametmax.com/tag/decorator/feed/" rel="self" type="application/rss+xml" />
	<link>http://sametmax.com</link>
	<description>Du code, du cul</description>
	<lastBuildDate>Thu, 05 Sep 2019 08:22:03 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.7</generator>
<site xmlns="com-wordpress:feed-additions:1">32490438</site>	<item>
		<title>Un décorateur pour accepter les callbacks en Python</title>
		<link>http://sametmax.com/un-decorateur-pour-accepter-les-callbacks-en-python/</link>
		<comments>http://sametmax.com/un-decorateur-pour-accepter-les-callbacks-en-python/#comments</comments>
		<pubDate>Mon, 12 Aug 2013 10:03:44 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[callback]]></category>
		<category><![CDATA[decorator]]></category>
		<category><![CDATA[python]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=7081</guid>
		<description><![CDATA[Un des événements auxquels on veut réagir le plus souvent, c'est l'appel d'une fonction, donc en gros être capable de fournir un callback quand on fonction est appelée. On peut bien entendu coder la logique du callback dans chaque fonction et méthode que l'on met en œuvre, mais avec un peu d'astuce, on peu trouver une solution générique qui va couvrir Pareto des besoins.]]></description>
				<content:encoded><![CDATA[<p>Si vous lisez assidûment ce blog, et je n&#8217;en doute pas car il est génial, vous savez ce qu&#8217;est un <a href="http://sametmax.com/comprendre-les-decorateurs-python-pas-a-pas-partie-1/">décorateur</a> et un <a href="http://sametmax.com/quest-ce-quun-callback/">callback</a>. On a même vu comment<a href="http://sametmax.com/le-pattern-observer-en-utilisant-des-decorateurs/"> créer un système de gestion d&#8217;événements</a> en utilisant ces deux concepts.</p>
<p>Un des événements auxquels on veut réagir le plus souvent, c&#8217;est l&#8217;appel d&#8217;une fonction, donc en gros être capable de fournir un callback quand une fonction est appelée. On peut bien entendu coder la logique du callback dans chaque fonction et méthode que l&#8217;on met en œuvre, mais avec un peu d&#8217;astuce, on peut trouver une solution générique qui va couvrir Pareto des besoins.</p>
<p>L&#8217;idée, c&#8217;est donc de coder un décorateur :</p>
<pre lang="python">def accept_callbacks(func):

    # on va stocker tous les callbacks là dedans
    callbacks = []

    @wraps(func)
    def wrapper(*args, **kwargs):
        
        # on appelle la fonction originale
        result = func(*args, **kwargs)

        # on appelle ensuite chaque callback en lui passant le resultat 
        # de la fonction ainsi que les paramètres qui avaient été passés
        for callback in callbacks:
            callback(result, *args, **kwargs)
        
        # et on retourne le résultat
        return result

    # on attache la liste des callbacks au wrapper pour y avoir accès depuis
    # l'extérieur
    wrapper.callbacks = callbacks

    return wrapper</pre>
<p>Du coup, pour accepter des callbacks sur une fonction, il suffit de décorer la fonction :</p>
<pre lang="python">@accept_callbacks
def add(a, b):
    return a + b</pre>
<p>Ensuite on écrit son callback avec la signature qui va bien :</p>
<pre lang="python">def mon_callback(result, a, b):
    print("Ma fonction a été appelée avec a=%s et b=%s !" % (a, b))
    print("Elle a retourné le résultat '%s'" % result)</pre>
<p>Et pour ajouter un callback, c&#8217;est juste une insertion dans la liste :</p>
<pre lang="python">add.callbacks.append(mon_callback)</pre>
<p>Derrière, chaque appel de la fonction va appeler également tous les callbacks :</p>
<pre lang="python">print(add(1, 1))
## Ma fonction a été appelée avec a=1 et b=1 !
## Elle a retourné le résultat '2'
## 2

print(add(42, 69))
## Ma fonction a été appelée avec a=42 et b=69 !
## Elle a retourné le résultat '111'
## 111

add.callbacks.remove(mon_callback)

print(add(0, 0))
# 0</pre>
<p>Et le plus fun, c&#8217;est que ça marche aussi sans rien modifier avec les méthodes :</p>
<pre lang="python">def autre_callback(result, self, truc_important):
    print("Ma fonction a été appelée avec truc_important=%s !" % truc_important)
    print("Elle a retourné '%s'" % result)


class CaMarcheAussiAvecUneClass(object):

    def __init__(self, repeat=1):
        self.repeat = repeat

    @accept_callbacks
    def puisque_une_classe_a_des_methodes(self, truc_important):
        return truc_important.upper() * self.repeat


CaMarcheAussiAvecUneClass.puisque_une_classe_a_des_methodes.callbacks.append(autre_callback)

instance1 = CaMarcheAussiAvecUneClass()
instance2 = CaMarcheAussiAvecUneClass(2)

print(instance1.puisque_une_classe_a_des_methodes("Le fromage de chèvre"))
## Ma fonction a été appelée avec truc_important=Le fromage de chèvre !
## Elle a retourné 'LE FROMAGE DE CHÈVRE'
## LE FROMAGE DE CHÈVRE

print(instance2.puisque_une_classe_a_des_methodes("Les perforeuses"))
## Ma fonction a été appelée avec truc_important=Les perforeuses !
## Elle a retourné 'LES PERFOREUSESLES PERFOREUSES'
## LES PERFOREUSESLES PERFOREUSES</pre>
<p>Par contre, si on veut qu&#8217;un callback ne s&#8217;active que pour une instance donnée, alors il faut ruser un peu :</p>
<pre lang="python"># le retrait d'un callback, c'est un simple retrait de la liste
CaMarcheAussiAvecUneClass.puisque_une_classe_a_des_methodes.callbacks.remove(autre_callback)

def callback_pour_une_instance(result, self, truc_important):
    # on check que l'instance est celle que l'on veut
    if self is instance1:
        print("Ma fonction a été appelée avec truc_important=%s !" % truc_important)
        print("Elle a retourné '%s'" % result)

CaMarcheAussiAvecUneClass.puisque_une_classe_a_des_methodes.callbacks.append(callback_pour_une_instance)

print(instance1.puisque_une_classe_a_des_methodes("Les points noirs des coccinelles"))
## Ma fonction a été appelée avec truc_important=Les points noirs des coccinelles !
## Elle a retourné 'LES POINTS NOIRS DES COCCINELLES'
## LES POINTS NOIRS DES COCCINELLES

print(instance2.puisque_une_classe_a_des_methodes("Les panneaux sens uniques"))
## LES PANNEAUX SENS UNIQUESLES PANNEAUX SENS UNIQUES</pre>
<p>Niveau perf, ce n&#8217;est pas optimal, et bien sûr, l&#8217;appel des callbacks est synchrone et blocant. Ce n&#8217;est pas un souci dans 90 % des cas, pour les autres cas, vous devrez faire le truc à la main. En même temps, dès qu&#8217;on a des problèmes de perf, les codes génériques fonctionnent rarement.</p>
<p>Je vais peut être rajouter ça dans <a href="sametmax.com/batbelt-la-lib-des-petits-outils-python-qui-vont-bien/">batbelt</a> moi&#8230;</p>
<hr />
<p><a href="https://github.com/sametmax/codes-des-articles/blob/master/2013/aout/accept_callbacks.py">Télécharger le code de l&#8217;article</a></p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/un-decorateur-pour-accepter-les-callbacks-en-python/feed/</wfw:commentRss>
		<slash:comments>3</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">7081</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2013/08/xYfIFmB.jpg" length="250944" type="image/jpg" />	</item>
		<item>
		<title>Créer un décorateur à la volée</title>
		<link>http://sametmax.com/creer-un-decorateur-a-la-volee/</link>
		<comments>http://sametmax.com/creer-un-decorateur-a-la-volee/#comments</comments>
		<pubDate>Fri, 12 Jul 2013 05:39:00 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[decorator]]></category>
		<category><![CDATA[python]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=6624</guid>
		<description><![CDATA[Sur les décorateurs, normalement, vous avez <a href="http://sametmax.com/comprendre-les-decorateurs-python-pas-a-pas-partie-1/">tout ce qu'il faut</a> pour être au point.

Néanmoins en informatique la moitié de la connaissance, c'est l'usage, pas la fonctionnalité. Car il y beaucoup d'usages auxquels on ne pense pas.]]></description>
				<content:encoded><![CDATA[<p>Sur les décorateurs, normalement, vous avez <a href="http://sametmax.com/comprendre-les-decorateurs-python-pas-a-pas-partie-1/">tout ce qu&#8217;il faut</a> pour être au point.</p>
<p>Néanmoins en informatique la moitié de la connaissance, c&#8217;est l&#8217;usage, pas la fonctionnalité. Car il y beaucoup d&#8217;usages auxquels on ne pense pas.</p>
<p>Particulièrement, je vous avais déjà expliqué que les fonctions étaient des objets comme les autres en Python, et qu&#8217;on pouvait donc les créer à la volée, les retourner, les passer en paramètre, et même leur coller des attributs.</p>
<p>Or les décorateurs ne sont jamais que des fonctions.</p>
<p>Maintenant, souvenez vous, le décorateurs <a href="http://sametmax.com/le-guide-ultime-et-definitif-sur-la-programmation-orientee-objet-en-python-a-lusage-des-debutants-qui-sont-rassures-par-les-textes-detailles-qui-prennent-le-temps-de-tout-expliquer-partie-2/">property</a> permet de faire ceci :</p>
<pre lang="python">class Mamouth(object):

    _valeur = "3 calots"

    @property
    def valeur(self):
        return self._valeur.upper()

    @valeur.setter
    def valeur(self, valeur):
        self._valeur = valeur.strip()

>>> bille = Mamouth()
>>> bille.valeur
u'3 CALOTS'
>>> bille.valeur = "une pépite           "
>>> bille.valeur
>>> print(bille.valeur)
UNE PÉPITE</pre>
<p>La syntaxe qui doit attirer votre attention est <code>@valeur.setter</code>. En effet, d&#8217;où vient ce décorateur ?</p>
<p>On comprend mieux ce qui s&#8217;est passé avec ce test :</p>
<pre lang="python">>>> Mamouth.valeur.setter
<built-in method setter of property object at 0x1a1baf8></pre>
<p><code>setter</code> est tout simplement un attribut de la méthode <code>valeur</code>. Par ailleurs, c&#8217;est une fonction et un décorateur.</p>
<p>Pourquoi faire cela ? Et bien tout simplement parce que cela permet d&#8217;attacher une fonction qui ne sert que dans un cas (ici ça ne sert qu&#8217;à créer le setter de la propriété <code>valeur</code>) à son contexte.</p>
<p>Bien entendu vous pouvez faire ça vous même, il suffit de le vouloir très fort et de croire en le pouvoir de l&#8217;amour.</p>
<p>Par exemple, imaginez un décorateur qui permet d&#8217;attacher un comportement de sérialisation à une fonction. On ne veut pas modifier la fonction, mais on veut qu&#8217;elle puisse automatiquement, pour quelques caractères de plus, pouvoir aussi retourner du JSON ou du pickle.</p>
<pre lang="python">import json
import pickle

def serializable(func):

    # Contrairement à la plupart des décorateurs, on ne va pas retourner
    # un wrapper, mais bien la fonction originale. Simplement on lui aura ajouté
    # des attributs

    func.as_json = lambda *a, **k: json.dumps(func(*a, **k))
    func.as_pickle = lambda *a, **k: pickle.dumps(func(*a, **k))

    return func</pre>
<p>Et ça s&#8217;utilise ainsi :</p>
<pre lang="python">import locale

from calendar import TimeEncoding, day_name, day_abbr

# obtenir les noms de jours localisés est complètement rocambolesque en python
def get_day_name(day_number, locale, short=False):
    """
        Retourne le nom d'un jour dans la locale sélectionnée.

        Exemple :

        >>> get_day_name(0,  ('fr_FR', 'UTF-8'))
        'lundi'
    """
    with TimeEncoding(locale) as encoding:
        s = day_abbr[day_number] if short else day_name[day_number]
        return s.decode(encoding) if encoding is not None else s

@serializable
def get_days_names(locale=locale.getdefaultlocale(), short=False):
    """
        Un dictionnaire contenant un mapping entre les numéros des jours
        de semaine et leurs noms selon la locale donnée.
    """

    return {i: get_day_name(i, locale) for i in xrange(7)}</pre>
<p>En usage ordinaire, la fonction retourne bien ce qui est prévu :</p>
<pre lang="python">>>> get_days_names()
{0: 'lundi', 1: 'mardi', 2: 'mercredi', 3: 'jeudi', 4: 'vendredi', 5: 'samedi', 6: 'dimanche'}
>>> get_days_names(locale=('en_US', 'UTF-8'))
{0: 'Monday', 1: 'Tuesday', 2: 'Wednesday', 3: 'Thursday', 4: 'Friday', 5: 'Saturday', 6: 'Sunday'}
</pre>
<p>Mais on peut choisir le format à la sortie :</p>
<pre lang="python">>>> get_days_names.as_json()
'{"0": "lundi", "1": "mardi", "2": "mercredi", "3": "jeudi", "4": "vendredi", "5": "samedi", "6": "dimanche"}'
>>> get_days_names.as_pickle(locale=('en_US', 'UTF-8'))
"(dp0\nI0\nS'Monday'\np1\nsI1\nS'Tuesday'\np2\nsI2\nS'Wednesday'\np3\nsI3\nS'Thursday'\np4\nsI4\nS'Friday'\np5\nsI5\nS'Saturday'\np6\nsI6\nS'Sunday'\np7\ns."</pre>
<p>Ici, on a attacher une fonction à une autre fonction, en mettant la deuxième dans un attribut de la première.</p>
<p>Comme les décorateurs sont des fonctions, rien ne vous empêche de faire pareil avec un décorateur, et c&#8217;est de cette manière que <code>@property</code> attache un décorateur <code>setter</code> à chaque méthode.</p>
<hr />
<a href="https://github.com/sametmax/codes-des-articles/blob/master/2013/juillet/functions_as_functions_attributes.py"><br />
Télécharger le code des articles</a></p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/creer-un-decorateur-a-la-volee/feed/</wfw:commentRss>
		<slash:comments>7</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">6624</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2013/07/ZbYZ9jq.jpg" length="56894" type="image/jpg" />	</item>
		<item>
		<title>Batbelt, la lib des petits outils Python qui vont bien</title>
		<link>http://sametmax.com/batbelt-la-lib-des-petits-outils-python-qui-vont-bien/</link>
		<comments>http://sametmax.com/batbelt-la-lib-des-petits-outils-python-qui-vont-bien/#comments</comments>
		<pubDate>Mon, 03 Jun 2013 08:57:33 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[decorator]]></category>
		<category><![CDATA[iterable]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[snippets]]></category>
		<category><![CDATA[with]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=6327</guid>
		<description><![CDATA[A force de coder plein de projets, il y a des opérations qui reviennent très souvent. Ces traitements sont petits et complètement sans relation, difficile d'en faire quelque chose. J'ai tout de même finit par en faire un lib, batbelt, qui au final n'est qu'une grosse collections de snippets que j'utilise régulièrement.]]></description>
				<content:encoded><![CDATA[<p>A force de coder plein de projets, il y a des opérations qui reviennent très souvent. Ces traitements sont petits et complètement sans relation, difficile d&#8217;en faire quelque chose. J&#8217;ai tout de même finit par en faire un lib, <a href="https://github.com/sametmax/Bat-belt/">batbelt</a>, qui au final n&#8217;est qu&#8217;une grosse collections de snippets que j&#8217;utilise régulièrement. Il y a aussi des trucs que j&#8217;utilise moins ou des astuces / hacks un peu crades, c&#8217;est toujours pratique pour geeker à l&#8217;arrache vite fait. Vous allez d&#8217;ailleurs retrouver des bouts de code dont j&#8217;ai déjà parlé sur le site</p>
<p><code><a href="http://sametmax.com/votre-python-aime-les-pip/">pip</a> install batbelt</code></p>
<p>Et la plupart des fonctions sont accessible avec un <code>from batbelt import...</code></p>
<p>Voici les choses qui pourraient vous intéresser le plus dans batbelt&#8230;</p>
<h2>To timestamp</h2>
<p>Mais combien de fois j&#8217;ai du la coder celle-là ? En plus l&#8217;inverse existe, alors pourquoi, mon Dieu, pourquoi ?</p>
<pre lang="python">>>> from datetime import datetime
>>> to_timestamp(datetime(2000, 1, 1, 2, 1, 1))
946692061
>>> datetime.fromtimestamp(946688461) # tu as codé celle là et pas l'autre connard !
datetime.datetime(2000, 1, 1, 2, 1, 1)</pre>
<h2>Récupérer une valeur dans une structure de données imbriquée</h2>
<p>Au lieu de faire :</p>
<pre lang="python">try:
    res = data['cle'][0]['autre cle'][1]
except (KeyError, IndexError):
    res = "valeur"
    </pre>
<p>On peut faire :</p>
<pre lang="python">get(data, 'cle', 0, 'autre cle', 1, default="valeur")</pre>
<h2>Récupérer la valeur d&#8217;un attribut dans un attribut dans un attribut&#8230;</h2>
<p>Pareil, mais pour les attributs.</p>
<pre lang="python">try:
    devise = voiture.moteur.prix.devise
except AttributeError:
    devise = "euro"</pre>
<p>On peut faire :</p>
<pre lang="python">devise = attr(voiture, 'moteur', 'prix', 'devise', default='euro')</pre>
<h2>Itérons, mon bon</h2>
<p>Ces fonctions retournent des générateurs qui permettent d&#8217;itérer par morceau ou par fenêtre glissante.</p>
<pre lang="python">>>> for chunk in chunks(l, 3):
...     print list(chunk)
...
[0, 1, 2]
[3, 4, 5]
[6, 7, 8]
[9]
>>> for slide in window(l, 3):
...     print list(slide)
...
[0, 1, 2]
[1, 2, 3]
[2, 3, 4]
[3, 4, 5]
[4, 5, 6]
[5, 6, 7]
[6, 7, 8]
[7, 8, 9]</pre>
<p>Ça devrait être en standard dans Python.</p>
<p>Parfois on veut juste le premier élément d&#8217;une collection. Ou juste le premier à être vrai:</p>
<pre lang="python">>>> first(xrange(10))
0
>>> first_true(xrange(10))
1</pre>
<p>Marche avec n&#8217;importe quel itérable, contrairement à <code>[0]</code> qui ne marche que sur les indexables. Et en prime on peut spécifier une valeur par défaut:</p>
<pre lang="python">>>> first([], default="What the one thing we say to the God of Death ?")
'What the one thing we say to the God of Death ?'</pre>
<h2>Set ordonné</h2>
<p>On a des dicts ordonnés dans la lib standard, mais pas de set ordonné. On en a pas besoin souvent, mais ça peut être TRES pratique, et TRES chiant à implémenter soi-même.</p>
<p>Donc acte.</p>
<pre lang="python">>>> for x in set((3, 2, 2, 2, 1, 2)): # booooooo
...     print x
...
1
2
3
>>> for x in sset((3, 2, 2, 2, 1, 2)): # clap clap !
...     print x
...
3
2
1</pre>
<p>Attention, c&#8217;est pas la structure de données la plus rapide du monde&#8230;</p>
<h2>Je suis une feignasse et j&#8217;aime les one-liners sur les dicos</h2>
<p>Je ne comprends pas pourquoi <code>+</code> ne fonctionne pas sur les dico.</p>
<pre lang="python">>>> dmerge({"a": 1, "b": 2}, {"b": 2, "c": 3})
{'a': 1, 'c': 3, 'b': 2}</pre>
<p>Ne modifie pas les dictionnaires originaux.</p>
<pre lang="python">>>> from batbelt.structs import rename
>>> rename({"a": 1, "b": 2})
>>> rename({"a": 1, "b": 2}, 'b', 'z')
{u'a': 1, u'z': 2}</pre>
<p>Modifie le dictionnaire original et n&#8217;est PAS thread safe.</p>
<p>Et le cas tordu mais tellement satisfaisant :</p>
<pre lang="python">>>> from batbelt.structs import unpack
>>> dct = {'a': 2, 'b': 4, 'z': 42}
>>> a, b, c = unpack(dct, 'a', 'b', 'c', default=1)
>>> a
2
>>> b
4
>>> c
1
</pre>
<h2>Slugifier</h2>
<pre lang="python">>>> slugify(u"Hélo Whorde")
helo-whorde</pre>
<p>Il y a pas mal de réglages possibles avec <code>slugify()</code>, mais je vous laisse les découvrir :-) Cette fonction fait partie du sous-module <code>strings</code>, qui contient d&#8217;autres utilitaires comme <code>escape_html/unescape_html</code> (qui transforme les caractères spéciaux en HTML entities et inversement) ou <code>json_dumps/json_loads</code> (qui fait un dump / load du JSON en prenant en compte le type <codde>datetime</codde>).</p>
<h2>Importer une classe ou une fonction depuis une string</h2>
<p>Dès que vous faites un fichier de config vous avez besoin de ce genre de truc, mais la fonction <code>__import__</code> a une signature uber-zarb. Voici une version beaucoup plus simple:</p>
<pre lang="python">TaClasse = import_from_path('foo.bar.TaClasse')
ton_obj = TaClasse()</pre>
<h2>Capturer les prints</h2>
<p>Parfois on a une lib qui <code>print</code> plutôt que de retourner une valeur. C&#8217;est très chiant. J&#8217;ai donc fait un context manager qui permet de récupérer tout ce qui est printé dans le block du <code>with</code>.</p>
<pre lang="python">>>> with capture_ouput() as (stdout, stderr):
...    print "hello",
...
>>> print stdout.read()
hello</pre>
<h2>Créer un décorateur qui accepte des arguments</h2>
<p>Même dans le cas où vous avez parfaitement compris les décorateurs grâce à un très <a href="http://sametmax.com/comprendre-les-decorateurs-python-pas-a-pas-partie-1/">bon tuto</a> (^^), se souvenir de comment faire un décorateur qui attend des arguments en paramètre, c&#8217;est mission impossible. Voici donc un décorateur&#8230; pour créer un décorateur.</p>
<p>Étape un, écrire votre décorateur :</p>
<pre lang="python"># tout les arguments après 'func' sont ceux que votre décorateur acceptera
@decorator_with_args()
def votre_decorateur(func, arg1, arg2=None):

    if arg1:
        # faire un truc

    # ici on fait juste le truc habituel des décorateurs
    # wrapper, appel de la fonction wrappée et retour du wrapper...
    def wrapper():
        # arg2 est dans une closure, on peut donc l'utiliser dans
        # la fonction appelée
        return func(arg2)


    return wrapper</pre>
<p>Et on peut utiliser son décorateur tranquile-bilou :</p>
<pre lang="python">@votre_decorateur(False, 1)
def hop(un_arg):
    # faire un truc dans la fonction décorée</pre>
<h2>Les processus parallèles finissent toujours par se rencontrer à l&#8217;infini et corrompre leurs données</h2>
<p>Mais en attendant on en a quand même besoin. Parfois un petit worker, c&#8217;est sympa, pas besoin de faire compliqué et de sortir des libs de task queue complètes:</p>
<pre lang="python">

from batbelt.parallel import worker

@worker()
def une_tache(arg):
    # faire un truc avec arg
    arg = arg + 10
    return arg


# on demarre le worker
process = une_tache.start()

# on balance des tâches au worker
for x in range(10):
    process.put(x)

# on récupère les résultats (optionnel)
# ca peut être dans un fichier différent
for x in range(10):
    print process.get()

## 10
## 11
## 12
## 13
## 14
## 15
## 16
## 17
## 18
## 19

# on arrête le worker
process.stop()</pre>
<p>Le worker est un subprocess par défaut, mais vous pouvez en faire un thread avec @worker(method=&#8221;tread&#8221;). Toujours utile, par exemple pour avec un processeur de mails qui envoit tous les mails hors du cycle requête / réponse de votre site Web. Par contre si votre process meurt la queue est perdue.</p>
<h2>Template du pauvre</h2>
<p>Avec format(), on a déjà un mini-langage de template intégré. Pas de boucle, mais pour des tâches simples ça suffit. Du coup j&#8217;ai une fonction <code>render()</code> qui prend un fichier de template au format string Python et qui écrit le résultat dans un autre. Pratique pour faire des fichiers de conf configurable.</p>
<pre lang="python">from batbelt.strings import render

render('truc.conf.tpl', {"var": "value"}, "/etc/truc.conf")</pre>
<p>Il y a aussi des implémentations de Singleton, du Null Pattern, etc. Mais ça s&#8217;utilise moins souvent alors je vais pas faire une tartine.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/batbelt-la-lib-des-petits-outils-python-qui-vont-bien/feed/</wfw:commentRss>
		<slash:comments>15</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">6327</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2013/06/7ZNvVOR.jpg" length="296662" type="image/jpg" />	</item>
		<item>
		<title>Le pattern observer en utilisant des décorateurs</title>
		<link>http://sametmax.com/le-pattern-observer-en-utilisant-des-decorateurs/</link>
		<comments>http://sametmax.com/le-pattern-observer-en-utilisant-des-decorateurs/#comments</comments>
		<pubDate>Sun, 14 Oct 2012 15:03:07 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[decorator]]></category>
		<category><![CDATA[design pattern]]></category>
		<category><![CDATA[observer]]></category>
		<category><![CDATA[python]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=2591</guid>
		<description><![CDATA[Nous avons vu précédemment que les décorateurs permettaient d’exécuter du code avant et après une fonction, sans modifier la fonction. La plupart du temps on retourne ainsi une nouvelle fonction embarquant un nouveau code.

Mais il existe d'autres usages pour les décorateurs, et notamment un qui est au cœur du fonctionnement de django-quicky: l'abonnement.
]]></description>
				<content:encoded><![CDATA[<p>Nous avons vu précédemment que les <a href="http://sametmax.com/comprendre-les-decorateurs-python-pas-a-pas-partie-1/">décorateurs</a> permettaient d’exécuter du code avant et après une fonction, sans modifier la fonction. La plupart du temps on retourne ainsi une nouvelle fonction avec un comportement différent.</p>
<p>Mais il existe d&#8217;autres usages pour les décorateurs, et notamment un qui est au cœur du fonctionnement de <a href="http://sametmax.com/django-quicky-labolition-des-preliminaires-par-sam-et-max/">django-quicky</a>: l&#8217;abonnement.</p>
<pre lang="python">
def evenement(nom):

    # on assure que la liste des events et callabcks est initialisae
    evenement.abonnements = getattr(evenement, 'abonnements', {})

    # on ajoute un moyen d'appeler tous les callbacks pour un event
    evenement.trigger = lambda e: [f(e) for f in evenement.abonnements[e]] 

    # définition du décorateur lui-même
    def decorateur(func):

        # on ajoute la fonction comme callback pour cet event
        evenement.abonnements.setdefault(nom, []).append(func)

        # et on retourne la fonction telle qu'elle, sans la modifier
        return func

    return decorateur</pre>
<p>Ce morceaux de code s&#8217;utilise ainsi:</p>
<pre lang="python">
# a chaque fois qu'on met le decorateur
# la fonction est liae à un événement
@evenement('evenement1')
@evenement('evenement2')
def reagir_a_evenement(evenement):
    # la fonction doit acccepter l'evenement en paramètre
    print "Oh, evenement '%s' a eu lieu" % evenement

@evenement('evenement1')
def moi_aussi(evenement):
    print "Cool, moi aussi j'ai reagit a l'evenement '%s'" % evenement

# ici on déclenche l'événement sans raison
# mais dans du vrai code on le déclenche à la suite
# d'une action réelle
evenement.trigger('evenement1')
evenement.trigger('evenement2')</pre>
<p>Ici c&#8217;est un exemple simplifié, mais le principe y est: chaque fois qu&#8217;on utilise un décorateur, on associe la fonction décorée à un nom (ici le nom de notre événement, mais dans django-quicky, c&#8217;est l&#8217;url). Et quand l&#8217;événement se produit, on appelle toutes les fonctions enregistrées, en leur passant l&#8217;objet événement (ici une simple string) en paramètres.</p>
<p>Avec ce design pattern appelé &#8216;observer&#8217;, on découple complètement le code qui déclenche un événement (la lecture d&#8217;un fichier, une erreur, un entrée utilisateur, etc) et le code qui réagit à cet événement (qui peut très bien être celui d&#8217;une lib complètement séparée).</p>
<p>Le décorateur Python est un moyen particulièrement pratique de déclarer un abonnement d&#8217;une fonction à un événement, et ne demande quasiment aucun effort de la part du développeur qui l&#8217;utilise à part d&#8217;avoir une fonction qui accepte les bons paramètres pour réagir à tous les événements que peuvent produire votre library. </p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/le-pattern-observer-en-utilisant-des-decorateurs/feed/</wfw:commentRss>
		<slash:comments>7</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">2591</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2012/10/erection.jpg" length="12928" type="image/jpg" />	</item>
		<item>
		<title>Les context managers et le mot clé with en Python</title>
		<link>http://sametmax.com/les-context-managers-et-le-mot-cle-with-en-python/</link>
		<comments>http://sametmax.com/les-context-managers-et-le-mot-cle-with-en-python/#comments</comments>
		<pubDate>Mon, 03 Sep 2012 17:56:43 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[contextmanager]]></category>
		<category><![CDATA[decorator]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[with]]></category>
		<category><![CDATA[yield]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=1987</guid>
		<description><![CDATA[Le mot clé <code>with</code> est utilisé comme dans aucun autre langage en Python. Au premier abord mystérieux, il agit en fait comme les <a href="http://sametmax.com/comprendre-les-decorateurs-python-pas-a-pas-partie-1/">décorateurs</a> en permettant d'exécuter du code automatiquement avant et après un autre code. Mais à l'image des décorateurs, tout ce qu'il fait pourrait être écrit à la main sans utiliser le mot clé <code>with</code>. Utiliser <code>with</code> est <a href="http://sametmax.com/jadore-les-context-managers-python/">une question de style</a>.
]]></description>
				<content:encoded><![CDATA[<p>Le mot clé <code>with</code> est utilisé comme dans aucun autre langage en Python. Au premier abord mystérieux, il agit en fait comme les <a href="http://sametmax.com/comprendre-les-decorateurs-python-pas-a-pas-partie-1/">décorateurs</a> en permettant d&#8217;exécuter du code automatiquement avant et après un autre code. Mais à l&#8217;image des décorateurs, tout ce qu&#8217;il fait pourrait être écrit à la main sans utiliser le mot clé <code>with</code>. Utiliser <code>with</code> est <a href="http://sametmax.com/jadore-les-context-managers-python/">une question de style</a>.</p>
<p>Supposons que vous vouliez afficher quelque chose avant un bout de code, et après un bout de code, même si celui-ci rate. Vous feriez quelque chose comme ça:</p>
<pre lang="python">def truc():
    print "machin"

print "Avant"
try:
    truc()
finally:
    print "Après"</pre>
<p>Et ça va afficher:</p>
<pre>Avant
machin
Après</pre>
<p>Et avec:</p>
<pre lang="python">def truc():
    print "machin"
    raise Exception('Fail !')</pre>
<p>&#8216;Après&#8217; sera quand même affiché. Ça plantera, mais la dernière action sera toujours faite.</p>
<p>Si vous le faites souvent, vous voudrez factoriser du code. Un des moyens de le faire est d&#8217;utiliser les context managers.</p>
<h2>Créer son propre context manager</h2>
<p>Un context manager est une classe <strong>ordinaire</strong> en Python. Sa seule spécificité est de déclarer une méthode <code>__enter__()</code> et une méthode <code>__exit__()</code>. Ces méthodes sont des méthodes <strong>ordinaires</strong>, leur nom spécial est juste là par convention, et en les nommant ainsi on s&#8217;assure qu&#8217;elles seront détectées et utilisées automatiquement.</p>
<p>Notre code là haut peut donc se réécrire ainsi:</p>
<pre lang="python">class MonSuperContextManager(object):
    def __enter__(self):
        print "Avant"
    def __exit__(self, type, value, traceback):
        # faites pas attention aux paramètres, ce sont toutes les infos
        # automatiquement passées à __exit__ et qui servent pour inspecter
        # une éventuelle exception
        print "Après"

with MonSuperContextManager():
    truc()</pre>
<p>L&#8217;avantage de with est multiple:</p>
<ul>
<li>Il permet de visualiser très précisément où on entre dans l&#8217;action et où on en sort (c&#8217;est un seul block)</li>
<li>Il permet de réutiliser les actions faite à l&#8217;entrée et à la sortie de l&#8217;action.</li>
<li>Même si une exception est levée, l&#8217;action de sortie sera exécutée juste avant le plantage. <code>__exit__</code> est en effet garantie d&#8217;être appelée quoiqu&#8217;il arrive. Bon, évidement, si il y a une coupure de courant&#8230;</li>
</ul>
<p>En gros, créer un context manager, c&#8217;est faire un raccourci lisible pour <code>try</code>/<code>finally</code>. Point.</p>
<h2>Un exemple utile de context manager</h2>
<p>Supposons que vous ayez beaucoup de travail à faire dans plein de dossiers. Vous voulez vous assurer que vous allez dans le dossier de travail, puis que vous retournez au dossier initial à chaque fois.</p>
<pre lang="python">import os

class Cd(objet):
    def __init__(dirname):
        self.dirname = dirname
    def __enter__(self):
        self.curdir = os.getcwd()
        os.chdir(self.dirname)
    def __exit__(self, type, value, traceback):
        os.chdir(self.curdir)</pre>
<p>On l&#8217;utilise comme ça:</p>
<pre lang="python"># ici on est dans /home/moi

with Cd('/'):

    # faire un truc dans /

    with Cd('/opt'):

        # faire un truc dans /opt

    # ici on est dans /

# ici on est dans /home/moi</pre>
<p>C&#8217;est d&#8217;ailleurs ce que fait <a href="http://sametmax.com/travailler-moins-pour-gagner-plus-en-15-minutes-avec-python-fabric/">fabric</a>.</p>
<h2>Le mot clé <code>as</code></h2>
<p>Tout ce qu&#8217;on retourne dans <code>__enter__</code> peut être récupéré grâce au mot clé <code>as</code>. Imaginons un context manager qui permette d&#8217;ouvrir un fichier et de le fermer automatiquement:</p>
<pre lang="python">class OpenFile(objet):
    def __init__(filename, mode='r'):
        self.filename = filename
        self.mode = mode
    def __enter__(self):
        self.file = open(self.filename, self.mode)
        # ici on retourne l'objet fichier, il sera accessible avec "as"
        return self.file
    def __exit__(self, type, value, traceback):
        self.file.close()</pre>
<p>On l&#8217;utilise comme ceci:</p>
<pre lang="python">with OpenFile('/etc/fstab') as f:
    for line in f:
        print line</pre>
<p><code>f</code> va contenir ici l&#8217;objet fichier, car nous l&#8217;avons retourné dans <code>__enter__</code>. A la fin du bloc <code>with</code>, le fichier sera fermé automatiquement.</p>
<p>Et devinez quoi, Python possède déjà un context manager qui fait ça:.</p>
<pre lang="python">with open(vot_fichier_msieu_dames) as f:
   # faire un truc</pre>
<h2>Context managers sous forme de fonctions</h2>
<p>Faire les choses sous forme de classes, c&#8217;est pratique quand on a beaucoup de logique à encapsuler. Mais la plupart des context managers sont très simples. Pour cette raison, Python vient avec plein d&#8217;outils pour se simplifier la vie avec <code>with</code> dans un module judicieusement nommé <code>contextlib</code>.</p>
<p>Pour l&#8217;utiliser, il faut avoir des notions sur les décorateurs, et le mot clé <a href="http://sametmax.com/comment-utiliser-yield-et-les-generateurs-en-python/">yield</a>. Si ce n&#8217;est pas votre cas, restez sur la version sous forme de classe :-)</p>
<p>Supposons que l&#8217;on veuille recréer le context manager <code>open</code>:</p>
<pre lang="python">from contextlib import contextmanager

@contextmanager
def open(filename, mode):
    try:
        f = open(filename, mode)
        yield f
    finally:
        f.close()</pre>
<p>Bon, c&#8217;est simplifié, hein, le vrai est plus robuste que ça.</p>
<p>Comment ça marche ?</p>
<p>D&#8217;abord, on utilise le décorateur <code>@contextmanager</code> pour dire à Python que la fonction sera un context manager.</p>
<p>Ensuite, on fait un <code>try</code>/<code>finally</code> (il est pas automatique comme avec <code>__enter__</code> et <code>__exit__</code>).</p>
<p><code>yield</code> sépare le code en deux: tout ce qui est avant est l&#8217;équivalent de <code>__enter__</code>, tout ce qui est après est l&#8217;équivalent de <code>__exit__</code>. Ce qui est &#8220;yieldé&#8221; est ce que l&#8217;on récupère avec le mot clé <code>as</code>.</p>
<h2>Context manager et décorateur, le shampoing deux en un</h2>
<p>Ces deux fonctionnalités se ressemblent beaucoup: elles permettent toutes les deux de lancer du code automatiquement avant et après un code tiers. La seule différence est que le context manager le fait à la demande, alors que le décorateur s&#8217;applique à la définition d&#8217;une fonction.</p>
<p>Quand on sait comment ils marchent, il est facile de faire un context manager utilisable également en tant que décorateur.</p>
<pre lang="python">from functools import wraps

class ContextDecorator(object):
    # __call__ est une méthode magique appelée quand on utilise () sur un objet
    def __call__(self, f):
        # bon, cette partie là suppose que vous savez comment marche un
        # décorateur, si c'est pas le cas, retournez lire l'article sur S&amp;M
        # linké dans le premier paragraphe
        @wraps(f)
        def decorated(*args, **kwds):
            # notez le with appelé sur soi-même, c'est y pas mignon !
            with self:
                return f(*args, **kwds)
        return decorated</pre>
<p>Et voilà, il suffit d&#8217;hériter de ça, et on a un décorateur + context manager. Par exemple, si on veut timer un truc:</p>
<pre lang="python">import datetime

class TimeIt(ContextDecorator):

    def __enter__(self):
        self.start = datetime.datetime.now()
        print self.start

    def __exit__(self, type, value, traceback):
        print (datetime.datetime.now() -self.start).total_seconds()</pre>
<p>Timer juste un appel:</p>
<pre lang="python">def foo():
    # faire un truc

with TimeIt():
    foo()</pre>
<p>Timer tous les appels:</p>
<pre lang="python">@TimeIt()
def foo():
   # faire un truc</pre>
<p>Notez que <a href="http://docs.python.org/py3k/library/contextlib.html#contextlib.ContextDecorator">ContextDecorator</a> est présent par défaut dans le module <code>contextlib</code> sous Python 3.2.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/les-context-managers-et-le-mot-cle-with-en-python/feed/</wfw:commentRss>
		<slash:comments>20</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">1987</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2012/09/shampooing-demelant-chien-demavic-laboratoire-2-1-z-345-34502.jpg" length="25075" type="image/jpg" />	</item>
		<item>
		<title>Explication de code: des mixins et des décorateurs de méthode pour Django</title>
		<link>http://sametmax.com/explication-de-code-des-mixins-et-des-decorateurs-de-methode-pour-django/</link>
		<comments>http://sametmax.com/explication-de-code-des-mixins-et-des-decorateurs-de-methode-pour-django/#comments</comments>
		<pubDate>Tue, 21 Aug 2012 14:37:57 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[cbv]]></category>
		<category><![CDATA[decorator]]></category>
		<category><![CDATA[django]]></category>
		<category><![CDATA[mixin]]></category>
		<category><![CDATA[python]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=1812</guid>
		<description><![CDATA[J'ai une préférence pour mon profile de 3-quart gauche.]]></description>
				<content:encoded><![CDATA[<p>Suite à notre <a href="http://sametmax.com/envoyez-nous-les-scripts-que-vous-ne-pigez-pas/">appel à l&#8217;envoi de code à expliquer</a>, nous avons reçu ceci:</p>
<blockquote><p>Pouvez-vous m&#8217;aider à comprendre ce code?</p>
<p><a href="https://gist.github.com/3092600">https://gist.github.com/3092600</a></p>
<p>La fonction dispatch, à quoi sert-elle?</p>
<p>L&#8217;appel via super, on appelle le parent de la classe?</p>
<p>Merci, je vous ferai une statue un jour!
</p></blockquote>
<p>Prépare le marbre.</p>
<h2>Programmation orientée objet</h2>
<p>Commençons par:</p>
<blockquote><p>L&#8217;appel via super, on appelle le parent de la classe?</p></blockquote>
<p>Oui, très exactement.</p>
<p>Et j&#8217;en profite pour rappeler que si vous utilisez les <a href="sametmax.com/des-vues-normales-aux-vues-generiques-django/">CBV</a>, il va vous falloir vous toucher en programmation orientée objet: définition de classe, héritage multiple, overriding, et autres joyeusetés.</p>
<p>Comme ce genre d&#8217;infos peut faire l&#8217;objet d&#8217;une série d&#8217;articles à part entière, je vais être obligé de partir du principe que vous savez coder en objet pour expliquer ce code. Sinon, ce post ferait quelques milliers de lignes. Si ce n&#8217;est pas votre cas, lisez notre <a href="http://sametmax.com/le-guide-ultime-et-definitif-sur-la-programmation-orientee-objet-en-python-a-lusage-des-debutants-qui-sont-rassures-par-les-textes-detailles-qui-prennent-le-temps-de-tout-expliquer-partie-1/">dossier sur la POO</a>, et revenez après.</p>
<h2>Worflow des CBV</h2>
<blockquote><p>La fonction <code>dispatch</code>, à quoi sert-elle? </p></blockquote>
<p>Les CBV ont un ordre d&#8217;éxécution pour leurs méthodes: <code>render_to_response()</code> retourne la vue, mais elle est appelée depuis <code>get()</code> ou <code>post()</code>, qui appellent aussi <code>get_context_data()</code> pour créer le <code>context</code> du template. Et <code>get_context_data()</code> appelle <code>get_query_set()</code> pour les vues qui utilisent l&#8217;ORM. Il faudrait que je fasse un gros schéma de tout ça un jour.</p>
<p><code>Dispatch()</code> est la méthode qui appelle toutes les autres. Elle choisi notament si on appelle la méthode <code>get()</code> ou <code>post()</code>. C&#8217;est en quelque sorte la méthode mère. Si on veut faire un truc avant que la vue ne travaille, c&#8217;est la dedans qu&#8217;il faut agir.</p>
<h2>Les décorateurs de méthode</h2>
<p>Comme vous l&#8217;avez vu, le code utilise <code>@method_decorator</code>. Encore une fois, je vais partir du principe que vous vous touchez avec les décorateurs, si ce n&#8217;est pas le cas, <a href="http://sametmax.com/comprendre-les-decorateurs-python-pas-a-pas-partie-1/">il y a un article pour ça</a><img src="https://s.w.org/images/core/emoji/2.4/72x72/2122.png" alt="™" class="wp-smiley" style="height: 1em; max-height: 1em;" />.</p>
<p>Néanmoins, dans l&#8217;article on ne parle que des décorateurs de fonctions. Comment décorer une méthode ? Et bien c&#8217;est pareil, sauf qu&#8217;il faut que votre décorateur accepte <code>self</code> en plus comme argument dans la fonction qu&#8217;il retourne.</p>
<p>Afin d&#8217;éviter de réécrire tous les décorateurs en double, on utilise <code>@method_decorator</code> qui est un décorateur&#8230; pour décorateurs ^^ Il transforme un décorateur pour fonction afin qu&#8217;il soit applicable à une méthode.</p>
<p>Ainsi quand vous voyez  <code>@method_decorator(login_required)</code>, ça veut dire &#8220;tranformer le décorateur <code>login_required</code> pour qu&#8217;il marche sur les méthodes, et l&#8217;apppliquer sur la méthode juste en dessous&#8221;</p>
<h2>Les mixins</h2>
<p>Je suis sûr que vous n&#8217;avez pas pu vous empêcher de vous demander, à la vue de ça:</p>
<pre lang="python">LoginRequiredMixin(object):
    """
        View mixin which requires that the user is authenticated.
    """</pre>
<p>Mais c&#8217;est quoi un mixin non de diou ?</p>
<p>Alors, déjà, on se rassure, ce n&#8217;est pas encore un nouveau truc compliqué à apprendre, c&#8217;est juste le nom d&#8217;un truc que vous connaissez déjà.</p>
<p>Un mixin, c&#8217;est le nom qu&#8217;on donne à une classe dont le but est exclusivement d&#8217;être utilisé pour l&#8217;héritage, afin de rajouter une fonctionalité à la classe enfant.</p>
<p>En gros, ce n&#8217;est qu&#8217;un nom, ça n&#8217;a rien de spécial, c&#8217;est une classe normale. Mixin est juste le rôle de la classe.</p>
<p>Les mixins ne sont PAS des interfaces, car ils font toujours quelque chose. Ils sont utilisés quand on a un code générique qu&#8217;on veut réutiliser dans plusieurs classes.</p>
<p>Les mixins changent le comportement, mais PAS la nature de la classe enfant. Il n&#8217;y a pas de <code>AnimalMixing</code> dont hériterait une class <code>Chien</code>, ou <code>Chat</code>. Ca c&#8217;est de l&#8217;héritage normal. On ne parle de mixin que pour le comportement.</p>
<p>Les mixins ne marchent que dans les langages qui autorisent l&#8217;héritage multiple, car on doit pouvoir hériter de plein de mixins d&#8217;un coup pour que ça soit utile.</p>
<h2>Explication du premier Snippet</h2>
<p>Vous vous souvenez du temps où c&#8217;était si simple de protéger une vue ?</p>
<pre lang="python">@login_required
def ma_vue(request):</pre>
<p>Avec les CBV, ce temps là est finit mes amis. C&#8217;est pour ça que je n&#8217;ai pas beaucoup d&#8217;amour pour elles.</p>
<p>Pour protéger une CBV on a plusieurs choix:</p>
<pre lang="python">class MaView(ListView):
    ...

ma_vue = login_required(MaView.as_view())</pre>
<p>Et on importe <code>ma_vue</code> dans <em>urls.py</em>.</p>
<p>OU directement dans <em>urls.py</em>:</p>
<pre lang="python">...
url('/this/is/not/a/url', login_required(MaView.as_view()))
...</pre>
<p>OU la méthode <a href="https://docs.djangoproject.com/en/1.4/topics/class-based-views/#decorating-the-class">recommandée</a> par les mecs de Django, méga simple et intuitive:</p>
<pre lang="python">class MaView(ListView):
    ...
    @method_decorator(login_required)
    def dispatch(self, *args, **kwargs):
        return super(ProtectedView, self).dispatch(*args, **kwargs)</pre>
<p>On applique le décorateur <code>@login_required</code> à la méthode <code>dispatch()</code>. Comme c&#8217;est la méthode qui appelle toutes les autres, la vue est ainsi protégée.</p>
<p>Seulement voilà, tout celà est bien relou, et l&#8217;auteur des snippets y remédie:</p>
<pre lang="python">class LoginRequiredMixin(object):
    """
      View mixin which requires that the user is authenticated.
    """
    @method_decorator(login_required)
    def dispatch(self, request, *args, **kwargs):
        return super(LoginRequiredMixin, self).dispatch(
            self, request, *args, **kwargs)</pre>
<p>Ce faisant, il créé un mixin qui va appliquer ce décorateur. Mixin qu&#8217;on peut réutiliser ainsi:</p>
<pre lang="python">class MaView(LoginRequiredMixin, ListView):
    ...</pre>
<p>Et protéger une vue redevient simple à nouveau !</p>
<p>Attention, il faut bien mettre le mixin en premier dans la liste de parents. En effet, <code>dispatch()</code> de <code>MaView</code> va appeler celui de <code>LoginRequiredMixin</code> qui va appeler <code>super()</code> qui va va ainsi appeler <code>dispatch()</code> de <code>ListView</code>. C&#8217;est ce qu&#8217;on appelle le MRO (Method Résolution Order), <a href="https://fuhm.net/super-harmful/">l&#8217;ordre à vachement d&#8217;importance</a>, et ça mériterait un article à lui tout seul.</p>
<p>Je résume:</p>
<p><code>dispatch()</code> est la méthode d&#8217;un vue qui appelle toutes les autres. <code>LoginRequiredMixin</code> a sa méthode <code>dispatch()</code> protégée pour qu&#8217;elle ne soit accessible que par les utilisateurs enregistrés. <code>MaView</code> hérite du mixin pour intégrer cette fonctionalité. Du coup son <code>dispatch()</code> va utiliser le <code>dispatch()</code> de <code>LoginRequiredMixin</code>, qui est protégé. Comme <code>LoginRequiredMixin</code> est bien faites, son <code>dispatch()</code> appelle celui de <code>ListView</code>, et ainsi la vue fonctionne correctement.</p>
<h2>Les autres snippets</h2>
<p>On peut maintenant aller plus vite.</p>
<p>Le deuxième mixin permet de n&#8217;autoriser l&#8217;accès à une vue que si on a les permissions nécessaires (Django vient en effet avec toute une gestion des permissions dans son app contrib &#8216;auth&#8217;)</p>
<pre lang="python">class PermissionsRequiredMixin(object):
    # les permissions nécessaires sont stockées dans cet attribut
    required_permissions = ()

    # dispatch est encore une fois protégée contre les users non loggés
    @method_decorator(login_required)
    def dispatch(self, request, *args, **kwargs):
        # on rajoute une subtilité:
        # on vérifie si le user a les permissions exigées avant
        # d'appler le dispatch() du parent
        # si on a pas les permissions, on rajoute un message d'erreur
        # et on redirige vers la page de login
        # sinon on appelle le dispatch() du parent comme d'hab
        if not request.user.has_perms(self.required_permissions):
            messages.error(
                request,
                'You do not have the permission required to perform the '
                'requested operation.')
            return redirect(settings.LOGIN_URL)
        return super(PermissionsRequiredMixin, self).dispatch(
            request, *args, **kwargs)</pre>
<p>Ca s&#8217;utilise comme ça:</p>
<pre lang="python">class MaVue(PermissionsRequiredMixin, ListView):
    required_permissions = (
        'dealer.create_cocaine',
        'dealer.delete_cocaine',
    )</pre>
<p>Un utilisateur qui n&#8217;a pas les permissions <code>create_cocaine</code> et <code>delete_cocaine</code> de l&#8217;app &#8216;dealer&#8217; sera redirigé vers la page de login.</p>
<p>En effet, <code>MaVue.dispatch</code> appelle la méthode <code>PermissionsRequiredMixin.dispatch</code>, mais avec une subtilité: le <code>self</code> passé en paramètre est celui de <code>MaVue</code>. <code>self.required_permissions</code> dans <code>PermissionsRequiredMixin.dispatch</code> est donc en vérité <code>MaVue.required_permissions</code>. Relisez ce paragraphe plusieurs fois.</p>
<p>Notez en revanche que la page de redirection n&#8217;est pas configurable, ce qui est bien dommage. Ca se corrige facilement:</p>
<pre lang="python">class PermissionsRequiredMixin(object):
    required_permissions = ()
    redirect_url = settings.LOGIN_URL # <== HOP

    @method_decorator(login_required)
    def dispatch(self, request, *args, **kwargs):
        if not request.user.has_perms(self.required_permissions):
            messages.error(
                request,
                'You do not have the permission required to perform the '
                'requested operation.')
            return redirect(self.redirect_url) # <== HOP
        return super(PermissionsRequiredMixin, self).dispatch(
            request, *args, **kwargs)</pre>
<p>Du coup on a plus de marge de manoeuvre.</p>
<p><strong>Le 3eme et 4eme snippet, c'est la même chose. Kiff kiff. Pareil.</strong></p>
<p>Mais au lieu de vérifier les permissions, on vérifie juste si l'utilisateur à accès à l'admin Django (<code>is_staff</code>) ou que l'utilisateur est un superutilisateur (<code>is_superuser</code>: il a toutes les permissions):</p>
<pre lang="python">class StaffRequiredMixin(object):
    @method_decorator(login_required)
    def dispatch(self, request, *args, **kwargs):
        # j'ai pas besoin de vous expliquer ça quand même ?
        if not request.user.is_staff:
            messages.error(
                request,
                'You do not have the permission required to perform the '
                'requested operation.')
            return redirect(settings.LOGIN_URL)
        return super(StaffRequiredMixin, self).dispatch(request,
            *args, **kwargs)

class SuperUserRequiredMixin(object):
    @method_decorator(login_required)
    def dispatch(self, request, *args, **kwargs):
        # je pense que c'est assez explicite
        if not request.user.is_superuser:
            messages.error(
                request,
                'You do not have the permission required to perform the '
                'requested operation.')
            return redirect(settings.LOGIN_URL)
        return super(SuperUserRequiredMixin, self).dispatch(request,
            *args, **kwargs)</pre>
<p>Comme je le disais plus haut, on peut utiliser plusieurs mixins en même temps. Par exemple, si je veux limiter l'accès à une vue aux dealers qui font partie de mon staff:</p>
<pre lang="python">class MaVue(PermissionsRequiredMixin, StaffRequiredMixin, ListView):
    required_permissions = (
        'dealer.create_cocaine',
        'dealer.delete_cocaine',
    )</pre>
<p>Notez encore une fois que les mixins sont là en premier, car <code>MaVue.dispatch</code> appelle <code>PermissionsRequiredMixin.dispatch</code> qui appelle <code>StaffRequiredMixin.dispatch</code> qui appelle <code>ListView.dispatch</code>.</p>
<p>En revanche, dans ce cas précis l'ordre des mixins, entre eux, n'a pas d'importance. Ce ne sera pas toujours le cas: il faut comprendre comment les mixins agissent pour savoir si certains doivent être mis en premier. C'est tout le problème des CBV: pour en faire un usage productif, la somme de choses à savoir est assez démente.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/explication-de-code-des-mixins-et-des-decorateurs-de-methode-pour-django/feed/</wfw:commentRss>
		<slash:comments>24</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">1812</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2012/08/monument_miniature.jpg" length="14088" type="image/jpg" />	</item>
		<item>
		<title>Mémoization d&#8217;une fonction Python</title>
		<link>http://sametmax.com/memoization-dune-fonction-python/</link>
		<comments>http://sametmax.com/memoization-dune-fonction-python/#comments</comments>
		<pubDate>Fri, 20 Jul 2012 20:37:27 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[decorator]]></category>
		<category><![CDATA[function]]></category>
		<category><![CDATA[memoize]]></category>
		<category><![CDATA[python]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=1223</guid>
		<description><![CDATA[La <a href="http://fr.wikipedia.org/wiki/M%C3%A9moization">mémoization</a> est une forme de mise en cache, elle consiste à cacher le résultat d'une fonction afin que les appels successifs avec des paramètres identiques utilisent le cache plutôt que de calculer à nouveau les données.]]></description>
				<content:encoded><![CDATA[<p>La <a href="http://fr.wikipedia.org/wiki/M%C3%A9moization">mémoization</a> est une forme de mise en cache, elle consiste à cacher le résultat d&#8217;une fonction afin que les appels successifs avec des paramètres identiques utilisent le cache plutôt que de calculer à nouveau les données.</p>
<p>En gros:</p>
<pre lang="python">>>> fonction_super_lente(True, '127.0.0.1') # calcule
>>> fonction_super_lente(True, '127.0.0.1') # ne calcule pas, retourne le cache
>>> fonction_super_lente(True, '192.168.0.1') # calcule car les paramètres sont différents</pre>
<p>En Python on peut le faire de plusieurs manières, malgré ce que <a href="http://www.python.org/dev/peps/pep-0020/">prétend la philosophie du langage</a>.</p>
<h2>La version avec dico externe</h2>
<pre lang="python">
resultats = {}
def fonction_super_lente(le_faire, sur_quoi):
    
    if not (le_faire, sur_quoi) in resultats:
        resultats[(le_faire, sur_quoi)] = # balancer le calcul lent ici

    return resultats[(le_faire, sur_quoi)]</pre>
<p>Cela marche parceque <code>resultats</code> est gardé dans une <a href="http://sametmax.com/closure-en-python-et-javascript/">closure</a> et donc accessible dans la fonction. Comme il est défini avant, et que les dictionnaires sont mutables, on a toujours la même référence au même dico à chaque appel. On a juste a vérifier qu&#8217;un résultat pour ces param existent (<a href="http://sametmax.com/ce-que-vous-ne-saviez-pas-sur-les-collections-en-python/">les tuples peuvent être des clés de dictionnaires</a>), et si non, on remplit le cache.</p>
<p>Avantages:</p>
<ul>
<li>c&#8217;est facile à comprendre;</li>
<li>on peut manipuler le cache depuis l&#8217;extérieur.</li>
</ul>
<p>Inconvénient:</p>
<ul>
<li>le namespace du module est pollué;</li>
<li>on risque d&#8217;importer le cache par erreur.</li>
</ul>
<h2>La version avec paramètre additionel </h2>
<pre lang="python">
def fonction_super_lente(le_faire, sur_quoi, _resultats={}):
    
    if not (le_faire, sur_quoi) in resultats:
        _resultats[(le_faire, sur_quoi)] = # balancer le calcul lent ici

    return _resultats[(le_faire, sur_quoi)]</pre>
<p>Même chose que précédement, mais la différence est que le cache est stocké dans un paramètre. Cela marche car <a href="http://sametmax.com/quelques-erreurs-tordues-et-leurs-solutions-en-python/">les paramètres sont initialisés à la déclaration en Python</a>, et une seule fois.</p>
<p>Notez le underscore devant le nom de paramètre qui est une convention pour désigner un paramètre qui ne fait pas partie de l&#8217;API publique.</p>
<p>Avantages:</p>
<ul>
<li>c&#8217;est encore pas trop dur à comprendre;</li>
<li>le namespace est clean.</li>
</ul>
<p>Inconvénient:</p>
<ul>
<li>la signature de la fonction possède un argument artificiel.</li>
</ul>
<h2>La version avec attribut</h2>
<pre lang="python">
def fonction_super_lente(le_faire, sur_quoi):
    
    resultats = getattr(function_super_lente, '_resultats', {})
    if not (le_faire, sur_quoi) in resultats:
        resultats[(le_faire, sur_quoi)] = # balancer le calcul lent ici
        function_super_lente._resultats = resultats

    return resultats[(le_faire, sur_quoi)]</pre>
<p>Cela marche car les fonctions en Python sont des objets. On peut leur rajouter des attributs à la volées comme pour n&#8217;importe quel objet :-)</p>
<p>Notez l&#8217;usage du troisième paramètre de <code>getattr()</code> qui nous permet d&#8217;avoir une valeur par défaut même si l&#8217;attribut n&#8217;existe pas encore.</p>
<p>Avantages:</p>
<ul>
<li>pas de polution du namespace ni de la signature.</li>
</ul>
<p>Inconvénient:</p>
<ul>
<li>votre collègue va surement vous demander: WTF ?</li>
</ul>
<h2>La version avec décorateur</h2>
<p>Il existe pas mal de versions de <a href="http://wiki.python.org/moin/PythonDecoratorLibrary#Memoize">décorateurs de mémoization</a>  disponibles sur le Net. Ca s&#8217;utilise généralement comme ça :</p>
<pre lang="python">
from malib import memoized

@memoized
def fonction_super_lente(le_faire, sur_quoi):
    
    return # le truc normalement</pre>
<p>Avantages:</p>
<ul>
<li>y a pas plus propre;</li>
<li>y a pas plus facile.</li>
</ul>
<p>Inconvénient:</p>
<ul>
<li>une dépendance de plus;</li>
<li>chaque implémentation possède une caractéristique (souvent une limite): il faut donc comprendre des codes parfois complexes pour les utiliser en toute tranquilité d&#8217;esprit.
</li>
</ul>
<h2>
Petit rappel</h2>
<p>Cette technique, de par sa nature, implique de tout stocker en mémoire vive. Donc attention à votre RAM, et vérifiez bien que ça vaut le coup d&#8217;échanger la charge CPU contre celle de vos barettes. Ensuite, le bénéfice est d&#8217;autant plus grand que le code tourne longtemps. Si c&#8217;est un script lancé de nombreuses fois, avec quelques appels à la fonction, le gain est faible: entre chaque initialisation de la VM Python, le cache disparait. Dans ce cas il vaut mieux se tourner vers une solution telle que Redis.</p>
<p>Le cas typique d&#8217;usage pertinent est celui d&#8217;un daemon faisant des appels à une API WEB: en cachant les résultats, vous économisez une requête HTTP.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/memoization-dune-fonction-python/feed/</wfw:commentRss>
		<slash:comments>11</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">1223</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2012/07/moise.jpg" length="66718" type="image/jpg" />	</item>
	</channel>
</rss>
