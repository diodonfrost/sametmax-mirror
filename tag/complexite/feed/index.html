<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" >

<channel>
	<title>complexité &#8211; Sam &amp; Max</title>
	<atom:link href="http://sametmax.com/tag/complexite/feed/" rel="self" type="application/rss+xml" />
	<link>http://sametmax.com</link>
	<description>Du code, du cul</description>
	<lastBuildDate>Thu, 05 Sep 2019 08:22:03 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.7</generator>
<site xmlns="com-wordpress:feed-additions:1">32490438</site>	<item>
		<title>Complexité algorithmique : pourquoi tant de &#8220;n&#8221; ?</title>
		<link>http://sametmax.com/complexite-algorithmique-pourquoi-tant-de-n/</link>
		<comments>http://sametmax.com/complexite-algorithmique-pourquoi-tant-de-n/#comments</comments>
		<pubDate>Tue, 22 Apr 2014 16:29:56 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[algo]]></category>
		<category><![CDATA[algorithme]]></category>
		<category><![CDATA[complexité]]></category>
		<category><![CDATA[python]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=10051</guid>
		<description><![CDATA[Que ayez eu un prof à l'ancienne durant vos études, où que vous vous soyez plongez dans des documents traitant d'optimisation, vous êtes peut être un jour tombé sur ces fameuse notation : O(n), O(1), O(log(n)), etc.]]></description>
				<content:encoded><![CDATA[<p>Que ayez eu un prof à l&#8217;ancienne durant vos études, où que vous vous soyez plongé dans des documents traitant d&#8217;optimisation, vous êtes peut être un jour tombé sur ces fameuses notations : O(n), O(1), O(log(n)), etc.</p>
<h2>Qu&#8217;est-ce que cela signifie-t-il donc, alors, hein ?</h2>
<p>C&#8217;est une manière de décrire l&#8217;ordre de grandeur de temps que va prendre un algo pour s&#8217;exécuter pour un nombre &#8220;n&#8221; d&#8217;éléments.</p>
<p>Par exemple, si je fais ceci en Python :</p>
<pre lang="python">
elements = [1, 2, 3]
for x in elements:
    print(x)
## 1
## 2
## 3
</pre>
<p>Ici, j&#8217;ai 3 éléments, donc n = 3. Mon algorithme va tous les utiliser une fois, mais pas plus d&#8217;une. Il va donc faire un nombre d&#8217;opérations proportionnel au nombres d&#8217;éléments. On note ce type de comportement O(n). Cela signifie que le temps de traitement de mon code suit à peu près &#8220;n&#8221;.</p>
<p>Je dis à peu près car le nombre d&#8217;éléments n&#8217;est pas uniquement ce qui va rentrer en compte. La taille des éléments, l&#8217;état de la machine au moment de l&#8217;exécution et tout un tas d&#8217;autres paramètres vont être des facteurs. Mais, globalement, je peux donner une évaluation convenable du temps que le code va prendre en notant le temps de traitement d&#8217;un seul élément, et en le multipliant par le nombre total d&#8217;éléments.</p>
<p>La notation O(truc), que l&#8217;on prononce &#8220;Oh de truc&#8221;, sert juste à indiquer quel type de comportement un algo a : est-ce qu&#8217;il prend du temps par rapport au nombre d&#8217;éléments ? Si oui à quel point ?</p>
<p>&#8220;A quel point&#8221; est une question importante, car si mon algo est celui ci:</p>
<pre lang="python">
elements = [1, 2, 3]
for x in elements:
    print()
    for i in elements:
        print(i, end="")
## 123
## 123
## 123
</pre>
<p>Alors, si n est grand, non seulement ma première boucle s&#8217;allonge, mais ma seconde boucle s&#8217;allonge aussi car j&#8217;affiche TOUS les éléments pour CHAQUE élément. Mon temps d&#8217;exécution dépend alors de &#8220;n&#8221; multiplié par lui-même : n X n. En effet, si j&#8217;ai 2 éléments, je vais faire 2 x 2 = 4 <code>print()</code>, si j&#8217;en ai 3, je vais faire 3 x 3 <code>print()</code>, etc.</p>
<p>Bien sûr, je pourrais faire des choses beaucoup plus compliquées qu&#8217;un <code>print()</code>, mais ça n&#8217;a pas d&#8217;importance. On en mesure pas le temps de tout le programme, seulement l&#8217;efficacité d&#8217;un algorithme. Ici, cela dépend du nombre d&#8217;éléments fois lui-même, soit au carré. On le note O(n²).</p>
<p>Il existe tout <a href="http://fr.wikipedia.org/wiki/Analyse_de_la_complexit%C3%A9_des_algorithmes">un tas de ces notations</a>. Par exemple, 0(1) signifie un temps &#8220;constant&#8221;, c&#8217;est un abus de langage pour dire que le temps que met l&#8217;ago à s&#8217;effectuer ne dépend pas du nombre d&#8217;éléments.</p>
<p>Par exemple :</p>
<pre lang="python">
elements = [1, 2, 3]
print(elements[0])
## 1
</pre>
<p>Afficher le premier élément prend un temps du même ordre de grandeur &#8211; car c&#8217;est ça l&#8217;important, l&#8217;ordre de grandeur &#8211; si il y a 1 ou 10000 éléments. On note donc cet algo O(1).</p>
<p>Il y a des cas plus complexes. Imaginez celui-ci :</p>
<pre lang="python">
import random

number = random.randint(0, 100)
print("Choosing: %s" % number)
smallest = 0
biggest = 100
guess = 50
while guess != number:
    if number >= guess:
        smallest = guess
    else:
        biggest = guess
    
    guess = (biggest - smallest)//2 + smallest
    print("New guess: %s" % guess)

print("Last guess: %s" % guess)
## Choosing: 69
## New guess: 75
## New guess: 62
## New guess: 68
## New guess: 71
## New guess: 69
## Last guess: 69</pre>
<p>Dans cet exemple, le nombre d&#8217;opérations dépend du nombre d&#8217;éléments &#8220;n&#8221; (ici 100) mais on divise l&#8217;interval de recherche par deux à chaque tour de boucle. On note cette complexité O(log n), puisque la fonction log illustre bien le concept d&#8217;avoir une mi-molle sur la fin de son algo :)</p>
<p>Il y a aussi l&#8217;inverse :</p>
<pre lang="python">
elements = [1, 2, 3, 4, 5]
copies = []
for x in elements:
    print()
    for i in copies:
        print(i, end="")
    copies.extend(elements)
## 12345
## 1234512345
## 123451234512345
## 12345123451234512345
</pre>
<p>Ici on augment la charge à traiter à chaque tour de boucle, et cette augmentation dépend du nombre d&#8217;éléments &#8220;n&#8221;. On parle d&#8217;une augmentation exponentielle de la charge de travail et on le note O(e<sup>n</sup>).</p>
<h2>A quoi ça sert ?</h2>
<p>Essentiellement à avoir une idée d&#8217;où on met les pieds. Si vous lisez une doc, et qu&#8217;on vous dis &#8220;cet algo met un temps O(log(n))&#8221;, vous savez que même sur un grand ensemble de données, le traitement ne sera pas trop agressif. Si plus tard vous rencontrez des problèmes de perf, ce ne sera pas le premier endroit à regarder.</p>
<p>Par contre si vous lisez qu&#8217;un algo est O(n!) &#8211; là on tape dans les factoriels, c&#8217;est énorme &#8211; alors au premier ralentissement il faut jeter un coup d’œil sur ce bout de code.</p>
<p>C&#8217;est aussi utile pour comparer l&#8217;efficacité de deux implémentations.</p>
<p>Imaginez la structure suivante :</p>
<pre lang="python">class Examen:
    """C'est un exemple pédagogique, ne faites pas ça chez vous les enfants"""
    def __init__(self):
        self.notes = []

    def ajouterNote(self, note):
        self.notes.append(note)

    def moyenne(self):
        total = 0
        for note in self.notes:
            total += note
        return total / len(self.notes)</pre>
<p>Récupérer la moyenne est une opération O(n). En revanche, si on a :</p>
<pre lang="python">class Examen:
    def __init__(self):
        self.notes = []
        self.moyenne = None

    def ajouterNote(self, note):
        
        if self.moyenne is None:
            self.moyenne = note
        else:
            self.moyenne = (len(self.notes)*self.moyenne + note) / (len(self.notes)+1)
        self.notes.append(note)
            
</pre>
<p>Là, récupérer la moyenne devient une opération O(1), on a déchargé et réparti le calcul sur l&#8217;ajout des notes. Selon que l&#8217;application va lire souvent la moyenne ou non, l&#8217;un ou l&#8217;autre algo est préférable, et la notation Big O va donner une idée duquel utiliser si on est face à la doc et pas au code, qui est généralement vachement plus compliqué que ça.</p>
<p>Bon, ok, dans la VVV, aucune de ces deux solutions n&#8217;est un problème, on s&#8217;en branle. Mais sur des algos plus riches, sur du matos plus limité, ou un jeu de données plus grand, c&#8217;est important. Ainsi, <a href="http://redis.io/commands/zremrangebyrank">la doc de redis donne la notation Big O de toutes les commandes</a>.</p>
<h2>En Python, qui est quoi ?</h2>
<p>Parcourir un itérable, c&#8217;est généralement du O(n), en tout cas pour les listes, les tuples, les dicos, les strings et les sets. Ajouter un élément ou en retirer un, c&#8217;est du O(1). Récupérer leurs tailles, c&#8217;est du O(1) aussi (elle est mise en cache), donc vous pouvez y aller avec <code>len()</code>.</p>
<p>En revanche, l&#8217;opérateur <code>in</code> a un temps moyen de O(n) pour les strings, les tuples et les listes (il doit parcourir l&#8217;itérable jusqu&#8217;à trouver l&#8217;élément), et un temps de O(1) pour les sets et les dicos. Ces derniers utilisent des hash, rendant la recherche très très rapide. C&#8217;est pour cela qu&#8217;on vous dit d&#8217;utiliser la bonne structure de données pour le bon usage.</p>
<p>Attention cependant, c&#8217;est de l&#8217;optimisation de poil de cul, mais c&#8217;est pour la culture, O(1) ne veut pas dire &#8220;plus rapide que O(n)&#8221;. O(1) veut juste dire que le temps est indépendant du nombre d&#8217;éléments. Ainsi :</p>
<p><code>1 in [1, 2, 3]</code> sera beaucoup plus rapide que <code>1 in [1, 2, 3..., 1000].</code></p>
<p>Et :</p>
<p><code>1 in {1, 2, 3}</code> prendra un temps similaire à 1 in <code>{1, 2, 3..., 1000}</code></p>
<p>Mais :</p>
<p><code>1 in {1, 2, 3}</code> peut tout à faire être plus lent que <code>1 in [1, 2, 3]</code></p>
<p>Par contre, il est presque certain que :</p>
<p><code>1 in {1, 2, 3..., 1000}</code> est BEAUCOUP plus rapide que <code>1 in [1, 2, 3..., 1000]</code></p>
<p>De plus, il y énormément de structures de données dans la stdlib Python, toutes avec des capacités différentes. <a href="http://sametmax.com/heapq-le-module-python-incompris/">Heapq</a> assure que votre structure de données est toujours ordonnées pour un coût de O(log n) à l&#8217;insertion. Les <a href="http://sametmax.com/implementer-une-fenetre-glissante-en-python-avec-un-deque/">deques</a> sont très rapides comme FIFO/LIFO (O(1)), mais récupérer une donnée au milieu est une opération O(n). Certaines opérations, comme retirer un élément d&#8217;un type <code>list</code> sont étonnamment coûteuses ((O(n) dans le cas du del).</p>
<p>Voici <a href="https://wiki.python.org/moin/TimeComplexity">quelques notations</a> de la doc de Python.</p>
<h2>La théorie, la pratique, et la mauvaise foi</h2>
<p>La notation O est une bonne indication pour faire un choix d&#8217;algo ou pour commencer ses recherches de goulot d&#8217;étranglement dans un code.</p>
<p>Néanmoins, c&#8217;est la performance sur la papier. En pratique, on peut obtenir des résultats un peu différents, voir carrément surprenant. Il peut y avoir de multiples causes :</p>
<ul>
<li>L&#8217;implémentation ne se comporte pas comme prévu. CPython et Jython n&#8217;ont pas les mêmes perfs pour les mêmes choses. Jython n&#8217;a pas de GIL.</li>
<li>Vous avez oublié un paramètre. Un accès disque ou un accès réseau au mauvais endroit, et bam, votre évaluation est à revoir. </li>
<li>Les données de la vie réelle ont généralement des tendances. Par exemple elles sont souvent un peu triées plutôt que complètement en bordel. C&#8217;est pour cette raison que Python utilise <a href="http://en.wikipedia.org/wiki/Timsort">Timsort</a>.</li>
<li>Le matos ne fait pas ce que vous croyez. Les processeurs / cartes graphiques actuels sont devenus <a href="http://www.grantjenks.com/docs/sortedcontainers/implementation.html">incroyablement efficaces à certaines opérations réputées lentes</a></li>
<li>Votre machine ne fait pas que faire tourner votre algo. Il y a d&#8217;autres processus, avec des conséquences.</li>
</ul>
<p>Donc si les perfs sont importantes, comme toujours en informatique, on a le dernier mot en mesurant soi-même.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/complexite-algorithmique-pourquoi-tant-de-n/feed/</wfw:commentRss>
		<slash:comments>25</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">10051</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2014/04/p8IfIPY.jpg" length="108943" type="image/jpg" />	</item>
	</channel>
</rss>
