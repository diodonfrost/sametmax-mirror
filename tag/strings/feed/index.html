<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" >

<channel>
	<title>strings &#8211; Sam &amp; Max</title>
	<atom:link href="http://sametmax.com/tag/strings/feed/" rel="self" type="application/rss+xml" />
	<link>http://sametmax.com</link>
	<description>Du code, du cul</description>
	<lastBuildDate>Thu, 05 Sep 2019 08:22:03 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.7</generator>
<site xmlns="com-wordpress:feed-additions:1">32490438</site>	<item>
		<title>« % ou format() en Python ? », inversion des polarités</title>
		<link>http://sametmax.com/ou-format-en-python-inversion-des-polarites/</link>
		<comments>http://sametmax.com/ou-format-en-python-inversion-des-polarites/#comments</comments>
		<pubDate>Tue, 08 Sep 2015 09:27:28 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[strings]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=16899</guid>
		<description><![CDATA[Normalement je fais les mises à jour d’articles par ordre chronologique, mais là une occasion s’est présentée avec l’article. Je suis tombé dessus par hasard, je ne sais plus trop comment, et j’ai réalisé que j’avais changé d’avis sur l’article. Je ne recommandais plus du tout ce que j’y mettais. Il fallait le mettre à [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>Normalement je fais les mises à jour d’articles par ordre chronologique, mais là une occasion s’est présentée avec l’article.</p>
<p>Je suis tombé dessus par hasard, je ne sais plus trop comment, et j’ai réalisé que j’avais changé d’avis sur l’article. Je ne recommandais plus du tout ce que j’y mettais.</p>
<p>Il fallait le mettre à jour, mais un si petit article, je serais probablement passé à côté dans le futur. En effet, je ne veux pas updater  600 articles, donc je fais ceux qui me paraissent prioritaires.</p>
<p>Du coup je l’ai fait tout de suite, histoire de ne pas oublier. En prime, il m’a donné envie d’écrire un article sur le formatage des chaines en Python en général, qui devrait sortir dans la semaine.</p>
<p>Cette réécriture comprend :</p>
<ul>
<li>Absolument aucun changement Python 3. Il n’y avait pas de code, mais de toute façon le code est le même en Python 2. J’ai quand même mis la mention « python 3 » en haut, histoire que les gens sachent que le conseil est d’actualité.</li>
<li>Des exemples rajoutés, car là c’était très théorique. Je devais être pressé le jour où je l’ai écrit :)</li>
<li>Et une mention des f-strings, histoire de faire un peu le teasing de la version 3.6.</li>
</ul>
<p>On se chauffe les yeux, et <a href="http://sametmax.com/ou-format-en-python/">on va le lire</a> !</p>
<p>Dans le cadre de notre parenthèse lubrique, j&#8217;ai eu envie de ruiner l&#8217;enfance de la nouvelle génération, la règle 34 ayant suffisamment attaqué la mienne :</p>
<p><iframe src="http://embed.redtube.com/?id=527722&#038;bgcolor=000000" frameborder="0" width="560" height="315" scrolling="no" allowfullscreen></iframe></p>
<p>Je suis quand même épaté de tout cet effort déployé par les monstres de tout poil (mouarf) juste pour insérer leur tentacules dans des orifices. Mais bon, quand ce sont des bites, au Japon, elles doivent être floutées, du coup ceci explique cela. Et puis ce qu&#8217;<a href="http://www.redtube.com/?search=my+little+poney">on trouve</a> sur MyLittlePoney n&#8217;est pas mieux.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/ou-format-en-python-inversion-des-polarites/feed/</wfw:commentRss>
		<slash:comments>8</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">16899</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2015/09/TriVdyx.jpg" length="130859" type="image/jpg" />	</item>
		<item>
		<title>Quelques innovation de Python 3 backportées en Python 2.7</title>
		<link>http://sametmax.com/quelques-innovation-de-python-3-backportees-en-python-2-7/</link>
		<comments>http://sametmax.com/quelques-innovation-de-python-3-backportees-en-python-2-7/#comments</comments>
		<pubDate>Mon, 05 Nov 2012 11:36:42 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[context manager]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[sets]]></category>
		<category><![CDATA[strings]]></category>
		<category><![CDATA[unit tests]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=2863</guid>
		<description><![CDATA[Comme nous l'avons vu avec les vues ou les collections, Python 2.7 vient avec pas mal de bonus issus directement de la branche 3. En voici quelques autres. Tout ceci n'est bien sûr ni nouveau ni exhaustif, mais je m’aperçois que peu de personnes le savent.]]></description>
				<content:encoded><![CDATA[<p>Comme nous l&#8217;avons vu avec les <a href="http://sametmax.com/les-vues-sur-des-collections-en-python/">vues</a> ou les <a href="http://sametmax.com/ce-que-vous-ne-saviez-pas-sur-les-collections-en-python/">collections</a>, Python 2.7 vient avec pas mal de bonus issus directement de la branche 3. En voici quelques autres. Tout ceci n&#8217;est bien sûr ni nouveau ni exhaustif, mais je m’aperçois que peu de personnes le savent.</p>
<p>Une notation littérale pour les sets:</p>
<pre lang="python">>>> {1, 2} == set((1, 2))
True</pre>
<p>Une syntaxe pour les dictionnaires en intention:</p>
<pre lang="python">>>> d = {chr(x): x for x in range(65, 91)}
>>> d
{'A': 65, 'C': 67, 'B': 66, 'E': 69, 'D': 68, 'G': 71, 'F': 70, 'I': 73, 'H': 72, 'K': 75, 'J': 74, 'M': 77, 'L': 76, 'O': 79, 'N': 78, 'Q': 81, 'P': 80, 'S': 83, 'R': 82, 'U': 85, 'T': 84, 'W': 87, 'V': 86, 'Y': 89, 'X': 88, 'Z': 90}</pre>
<p>Imbriquer <code>with</code>:</p>
<p>Avant il fallait utiliser <a href="http://docs.python.org/2/library/contextlib.html#contextlib.nested">nested()</a> ou imbriquer à la main</p>
<pre lang="python">with open('fichiera') as a:
    with open('fichiera') as b:
        # faire un truc</pre>
<p>Maintenant on peut faire:</p>
<pre lang="python">with open('fichiera') as a, open('fichiera') as b:
    # faire un truc</pre>
<p>Rien à voir, mais toujours sympa. <code>timedelta</code> a maintenant une méthode <code>total_seconds()</code> qui retourne la valeur de la durée en seconde. En effet, l&#8217;attribut <code>seconds</code> ne retourne que ce qui reste en seconde une fois qu&#8217;on a retiré les jours:</p>
<pre lang="python">>>> from datetime import timedelta
>>> delta = timedelta(days=1, seconds=1)
>>> delta.seconds
1
>>> delta.total_seconds()
86401.0</pre>
<p>Notez qu&#8217;il n&#8217;y a toujours ni attribut minutes, ni heures.</p>
<p>Le module <code>unittest</code> gagne une pléthore d&#8217;améliorations, et notamment:</p>
<p>L&#8217;utilisation de <code>assertRaises</code> comme context manager:</p>
<pre lang="python">with self.assertRaises(KeyError):
    {}['foo']</pre>
<p>Et un bon gros nombres de méthodes:</p>
<p><code>assertIsNone()</code> / <code>assertIsNotNone()</code>, <code>assertIs()</code> / <code>assertIsNot()</code>, <code>assertIsInstance()</code> / <code>assertNotIsInstance()</code>, <code>assertGreater()</code> / <code>assertGreaterEqual()</code> / <code>assertLess()</code> / <code>assertLessEqual()</code>, <code>assertRegexpMatches()</code> / <code>assertNotRegexpMatches()</code>, <code>assertRaisesRegexp()</code>,<br />
<code>assertIn()</code> / <code>assertNotIn()</code>, <code>assertDictContainsSubset()</code>, <code>assertAlmostEqual()</code> / <code>assertNotAlmostEqual()</code>.</p>
<p>Enfin <code>format()</code> commence à devenir une alternative valable à <code>%</code> car il propose maintenant des marqueurs sans noter d’index:</p>
<pre lang="python">>>> "{}, puis {} et finalement {}".format(*range(3))
'0, puis 1 et finalement 2'</pre>
<p>Et il ajoute le séparateur des milliers au mini-langage de formatage, mais pour la virgule uniquement. Par exemple, si avoir un nombre de 15 caractères minimum formater en tant que float, avec deux chiffres après la virgules, et donc les milliers sont groupés à l&#8217;américaine:</p>
<pre lang="python">>>> '{:15,.2f}'.format(54321)
'      54,321.00'</pre>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/quelques-innovation-de-python-3-backportees-en-python-2-7/feed/</wfw:commentRss>
		<slash:comments>4</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">2863</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2012/11/Pimp-My-Ride-43797.jpg" length="291183" type="image/jpg" />	</item>
		<item>
		<title>Les vues sur des collections en Python</title>
		<link>http://sametmax.com/les-vues-sur-des-collections-en-python/</link>
		<comments>http://sametmax.com/les-vues-sur-des-collections-en-python/#comments</comments>
		<pubDate>Sat, 03 Nov 2012 18:57:02 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[dict]]></category>
		<category><![CDATA[generators]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[strings]]></category>
		<category><![CDATA[views]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=2785</guid>
		<description><![CDATA[Python 3 introduit de nombreux changements qui ont été backportés dans Python 2.7. Parmis eux, les vues, qui sont un concept assez mal expliqué dans la documentation standard.]]></description>
				<content:encoded><![CDATA[<p>Python 3 introduit de nombreux changements qui ont été backportés dans Python 2.7. Parmi eux, les vues, qui sont un concept assez mal expliqué dans la documentation standard.</p>
<h2>Dictionary views</h2>
<p>Quand on voulait travailler sur les valeurs d&#8217;un dictionnaire en Python, on avait deux choix:</p>
<ul>
<li>faire <code>dict.values()</code> et récupérer une liste entière. Créant une liste entière en mémoire.</li>
<li>faire <code>dict.itervalues()</code>, et récupérer un générateur. Mais qui ne peut être lu qu&#8217;une fois.</li>
</ul>
<p>Les vues sont une solution intermédiaire: ce sont des objets qui prennent peu de mémoire, mais qui peuvent être lus plusieurs fois.</p>
<p>Exemple:</p>
<pre lang="python">>>> scores = {'foo': 1, 'bar': 0}
>>> val = scores.viewvalues()
>>> print val
dict_values([1, 0])
>>> 1 in val
True
>>> [x * 2 for x in val]
[2, 0]
</pre>
<p>Contrairement à une liste, les vues issues d&#8217;un dictionnaire ne supportent pas le slicing ou l&#8217;assignation et il n&#8217;y a aucune garantie d&#8217;ordre des éléments. De plus, elles ne peuvent être modifiées.</p>
<p>Bref, <strong>une vue ne contient rien</strong>, c&#8217;est juste un objet qui, quand on accède à son contenu, va le chercher dans le dictionnaire et vous le retourne. C&#8217;est ce qu&#8217;on appelle un objet proxy: il vous donne l&#8217;illusion d&#8217;accéder directement aux données pour vous faciliter la vie, généralement en vous les présentant sous une forme différente: ici un itérable.</p>
<p>On peut récupérer des vues pour les valeurs, mais également pour les clés et les couples clés / valeurs. Ces deux types de vues se comportent en plus comme des <a href="http://sametmax.com/ce-que-vous-ne-saviez-pas-sur-les-collections-en-python/">sets</a>:</p>
<pre lang="python">
>>> scores.viewitems()
dict_items([('foo', 1), ('bar', 0)])
>>> scores.viewkeys() | [3,]
set([3, 'foo', 'bar'])</pre>
<p>Puisqu&#8217;il est rare d&#8217;avoir besoin d&#8217;une vraie liste, et comme les vues sont une très bonne alternative aux générateurs, <code>dict.values</code> et consorts retournent des vues en Python 3.</p>
<p>Maintenant vous allez me dire &#8220;Mais si les vues sont une si bonne alternative aux générateurs, pourquoi on ne remplace pas tous les générateurs par des vues ?&#8221;. </p>
<p>Tout simplement parce que ce n&#8217;est pas possible. Un générateur est un mécanisme standard qui permet de produire des valeurs une par une. N&#8217;importe qui peut créer un générateur, car c&#8217;est un concept portable d&#8217;un problème à un autre. On peut l&#8217;appliquer à de nombreuses choses: algorithme, flux de données, fichier, etc. </p>
<p>Une vue n&#8217;est qu&#8217;un proxy qui permet de voir une <a href="http://sametmax.com/quest-ce-quune-structure-de-donnees/">structure de données</a> sous une autre forme. Il faut coder une vue par type de structure de données, car la vue va chercher les données dans cette structure quand on lui demande. Le code est donc différent à chaque fois.</p>
<p>Python ne permet pas de créer soi-même des vues, mais créer un proxy, c&#8217;est à dire un objet qui retourne les valeurs d&#8217;un autre objet quand on l&#8217;interroge, peut se faire à la main dans tout langage de programmation. Ainsi vous pourriez créer un proxy qui ressemble a une vue des clés d&#8217;un dico très simplement:</p>
<pre lang="python">
class keyview(object):

    def __init__(self, d):
        self.d = d

    def __iter__(self):
        return self.d.iterkeys()

>>> view = keyview(scores)
>>> for x in view:
...     print x
...     
foo
bar
>>> list(view)
['foo', 'bar']
>>> 
</pre>
<p>L&#8217;implémentation réelle de Python (en C&#8230;) ne fait pas vraiment grand chose de plus, juste un travail d&#8217;optimisation pour être plus rapide.</p>
<h2>memoryview</h2>
<p>Les memory views suivent le même principe, mais appliqué à toute structure de données qui supporte le buffer protocole (un certain nombre de méthodes avec un nom et un comportement défini par ce protocole) comme celles trouvées dans le module <code>struct</code> ou <code>array</code>. La structure de données la plus connue qui suit le buffer protocole est la chaîne de caractères.</p>
<pre lang="python">>>> s = 'Sam & Max eat the road with a Github fork'
>>> ms = memoryview(s)
>>> ms[-1]
'k'
>>> ms[:9]
<memory at 0x25ded60>
>>> ''.join(ms[:9])
'Sam & Max'</pre>
<p>Le principal intérêt de la memory view appliquée aux strings, c&#8217;est que tout slicing retourne une nouvelle memory view. On peut donc travailler sur des parties de la chaînes sans créer une nouvelle chaîne en mémoire.</p>
<p>En revanche, les chaînes unicodes ne sont pas supportées. Il vous faudra jouer avec <code>encode()</code> et <code>decode()</code>.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/les-vues-sur-des-collections-en-python/feed/</wfw:commentRss>
		<slash:comments>15</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">2785</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2012/11/fenetretravaux.jpg" length="392879" type="image/jpg" />	</item>
	</channel>
</rss>
