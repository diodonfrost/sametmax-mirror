<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" >

<channel>
	<title>composition &#8211; Sam &amp; Max</title>
	<atom:link href="http://sametmax.com/tag/composition/feed/" rel="self" type="application/rss+xml" />
	<link>http://sametmax.com</link>
	<description>Du code, du cul</description>
	<lastBuildDate>Thu, 05 Sep 2019 08:22:03 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.7</generator>
<site xmlns="com-wordpress:feed-additions:1">32490438</site>	<item>
		<title> Le guide ultime et définitif sur la programmation orientée objet en Python à l’usage des débutants qui sont rassurés par les textes détaillés qui prennent le temps de tout expliquer. Partie 5.</title>
		<link>http://sametmax.com/le-guide-ultime-et-definitif-sur-la-programmation-orientee-objet-en-python-a-lusage-des-debutants-qui-sont-rassures-par-les-textes-detailles-qui-prennent-le-temps-de-tout-expliquer-partie-5/</link>
		<comments>http://sametmax.com/le-guide-ultime-et-definitif-sur-la-programmation-orientee-objet-en-python-a-lusage-des-debutants-qui-sont-rassures-par-les-textes-detailles-qui-prennent-le-temps-de-tout-expliquer-partie-5/#comments</comments>
		<pubDate>Mon, 11 Feb 2013 17:38:28 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[composition]]></category>
		<category><![CDATA[heritage]]></category>
		<category><![CDATA[poo]]></category>
		<category><![CDATA[python]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=4495</guid>
		<description><![CDATA[La POO, c'est comme les poupées russes. Une fois qu'on a maîtrisé un concept, paf, y en a un autre qui se ramène derrière.
]]></description>
				<content:encoded><![CDATA[<p>Maestro, musique !</p>

<!-- iframe plugin v.4.3 wordpress.org/plugins/iframe/ -->
<iframe width="420" height="315" src="http://www.youtube.com/embed/XWE_VC9DpK0" frameborder="0" 0="allowfullscreen" scrolling="yes" class="iframe-class"></iframe>

<p>Prérequis :</p>
<ul>
<li>Avoir lu la <a href="http://sametmax.com/le-guide-ultime-et-definitif-sur-la-programmation-orientee-objet-en-python-a-lusage-des-debutants-qui-sont-rassures-par-les-textes-detailles-qui-prennent-le-temps-de-tout-expliquer-partie-4/">partie 4</a>.</li>
<li>Etre bien au point sur la notion de <a href="http://sametmax.com/valeurs-et-references-en-python/">références</a>.</li>
</ul>
<p>La POO, c&#8217;est comme les poupées russes. Une fois qu&#8217;on a maîtrisé un concept, paf, y en a un autre qui se ramène derrière.</p>
<h2>J&#8217;ai plusieurs mamans</h2>
<p>En ces temps de polémique sur l&#8217;autorisation du mariage entre êtres amoureux et consentants (par opposition à celui qu&#8217;on fait par convention sociale depuis des siècles), je vous propose de vous rappeler qu&#8217;une fois de plus les informaticiens sont en avance sur les mœurs.</p>
<p>D&#8217;abord parce qu&#8217;une communauté qui fait autant de links vers <a href="http://www.yougotrickrolled.com/">Never Gona Give You Up</a> est forcément pro gay par essence. Ensuite parce qu&#8217;une classe fille peut avoir plusieurs classes mères sans que ça choque personne.</p>
<p>Prenez ces deux classes qui passaient par là sans rien demander :</p>
<pre lang="python">class MouMoutte(object):

    type = 'top' # c'est tip top moumoutte

class Raoul(object):

    trop = 'cool'</pre>
<p>Hé merde, j&#8217;ai écris ça, et maintenant j&#8217;ai aucune idée de comment faire un code cohérent à partir de cet exemple à la con.</p>
<p>On annule tout.</p>
<p>On recommence.</p>
<p>Vous faites un jeu vidéo. Ça, ça parle bien. Et dedans vous avez des protections et des armes.</p>
<pre lang="python">class Arme(object):

    def __init__(self, nom, degat):

        self.nom = nom
        self.degat = degat

    def attaque(self, cible): # on retire les degâts de l'épee des points de vie
        cible.vie -= self.degat


class Protection(object):

    def __init__(self, nom, armure):

        self.nom = nom
        self.armure = armure

    def defend(self, degat): # on diminue les degâts, voire on les annule

        degat = degat - self.armure
        if degat < 0:
            return 0

        return degat

>>> epee = Arme('Epée Mana', degat=999)
>>> casque = Protection('Casque de Balduran', armure=1)</pre>
<p>C&#8217;est simpliste, mais vous voyez le tableau. Maintenant un connard de client arrive et vous sort une idée trop cool : il faudrait ajouter un barbare dans le jeu. Qui tape aussi avec son bouclier, parce que la concurrence le fait et qu&#8217;ils veulent pas se faire mettre un vent par Blizzard.</p>
<p>Enfer et Rutabaga ! Comment allons nous nous sortir de cette situation ?</p>
<p>Il y a moult manières de faire, mais l&#8217;une d&#8217;elle est d&#8217;utiliser l&#8217;<strong>héritage multiple</strong>, c&#8217;est-à-dire de créer une classe qui hérite des deux classes en même temps.</p>
<pre lang="python">class ProtectionOffensive(Arme, Protection):

    def __init__(self, nom, degat, armure):

        Arme.__init__(self, nom, degat) # appelle le __init__ de arme
        Protection.__init__(self, nom, armure) # appelle le __init de protection

        # comme on a appelé les deux __init__, on va avoir les attributs
        # settés dans les deux __init__ attachés à cette classe
</pre>
<p>Nous avons alors une classe qui possède les méthodes des deux classes parentes :</p>
<pre lang="python">
>>> bouclier = ProtectionOffensive('Bouclier du dragon', degat=10, armure=100)
>>> bouclier.degat
10
>>> bouclier.armure
100
>>> bouclier.defend(10)
0</pre>
<p>Ne cherchez pas compliqué, ça fait exactement ce que ça à l&#8217;air de faire : &#8220;copier&#8221; (oui bon, entre guillemets) le code de chaque parent dans l&#8217;enfant.</p>
<p>Néanmoins vous avez vu qu&#8217;il y a quelques subtilités, notamment la partie <code>__init__</code>.</p>
<p>Posez-vous deux minutes. Respirez. Concentrez-vous. Prêt ?</p>
<p>Les deux classes parentes ont une méthode <code>__init__</code>, mais <strong>Python ne peut en &#8220;copier&#8221; qu&#8217;une seule </strong>dans l&#8217;enfant. Il copie donc la première qu&#8217;il trouve. Il va prendre la liste des parents (ici: <code>Arme, Protection</code>), et la lire de gauche à droite. Il va regarder chaque parent, et si la méthode existe, il va la &#8220;copier&#8221; dans l&#8217;enfant.</p>
<p>Si il retrouve une méthode de même nom dans un des parents suivants, il l&#8217;ignore. (Je dis un DES parents suivants car vous pouvez avoir 10 parents si vous voulez).</p>
<p>Donc dans notre exemple, si je fais :</p>
<pre lang="python">class ProtectionOffensive(Arme, Protection):
    pass</pre>
<p><code>ProtectionOffensive</code> n&#8217;aura que la méthode <code>__init__</code> de <code>Arme</code>. Or ce n&#8217;est pas ce qu&#8217;on veut. On va donc overrider la méthode <code>__init__</code>, et dedans appeler la méthode <code>__init__</code> de <code>Arme</code> ET celle de <code>Protection</code>.</p>
<p>Cette syntaxe : <code>Classe.methode(self, args...)</code> que l&#8217;on retrouve dans <code>Arme.__init__(self, nom, degat)</code> est juste un moyen d&#8217;appeler spécifiquement la méthode du parent.</p>
<p>Dans la partie précédente, je vous ai montré qu&#8217;on pouvait faire cela avec <code>super()</code>. Or <code>super()</code> vous retournera la première méthode du premier parent qu&#8217;elle trouve : c&#8217;est le but de <code>super()</code>, de faire ça automatiquement sans se soucier de savoir qui est le premier parent à avoir une méthode du bon nom.</p>
<p>C&#8217;est utile car parfois c&#8217;est le parent du parent du parent qui a la méthode qu&#8217;on veut appeler. On ne connaît pas forcément son nom, ou alors on ne veut pas l&#8217;écrire en dur. Mais dans notre cas, on veut spécifiquement une méthode d&#8217;un parent en particulier, il faut donc l&#8217;écrire à la main.</p>
<p>D&#8217;une manière générale :</p>
<ul>
<li>Utilisez<code> super()</code> quand vous faites de l&#8217;héritage simple où que vous voulez juste appeler la méthode du premier parent venu sans vous soucier de son nom (car il peut être très haut dans la chaîne d&#8217;héritage).</li>
<li>Utilisez <code>Classe.methode(self, args...)</code> quand vous voulez spécifiquement appeler la méthode d&#8217;un parent en particulier.</li>
</ul>
<p>Faites attention !</p>
<p>Le <code>self</code> n&#8217;est pas au même endroit dans <code>super(ClassCourante, self).methode(args...)</code> et <code>ClasseParente.methode(self, args...)</code>. Et dans le premier cas, on passe la classe courante (que <code>super()</code> va analyser pour trouver les parents automatiquement), dans le cas suivant, on écrit le nom de la classe parente en dur.</p>
<p>Faites quelques tests avec des scripts bidons pour bien comprendre comment ça marche. Faites ça avec des classes toutes simples. Sinon le jour où vous aurez une classe compliquée, vous allez vous embrouiller.</p>
<h2>La composition (POO pour les vrais mecs)</h2>
<p>Jusqu&#8217;ici c&#8217;était un tuto avec des notions de base pour des petits geeks imberbes qui jouent avec des action figures fabriquées en Chine et achetées sur ebay. Mais maintenant nous allons voir la POO pour les vrais hommes, les barbus, ceux qui jouent avec des <a href="https://www.realdoll.com/">reals dolls</a> et qui n&#8217;ont pas peur de mettre des chaussettes dépareillées.</p>
<p>Voyez-vous, un objet, tout seul, il sert à rien. Il s&#8217;emmerde déjà, rien à foutre le samedi, nul part où sortir, tout ça. Mais surtout, il a personne pour prendre l&#8217;apéro. Non, dans un programme digne d&#8217;un vrai pastis, il faut plusieurs objets qui interagissent entre eux. En fait, plusieurs objets qui s&#8217;utilisent les uns les autres.</p>
<p>Retournez à notre exemple de jeu video :</p>
<pre lang="python">class HeroViril(object):

    # def __init__(self, nom, prenom, groupe_sanguin, signe_astrologique,
    #              couleur_preferee, tendance_sexuelle, culte,
    #              taille_de_la_troisieme_phallange_de_l_index_gauche)
    # TODO : voir le CDC avec le client pour confirmer les attributs du personnage
    def __init__(self, nom, vie, arme=None, protection=None):

        self.nom = nom
        self.vie = vie
        self.arme = arme
        self.protection = protection

    def combattre(self, ennemi):

        print "{} attaque {}".format(self.nom, ennemi.nom)

        while True:

            if self.arme:
                self.arme.attaque(ennemi)

            if ennemi.vie <= 0:
                break

            if ennemi.arme:
                ennemi.arme.attaque(self)

            if self.vie <= 0:
                break

        if self.vie > 0:
            print "Victoire de {}".format(self.nom)
        else:
            print "{} est mort comme une pov' merde".format(self.nom)</pre>
<p>Et là vous notez un truc, c&#8217;est que nous n&#8217;avons pas de méthode <code>attaque()</code> sur notre héros. Nous utilisons la méthode attaque d&#8217;un objet arme. Que l&#8217;on a en attribut.</p>
<p>C&#8217;est cela la composition : un objet, qui en fait est composé de plusieurs sous-objets. Dans notre cas, notre objet héros est aussi composé d&#8217;une arme et d&#8217;une protection, qui sont ses attributs. Il peut ainsi utiliser le comportement de ses objets pour faire le boulot à sa place : c&#8217;est ce qu&#8217;on appelle la délégation.</p>
<p>Reprenons notre code des armes, un peu adapté :</p>
<pre lang="python"># le code de l'armure ne change pas
class Protection(object):

    def __init__(self, nom, armure):

        self.nom = nom
        self.armure = armure

    def defend(self, degat):

        degat = degat - self.armure
        if degat < 0:
            return 0

        return degat


# on change le code de l'arme, si la cible a une protection
# cela diminue les degâts pris
class Arme(object):

    def __init__(self, nom, degat):

        self.nom = nom
        self.degat = degat

    def attaque(self, cible):

        # je mets aussi quelques prints pour le lulz
        if cible.protection:
            degat = cible.protection.defend(self.degat)
            print "{} - {} = {}".format(cible.vie, degat, cible.vie - degat)
            cible.vie -= degat
        else:
            print "{} - {} = {}".format(cible.vie, self.degat, cible.vie - self.degat)
            cible.vie -= self.degat</pre>
<p>Maintenant créons deux héros, armons-les, et faisons-les combattre :</p>
<pre lang="python">>>> gosu = HeroViril("Drizzt Do'Urden", 2000)
>>> gosu.arme = Arme('Lame Vorpale', 10)
>>> gosu.protection = Protection("Maille en Kevlar de mithril doré a l'adamantium", 10)
>>> noob_qui_repop = HeroViril("Bob", 200)
>>> noob_qui_repop.arme = Arme('Cure-dent', 1)
>>> noob_qui_repop.protection = Protection("Slip", 1)
>>> noob_qui_repop.combattre(gosu) # yaaaaaaaaaaaaaaaaaaaaaaa !

Bob attaque Drizzt Do'Urden
2000 - 0 = 2000
200 - 9 = 191
2000 - 0 = 2000
191 - 9 = 182
2000 - 0 = 2000
182 - 9 = 173
2000 - 0 = 2000
173 - 9 = 164
2000 - 0 = 2000
164 - 9 = 155
2000 - 0 = 2000
155 - 9 = 146
2000 - 0 = 2000
146 - 9 = 137
2000 - 0 = 2000
137 - 9 = 128
2000 - 0 = 2000
128 - 9 = 119
2000 - 0 = 2000
119 - 9 = 110
2000 - 0 = 2000
110 - 9 = 101
2000 - 0 = 2000
101 - 9 = 92
2000 - 0 = 2000
92 - 9 = 83
2000 - 0 = 2000
83 - 9 = 74
2000 - 0 = 2000
74 - 9 = 65
2000 - 0 = 2000
65 - 9 = 56
2000 - 0 = 2000
56 - 9 = 47
2000 - 0 = 2000
47 - 9 = 38
2000 - 0 = 2000
38 - 9 = 29
2000 - 0 = 2000
29 - 9 = 20
2000 - 0 = 2000
20 - 9 = 11
2000 - 0 = 2000
11 - 9 = 2
2000 - 0 = 2000
2 - 9 = -7
Bob est mort comme une pov' merde</pre>
<h2>Ok, j'ai pigé le principe, mais comment ça marche dans le détail ?</h2>
<p>Regardons la méthode combattre de plus près :</p>
<pre lang="python">    # elle attend un ennemi en paramètre, donc UN OBJET HeroViril
    # self est l'objet en cours, donc aussi un objet HeroViril
    def combattre(self, ennemi):

        print "{} attaque {}".format(self.nom, ennemi.nom)

        # une petite boucle infinie. Warning, c'est un tuto. Ne faites pas
        # ça chez vous les enfants.
        # cette boucle loop pour toujours si il n'y a pas d'attribut arme donc
        # ceci n'est qu'un exemple. Hein ? Noté ? Les deux du fond là ?
        while True:

            # on donne le premier coup à la personne qui attaque (l'objet en
            # cours). On vérifie qu'il a une arme. Si c'est le cas,
            # on appelle la méthode de l'arme "attaque()", et on lui passe
            # en paramètre l'ennemi.
            if self.arme:
                self.arme.attaque(ennemi)

            # condition de sortie de la boucle sur la vie du héros qui a pris
            # le coup
            if ennemi.vie <= 0:
                break

            # ensuite on fait pareil à l'envers pour donner une chance à l'autre
            # de répliquer : on vérifie que l'ennemi a une arme, et si c'est
            # le cas, on applique la méthode "attaque" de l'arme à l'objet
            # en cours
            if ennemi.arme:
                ennemi.arme.attaque(self)

            # condition de sortie de la boucle sur la vie du héros qui a pris
            # le coup
            if self.vie <= 0:
                break

        # une fois sorti de la boucle, on vérifie le niveau de vie pour
        # désigner le vainqueur
        if self.vie > 0:
            print "Victoire de {}".format(self.nom)
        else:
            print "{} est mort comme une pov' merde".format(self.nom)</pre>
<p>Donc combattre utilise un objet arme, et appelle sa méthode <code>attaque()</code> sur un héros (j'ai viré les prints pour rendre le truc plus clair) :</p>
<pre lang="python">    # self est l'objet en cours, donc l'arme.
    # cible est un héros, puisqu'on l'a passé en paramètre.
    def attaque(self, cible):

        # si la cible (l'objet héros) a un attribut protection,
        # les dégâts retirés sont diminués (ce calcul est fait par la protection)
        if cible.protection:
            cible.vie -= cible.protection.defend(self.degat)

        # sinon, on retire les dégâts à la vie de la cible (le héros)
        # directement
        else:
            cible.vie -= self.degat</pre>
<p>Diantre ! La méthode attaque utilise elle-même la méthode <code>defend(</code>) de la protection :</p>
<pre lang="python">    # self est l'objet en cours, donc la protection.
    # degat est un simple int.
    def defend(self, degat):
        # on retourne les degâts infligés, moins la protection
        return degat - self.armure</pre>
<p>Pour comprendre tous ces codes, il faut bien piger deux trucs :</p>
<ul>
<li>Il y a 6 objets. Deux héros, deux armes, et deux protections. Les héros ont les armes / protections comme attributs.</li>
<li>On se sert des méthodes des armes pour attaquer. On passe les héros en paramètres à ces méthodes. Les armes se servent des protections des héros pour calculer les dégats.</li>
</ul>
<p>Ce dernier point est le plus important. Si vous comprenez ça, vous avez maîtrisé le plus important de la POO. Relisez le plusieurs fois :</p>
<p>Les héros ont une référence aux armes. Et ensuite, on passe une référence des héros aux armes. Les armes retirent de la vie à ces héros, non sans calculer les dégâts en fonction de la protection qu'ils portent.</p>
<p>Les objets ont tous des références les uns vers les autres. <strong>Ils se manipulent tous les uns les autres.</strong></p>
<p>Cela fait bizarre car dans la vie une épée ne manipule pas un héros (bon, je connais peu d'elfes noirs IRL aussi). On comprend facilement qu'un héros ait un attribut 'épée', mais il est difficile de comprendre qu'une épée ait une méthode, et que le paramètre de cette méthode soit un héros.</p>
<p>C'est un concept purement informatique : la logique des dégâts est codée dans l'arme, pas dans le héros. L'avantage de cette architecture, c'est que si vous changez l'arme, vous changez toute la logique des dégâts. Par exemple, vous rajoutez une arme empoisonnée :</p>
<pre lang="python">class ArmeMegaEmpoisonnee(Arme):

    def __init__(self, nom, degat, poison=100000):
        super(ArmeMegaEmpoisonnee, self).__init__(nom, degat)
        self.poison = poison


    def attaque(self, cible):

        # on prend les degâts une premiere fois
        super(ArmeMegaEmpoisonnee, self).attaque(cible)

        # puis on prend les dégâts du poison
        cible.vie -= self.poison</pre>
<p>Cette arme fait plus de dégâts. Son mécanisme pour faire des dégâts est différent. Il suffit d'équiper un héros avec l'arme (en changeant l'attribut) pour que ce nouveau calcul de dégâts soit pris en compte.</p>
<pre lang="python">>>> noob_qui_repop.vie = 200 # rePOP !
>>> noob_qui_repop.arme = ArmeMegaEmpoisonnee('Cheat Code', 1)
>>> noob_qui_repop.combattre(gosu) # Vengeance !
Bob attaque Drizzt Do'Urden
2000 - 0 = 2000
Victoire de Bob</pre>
<p>Ce qu'il faut retenir : on peut mettre des objets en tant qu'attributs d'objets. Il n'y a pas de limite dans les nombres d'objets à mettre, leur mélange, les niveaux d'imbrications, etc. On peut mettre des objets, dans des objets, dans des objets... C'est la composition.</p>
<p>Et les objets peuvent utiliser les méthodes des autres objets. Et on peut passer des objets comme paramètres à des méthodes. C'est la délégation.</p>
<p>C'est la partouze des objets, quoi.</p>
<p>On peut mettre des objets dans des sets, des dicos, des listes... Par juste dans des attributs. Il y en a des choses à faire !</p>
<h2>Choisir entre l'héritage et la composition</h2>
<p>Les deux techniques permettent de réutiliser du code, mais pas de la même façon. Aucune règle générale ne tient la route dans tous les cas, mais un bon point de départ est de se dire que :</p>
<ul>
<li>Si vous avez deux objets de même nature et que l'un est une spécialisation de l'autre (Garçon est une spécialisation de Personne, Voiture est une spécialisation de véhicule, Clio est une spécialisation de voiture, Reptincel est une spécialisation de pokemon, foxmask est une spécialisation du correcteur orthographique de Word, etc), alors utilisez l'héritage.</li>
<li>Si vous avez deux objets qui échangent des données, qui sont associés ou qui dans la vie réelle sont des 'part de' (un article est une partie d'un blog, Raymond Barre est membre d'un parti, Raymond fait partie d'un bar, <del>le bar et la raie font parti des poissons ah non ça c'est une spécialisation</del>, etc), utilisez la composition.</li>
</ul>
<p>Il y a aussi, quelque part, dans le lointain pays des enculeurs de mouche, une différence entre l’agrégation (qu'on a pas vu) et la composition. Vous vivrez très bien en considérant que c'est la même chose.</p>
<h2>Le design pattern "stratégie"</h2>
<p>Vous entendrez parfois parler du motif de conception "stratégie". C'est en fait une mise en application abstraite de la composition.</p>
<p>Normalement la composition s'utilise avec des "part de" concrètes. Vous avez une voiture : elle est composée d'objets pneus, d'un objet moteur, etc.</p>
<p>Le design pattern stratégie est l'extraction d'une part du comportement d'un objet pour le mettre dans un autre objet, mais la nature de l'objet importe peu. Ceci est fait purement pour découpler le comportement de l'objet.</p>
<p>On a vu plus haut que changer l'arme permet de changer le calcul des dégâts. C'est ce type de résultat qu'on vise avec le design pattern strategy.</p>
<pre lang="python">import os

class ParseurXml(object):
    ...

class ParseurJson(object):
    ...


class ParseurDeFichier(object):

    _strategy = { # les stratégie par défaut
        'json': ParseurXml,
        'xml': ParseurJson
    }

    def __init__(self, fichier, strategy=None):

        self.fichier = fichier
        # on récupère l'extension du fichier
        path, ext = os.path.splitext(fichier)

        # Strategy est une classe de parseur
        # on la récupère depuis les paramètres ou selon
        # l'extension
        Strategy = strategy or self._strategy[ext.lstrip('.')]
        # on instancie notre classe de strategie
        self.strategy = Strategy(fichier)

    def parse(self):
        # on délègue le boulot à la stratégie
        self.strategy.parse()</pre>
<p>La ligne la plus importante est :</p>
<pre lang="python">Strategy = strategy or self._strategy[ext]</pre>
<p>Ici on dit récupérer la stratégie de parsing en paramètre, ou sinon, la bonne en fonction de l'extension de fichier. On charge donc une classe dynamiquement, on va créer un objet à partir de cette classe. Et c'est cet objet à qui on va déléguer le comportement du parseur :</p>
<pre lang="python">    def parse(self):
        self.strategy.parse()</pre>
<p>On utilise l'objet dynamiquement pour gérer tout le parsing. On peut ainsi choisir un parseur à la volée.</p>
<p>La pattern strategy mélange donc composition (l'objet strategy est une part de l'objet général), délégation (l'objet général utilise le comportement de l'objet strategy) et d'injection de dépendance (on peut changer l'algo à la volée, il suffit de changer de stratégie).</p>
<p>Bon, ça c'était le mode hard. C'est pas grave si vous finissez pas le niveau toute de suite. Mettez pause. Allez pisser un coup et revenez- plus tard, les continues sont infinis sur le blog.</p>
<p>C'est bon, vous êtes chaud ? Prochaine stations, <a href="http://sametmax.com/le-guide-ultime-et-definitif-sur-la-programmation-orientee-objet-en-python-a-lusage-des-debutants-qui-sont-rassures-par-les-textes-detailles-qui-prennent-le-temps-de-tout-expliquer-partie-6/">le monde merveilleux des méthodes magiques</a>.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/le-guide-ultime-et-definitif-sur-la-programmation-orientee-objet-en-python-a-lusage-des-debutants-qui-sont-rassures-par-les-textes-detailles-qui-prennent-le-temps-de-tout-expliquer-partie-5/feed/</wfw:commentRss>
		<slash:comments>64</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">4495</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2013/02/magic_warmhanz.jpg" length="172488" type="image/jpg" />	</item>
	</channel>
</rss>
