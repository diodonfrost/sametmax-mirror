<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" >

<channel>
	<title>http &#8211; Sam &amp; Max</title>
	<atom:link href="http://sametmax.com/tag/http/feed/" rel="self" type="application/rss+xml" />
	<link>http://sametmax.com</link>
	<description>Du code, du cul</description>
	<lastBuildDate>Thu, 05 Sep 2019 08:22:03 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.7</generator>
<site xmlns="com-wordpress:feed-additions:1">32490438</site>	<item>
		<title>Pourquoi obliger le SSL par défaut est une grosse connerie</title>
		<link>http://sametmax.com/pourquoi-obliger-le-ssl-par-defaut-est-une-grosse-connerie/</link>
		<comments>http://sametmax.com/pourquoi-obliger-le-ssl-par-defaut-est-une-grosse-connerie/#comments</comments>
		<pubDate>Wed, 06 May 2015 09:06:13 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Philo et culture]]></category>
		<category><![CDATA[chrome]]></category>
		<category><![CDATA[firefox]]></category>
		<category><![CDATA[http]]></category>
		<category><![CDATA[https]]></category>
		<category><![CDATA[mozilla]]></category>
		<category><![CDATA[ssl]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=16175</guid>
		<description><![CDATA[Chrome et Mozilla parlent de limiter les fonctionnalités de leurs navigateurs sur les sites qui n'utilisent pas SSL.]]></description>
				<content:encoded><![CDATA[<p>Chrome et Mozilla <a href="https://blog.mozilla.org/security/2015/04/30/deprecating-non-secure-http/">parlent</a> de limiter les fonctionnalités de leurs navigateurs sur les sites qui n&#8217;utilisent pas SSL.</p>
<p>Sur le papier, c&#8217;est pavé de bonnes intentions : forcer les auteurs de sites à chiffrer la communication entre le serveur et le client. Plus de sécurité pour les utilisateurs, tant pis pour les dev paresseux, pas vrai ?</p>
<p><strong>Sauf que HTTPS fonctionne sur le principe d&#8217;autorités centrales</strong>. Vous devez obtenir un certificat auprès d&#8217;une autorité de confiance, sans quoi le navigateur va afficher ça :<br />
<div id="attachment_16176" style="width: 700px" class="wp-caption aligncenter"><a href="http://sametmax.com/wp-content/uploads/2015/05/firefoxCertError.jpg" class="grouped_elements" rel="tc-fancybox-group16175"><img src="http://sametmax.com/wp-content/uploads/2015/05/firefoxCertError.jpg" alt="This connection is untrusted" width="690" height="431" class="size-full wp-image-16176" /></a><p class="wp-caption-text">Michou ne va pas lire ce texte, encore moins chercher et trouver comment accéder au site. Elle va courir. Un virus !</p></div></p>
<p>Les moteurs de recherche vont vous plomber, l&#8217;utilisateur va fuir, bref, votre site est mort.</p>
<p>Et c&#8217;est la que ça devient fun, car les autorités centrales sont des organismes privés, et il n&#8217;y en a pas beaucoup. Ils ne sont pas tenus de vous filer un certificat, et peuvent le retirer à tout moment. </p>
<p>En clair, <strong>forcer SSL partout, c&#8217;est donner la main à quelques grosses boites pour décider qui a le droit d&#8217;être sur le Web ou pas.</strong> Vous voulez faire un truc qui ne leur plait pas ? Attention, montrer un tableau classique avec des nichons ne plait pas à Apple, faire un noeud Tor ne plait pas à Amazon, les bitcoins ne plaisent pas à Paypal et être gay ne plait pas à plein de gouvernements.</p>
<p>Toutes ces entités travaillent main dans la main avec les autorités de certification, et avoir Mozilla en <a href="https://letsencrypt.org/">proposer</a> une n&#8217;y changera rien. Si vous faites un truc que ces gens ne veulent pas, vous effacer du Web sera aussi facile que de faire pression pour révoquer votre certificat.</p>
<p>Sans jugement. Sans procès. Sans recours possible.</p>
<p>Le Web deviendra un app store.</p>
<p>EDIT : </p>
<p>Je rajoute mon commentaire sur let&#8217;s encrypt ici sinon je sens que tout le monde va radoter</p>
<blockquote><p>L’article a un lien qui pointe vers let’s encrypt. Ca ne change rien : c’est centralisé, privé, et subira des pressions comme tous les autres. J’aime Mozilla, j’ai confiance en eux, mais ils n’ont aucun moyen de garantir la neutralité de let’s encrypt, ne serait que par rapport aux gouvernements.</p>
<p>Et puis quoi ? A la fin tous les sites “border line” seront chez eux ? Comme ça bam, un bon single point of failure à attaquer pour tout faire tomber d’un coup ?</p>
<p>FBI. FBI. FBI.</p></blockquote>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/pourquoi-obliger-le-ssl-par-defaut-est-une-grosse-connerie/feed/</wfw:commentRss>
		<slash:comments>47</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">16175</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2015/05/dgggmto.gif" length="154990" type="image/jpg" />	</item>
		<item>
		<title>Le don du mois : Python requests</title>
		<link>http://sametmax.com/le-don-du-mois-python-requests/</link>
		<comments>http://sametmax.com/le-don-du-mois-python-requests/#comments</comments>
		<pubDate>Wed, 04 Feb 2015 11:55:58 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Philo et culture]]></category>
		<category><![CDATA[argent]]></category>
		<category><![CDATA[don]]></category>
		<category><![CDATA[http]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[requests]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=15846</guid>
		<description><![CDATA[Il n'y aucune cohérence dans ma manière de donner. Je le fais au fil de l'eau, anarchiquement. Parfois j'oublies pendant des mois et des mois.]]></description>
				<content:encoded><![CDATA[<p>Il n&#8217;y aucune cohérence dans ma manière de donner. Je le fais au fil de l&#8217;eau, anarchiquement. Parfois j&#8217;oublie pendant des mois et des mois.</p>
<p>Là, je me baladais sur l&#8217;<a href="http://docs.python-requests.org/en/latest/user/quickstart/">excellente documentation</a> de la non moins excellente lib requests, à la recherche du one-liner qui allait, encore une fois, me faire gagner un bon quart d&#8217;heure.</p>
<p>Et j&#8217;ai vu un bouton &#8220;Buy request pro&#8221;.</p>
<p>Curieux. Il y a plus mieux que le meilleur de requests ?</p>
<p>Je clique, et en fait le bouton est juste là pour proposer de supporter requests. On &#8220;achète&#8221; la lib gratuite :)</p>
<p>Le minimum est $12, ce qui est fort raisonnable considérant que ce petit bout de code m&#8217;a sauvé la mise un million de fois :</p>
<ul>
<li>Pas besoin de se soucier de l&#8217;encoding du payload.</li>
<li>Traitement élégant des headers.</li>
<li>Api super simple et propre.</li>
<li>Doc excellente.</li>
<li>Ergonomie mettant les cas les plus courants à portée de main.</li>
<li>Automatisation des choses importantes comme les redirections ou les cookies.</li>
<li>Fonctions avancées pour les cas compliqués comme la vérification SSL.</li>
<li>Extensibilité.</li>
<li>Un claque pédagogique qui a influencé toute la communauté Python.</li>
</ul>
<p>Bref, 10 euros, c&#8217;est le prix de mon amour en février. Je suis un mec facile.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/le-don-du-mois-python-requests/feed/</wfw:commentRss>
		<slash:comments>4</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">15846</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2015/02/be-my-valentine-its-not-going-to-suck.jpg" length="37512" type="image/jpg" />	</item>
		<item>
		<title>Utiliser requests de manière non bloquante facilement</title>
		<link>http://sametmax.com/utiliser-requests-de-maniere-non-bloquante-facilement/</link>
		<comments>http://sametmax.com/utiliser-requests-de-maniere-non-bloquante-facilement/#comments</comments>
		<pubDate>Wed, 21 Jan 2015 07:17:41 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[asynchrone]]></category>
		<category><![CDATA[http]]></category>
		<category><![CDATA[non-bloquant]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[requests]]></category>
		<category><![CDATA[thread]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=15797</guid>
		<description><![CDATA[En attendant le dossier sur la programmation non bloquante, voici une petite lib qui résout un cas décole : faire une requête HTTP sans bloquer avec une jolie API, en pur Python.]]></description>
				<content:encoded><![CDATA[<p>En attendant le dossier sur la programmation non bloquante, voici une petite lib qui résout un cas d&#8217;école : faire une requête HTTP sans bloquer avec une jolie API, en pur Python.</p>
<p>Pour ça, on dégaine <a href="http://sametmax.com/votre-python-aime-les-pip/">pip</a> et installe <a href="https://pypi.python.org/pypi/requests-futures/0.9.0">requests-futures</a>, un plugin pour la célèbre lib <a href="http://sametmax.com/sept-petites-libs-qui-changent-la-vie-dun-dev-python/">requests</a> qui fonctionne avec Python 2 et 3 :</p>
<pre lang="bash">pip install requests-futures</pre>
<p>requests-futures va créer pour vous une pool de workers (2 par défaut) et quand vous faites une requête, la lib vous retourne un objet <a href="http://sametmax.com/deferred-future-et-promise-le-pourquoi-le-comment-et-quand-est-ce-quon-mange/">future</a> qui vous permet d&#8217;attacher un <a href="http://sametmax.com/quest-ce-quun-callback/">callback</a>.</p>
<p>Fiou, le nombre de liens référant à d&#8217;autres articles du blog est en train d&#8217;exploser.</p>
<p>Exemple :</p>
<pre lang="python">import time
from requests_futures.sessions import FuturesSession

# Cette session est notre point d'entrée, c'est elle
# qui gère nos workers. Faites help(FuturesSession)
# pour voir ses paramètres.
session = FuturesSession()

# Les URLs sur lesquelles on va faire
# nos requêtes
URLs = [
    "http://sametmax.com",
    "http://sebsauvage.net",
    "http://indexerror.net",
    "http://afpy.org",
    "http://0bin.net"
]

# Notre callback qui sera appelé quand une 
# des requêtes sera terminée. Il reçoit
# l'objet future pour seul paramètre
def faire_un_truc_avec_le_resultat(future):
    # On est juste intéressé par le résutlat, qui
    # est un objet response typique de la lib
    # request
    response = future.result()
    print(response.url, response.status_code)

# On traite chaque URL. Comme on a 2 workers,
# on pourra traiter au mieux 2 URLs en parallèle,
# mais toujours sans bloquer le programme
# principal
for url in URLs:
    # On fait notre requête GET
    future = session.get(url)
    # On rajoute le callback à appeler quand
    # le résultat de la requête arrive.
    # La flemme de faire la gestion des erreurs.
    future.add_done_callback(faire_un_truc_avec_le_resultat)

# Juste pour montrer que c'est bien non bloquant
for x in range(10):
    print(x)
    time.sleep(1)</pre>
<p>Output :</p>
<pre>0
1
(u'http://sebsauvage.net/', 200)
(u'http://sametmax.com/', 200)
2
(u'http://indexerror.net/', 200)
(u'http://0bin.net/', 200)
(u'http://www.afpy.org/', 200)
3
4
5
6
7
8
9</pre>
<p>On remerciera turgon37 pour <a href="http://indexerror.net/357/comment-passer-une-valeur-entre-threads">sa question</a> sur IndexError qui m&#8217;a amené à écrire cet article.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/utiliser-requests-de-maniere-non-bloquante-facilement/feed/</wfw:commentRss>
		<slash:comments>12</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">15797</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2015/01/images.jpeg" length="12961" type="image/jpg" />	</item>
		<item>
		<title>Qu&#8217;est-ce que les websockets et à quoi ça sert ?</title>
		<link>http://sametmax.com/quest-ce-que-les-websockets-et-a-quoi-ca-sert/</link>
		<comments>http://sametmax.com/quest-ce-que-les-websockets-et-a-quoi-ca-sert/#comments</comments>
		<pubDate>Tue, 30 Dec 2014 04:51:57 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[http]]></category>
		<category><![CDATA[javascript]]></category>
		<category><![CDATA[protocol]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[web]]></category>
		<category><![CDATA[websocket]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=15615</guid>
		<description><![CDATA[<blockquote>Le protocole WebSocket vise à développer un canal de communication full-duplex sur un socket TCP.</blockquote>

LOL. C'est clair non ?

Vous inquiétez pas, tonton Sam est là.]]></description>
				<content:encoded><![CDATA[<blockquote><p>Le protocole WebSocket vise à développer un canal de communication full-duplex sur un socket TCP.</p></blockquote>
<p>LOL. C&#8217;est clair non ?</p>
<p>Vous inquiétez pas, tonton Sam est là.</p>
<p>Le Web a évolué. On est passé de Gopher a HTTP 1 puis 1.1. Et on a eu AJAX pour rafraîchir la page sans tout recharger.</p>
<p>Et maintenant on a des apps complètes qui font des centaines de requêtes au serveur alors même que l&#8217;utilisateur ne change pas de page. D&#8217;ailleurs, je parie que plein de gens ne savent même plus ce qu&#8217;est une page&#8230;</p>
<p>Le problème c&#8217;est qu&#8217;AJAX, c&#8217;est toujours HTTP, et HTTP est sans état (stateless) : il ne garde aucune information en mémoire d&#8217;une requête à l&#8217;autre. Ça a des avantages, mais cela implique qu&#8217;à chaque requête, il faut ouvrir une connexion et la refermer. Ce qui bouffe quelques ms à chaque fois, et d&#8217;autant plus si on utilise SSL.</p>
<p>Une autre limite, c&#8217;est que le serveur ne peut pas envoyer de données au client (ici le navigateur) si le client ne fait pas une requête au préalable. Du coup, pour savoir si il y a quelque chose de nouveau, le navigateur doit régulièrement faire des requêtes au serveur ou utiliser des gros hacks comme le long polling.</p>
<p>Les websockets (c&#8217;est un abus de langage, on devrait parler du protocole Websocket) ont été créés pour répondre à ces besoins : elles permettent d&#8217;ouvrir une connexion permanente entre le navigateur et le serveur. Ainsi, chaque requête est plus rapide, et plus légère. En prime, le serveur peut envoyer des requêtes au navigateur pour le prévenir qu&#8217;il y a du nouveau.</p>
<p>Ceci permet de faire tout ce que permettait de faire AJAX mais en plus rapide, et en plus léger. Et également d&#8217;envoyer des notifications (ce contenu a changé, un message est arrivé, l&#8217;autre joueur a fait cette action&#8230;) au navigateur au moment où l&#8217;événement se produit.</p>
<p>En gros, de faire des apps Web quasi temps réel.</p>
<p>Il existe d&#8217;autre technos pour faire cela : applets Java, flash, comet, server sent events&#8230;</p>
<p>Mais aucune n&#8217;ont décollé. Websocket est donc aujourd&#8217;hui la solution de facto.</p>
<h2>Caractéristiques</h2>
<p>Le protocole Websocket utilise l&#8217;abréviation <code>ws</code> et <code>wss</code> si SSL, les URLs vers des endpoints websocket ressemblent donc à : <code>ws://domaine.tld/chemin/vers/truc/</code>.</p>
<p>Intelligemment, il utilise un handshake compatible avec celui de HTTP, permettant à un serveur de gérer les deux sur les mêmes ports. Donc on peut faire du Websocket sur le port 80 et 443. Néanmoins, certains proxy se gourent quand ils voient du websocket non chiffré et gauffrent votre connexion en la traitant comme du HTTP. Donc si vous voulez une app solide, investissez dans un certif SSL.</p>
<p>Tout ça fonctionne à partir de IE10. Notez comme IE est devenu le standard de ce qui ce fait de moins bien à tel point que je n&#8217;ai même pas besoin de vous parler des autres, vous savez que ça marche. Il existe en plus des <a href="https://github.com/gimite/web-socket-js">plugins flash</a> pour simuler des websockets sur les navigateurs anciens, c&#8217;est à dire les encore plus vieux IE.</p>
<p>Par défaut, les websockets permettent de faire de requêtes crossdomain, contrairement à AJAX. Avec les nouvelles apps qui utilisent NodeJS en local (comme <a href="http://getpopcornti.me/">popcorntime</a>) on peut imaginer une nouvelle type d&#8217;attaque : une page web qui se connecte à un serveur websocket local de votre machine. Comme les websockets sont souvent utilisées pour du RPC, il y a du potentiel.</p>
<h2>Bon, ta gueule, et montre le code</h2>

<!-- iframe plugin v.4.3 wordpress.org/plugins/iframe/ -->
<iframe width="100%" height="300" src="http://jsfiddle.net/rpecs5f1/embedded/result,js" allowfullscreen="allowfullscreen" frameborder="0" scrolling="yes" class="iframe-class"></iframe>

<p>Vous noterez que ce qui prend du temps dans l&#8217;exemple c&#8217;est la connexion, qu&#8217;on ne fait qu&#8217;une fois. Ensuite l&#8217;échange de données est super rapide.</p>
<p>Ceci est un exemple Javascript, mais un client websocket n&#8217;est pas forcément un navigateur. En fait, c&#8217;est très précisément le cas avec <a href="http://sametmax.com/presentation-de-wamp-round-2/">WAMP</a>, dont les clients peuvent être des programmes Python, Objective C, Java, C++, etc. L&#8217;avantage de WAMP, c&#8217;est qu&#8217;il automatise toute la machinerie pour découper la logique de son programme en divers fonctions et services, plutôt que d&#8217;avoir à tout faire à la main avec <code>send()</code> et <code>onmessage()</code>.</p>
<p>Dans tous les cas, il vous faudra un serveur qui supporte les Websockets pour l&#8217;utiliser. En Python, c&#8217;est Tornado ou Twisted (sur lequel est basé le serveur WAMP crossbar). En Javascript, c&#8217;est NodeJS. Quoi qu&#8217;il en soit, il vous faut un logiciel qui gère l&#8217;IO de manière <a href="http://sametmax.com/quelle-est-la-difference-entre-bloquer-et-en-cours-dexecution/">non bloquante</a>, car il y a de nombreuses connexions ouvertes en simultanées, si on veut que ça soit performant.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/quest-ce-que-les-websockets-et-a-quoi-ca-sert/feed/</wfw:commentRss>
		<slash:comments>9</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">15615</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2014/12/ybWpMif.jpg" length="81034" type="image/jpg" />	</item>
		<item>
		<title>Bridge HTTP/WAMP</title>
		<link>http://sametmax.com/bridge-httpwamp/</link>
		<comments>http://sametmax.com/bridge-httpwamp/#comments</comments>
		<pubDate>Mon, 29 Dec 2014 10:07:59 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[bridge]]></category>
		<category><![CDATA[http]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[wamp]]></category>
		<category><![CDATA[wamp.ws]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=13072</guid>
		<description><![CDATA[Le principe : faire un client WAMP qui soit aussi client HTTP avec une API REST.]]></description>
				<content:encoded><![CDATA[<p>Il y a 4 gros freins à l&#8217;adoption de <a href="http://sametmax.com/presentation-de-wamp-round-2/">WAMP</a> :</p>
<ol>
<li>L&#8217;incompréhension de la techno. Les gens ne voient pas à quoi ça sert, ce qu&#8217;ils peuvent faire avec, et ont peur. Logique. Je vais pas les blâmer, c&#8217;est pareil avec toute nouvelle techo. S&#8217;investir dans un nouveau truc a un coût, surtout un truc jeune.</li>
<li>La doc. je vais travailler sur la question, mais c&#8217;est un travail de fond.</li>
<li>L&#8217;API : ça va avec les deux points plus haut. Il faut quelque chose de plus haut niveau. L&#8217;API <a href="http://sametmax.com/introduction-a-wamp-en-python/">flaskesque</a> est un bon début, il faut maintenant continuer dans ce sens.</li>
<li>L&#8217;intégration avec les anciennes technos. Par exemple, un site Django. Personne n&#8217;a envie de mettre toute son ancienne stack à la poubelle.</li>
</ol>
<p>Toute les libs qui introduisent une nouvelle façon de travailler rencontrent ce problème. Quand les ORM sont sortis, c&#8217;était pareil. Quand les Django et Rails, et Symfony sont sortis, c&#8217;était pareil.</p>
<p>Mais puisqu&#8217;on le sait, on peut agir.</p>
<p>Les 3 premiers points ont déjà un début de solution, ce qui nous intéresse c&#8217;est donc le 4ème point.</p>
<p>Il y a de nombreuses choses à faire pour l’intégration : authentification, actions bloquantes, communications&#8230;</p>
<p>On ne peut pas tout résoudre d&#8217;un coup, mais une solution qui ratisse large serait de créer un bridge HTTP/WAMP.</p>
<p>Le principe : faire un client WAMP qui soit aussi client HTTP avec une API REST.</p>
<h2>Fonctionnement</h2>
<p>En envoyant des requêtes HTTP avec un <a href="https://github.com/progrium/pyjwt">webtoken</a> pour s&#8217;authentifier, on peut faire un register/subscribe/call/publish sur le bridge en spécifiant une URL de callback. Le bridge transmet tout ça à routeur WAMP. Quand un événement arrive sur le bridge qui concerne une des URLs de callback, il fait une requête sur l&#8217;URL avec les infos arrivées via WAMP.</p>
<p>API :</p>
<p><code>POST /register/</code></p>
<pre lang="javascript">{
    // token d'authentification
    token: "fdjsklfqsdjm",
    // On enregistre des urls de callbacks pour chaque "function" exposées en RPC
    // Quand le bridge reçoit un appel RPC via WAMP, il fera une requête POST
    // sur la bonne URL. Votre app récupère les données via POST, et retourne
    // du JSON que le bridge va transmettre via WAMP.
    endpoints: {
        "nom_fonction_1":  "http://localhost:8080/wamp/rpc/nom_fonction_1/",
        "nom_fonction_2":  "http://localhost:8080/wamp/rpc/nom_fonction_2/"
    }
}</pre>
<p><code>POST /subscribe/</code></p>
<pre lang="javascript">{
    token: "fdjsklfqsdjm",
    // On enregistre des urls de callbacks chaque abonnement à un topic.
    // Quand le bridge reçoit un message PUB via WAMP, il fera une requête POST
    // sur la bonne URL. Votre app récupère les données via POST.
    endpoints: {
        "nom_fonction_1":  "http://localhost:8080/wamp/pub/nom_fonction_1/",
        "nom_fonction_2":  "http://localhost:8080/wamp/pub/nom_fonction_2/"
    }
}</pre>
<p><code>POST /call/nom_fonction/</code></p>
<pre lang="javascript">{
    token: "fdjsklfqsdjm",
    // Le bridge fera l'appel RPC, récupère la valeur de retour, et la renvoie
    // à cette URL via POST ou une erreur 500 en cas d'exception.
    callback: "http://localhost:8080/wamp/callback/nom_fonction",
    // Les params à passer à l'appel RPC
    params: ['param1', 'param2']
}</pre>
<p><code>POST /publish/nom_sujet/</code></p>
<pre lang="javascript">{
    token: "fdjsklfqsdjm",
    // Le bridge fera la publication WAMP
    // Les params à passer lors de la publication
    params: ['param1', 'param2']
}</pre>
<p>On peut rajouter des fioritures : recharger le fichier de config qui contient les API keys, se désabonner, désinscrire un callback RPC, etc. </p>
<p>Bien entendu, du fait d&#8217;avoir un intermédiaire, c&#8217;est peu performant, mais suffisant pour permettre une communication entre des apps existantes et vos apps WAMP et mettre un pied dedans.</p>
<h2>Intégration poussée</h2>
<p>Ceci permet une intégration générique, de telle sorte que tout le monde puisse intégrer son app facilement avec quelques requêtes HTTP. Néanmoins, avoir un plugin pour son framework plug and play faciliterait la vie de beaucoup de gens.</p>
<p>Donc la partie 2, c&#8217;est de faire des apps pour les frameworks les plus courants qui wrappent tout ça.</p>
<p>Par exemple, pour Django, ça permettrait de faire :</p>
<p><code>settings.py</code></p>
<pre lang="python">WAMP_BRIDGE_URL = "http://localhost:8181/"</pre>
<p><code>urls.py</code></p>
<pre lang="python">from wamp_bridge.adapters.django import dispatcher

urlpatterns += ('',
    url('/wamp/, dispatcher),
    ...
)</pre>
<p><code>views.py</code></p>
<pre lang="python">from wamp_bridge.adapters.django import publish, call, rpc, sub

@rpc()
def nom_fonction_1(val1, val2):
    # faire un truc

@sub()
def nom_topic_1(val1, val2):
    # faire un truc

def vue_normale(request):
    publish('sujet', ['arg1'])
    resultat = call('function', ['arg1'])</pre>
<p>Ca répond pas à des questions du genre : &#8220;comment je fais pour garder mon authentification Django&#8221; mais c&#8217;est déjà super glucose.</p>
<h2>Implémentation</h2>
<p>On peut créer un bridge dans plein de langages, mais je pense que Python est le plus adapté.</p>
<p>Les clients JS utiliseraientt de toute façon nodeJS, qui n&#8217;a pas besoin de bridge, puisque déjà asynchrone. Un routeur en C demanderait de la compilation. PHP est trop moche. Java, c&#8217;est tout un bordel à setuper à chaque fois. C#, si il faut se taper Mono sous Linux&#8230;</p>
<p>En prime, le routeur crossbar est déjà en Python, donc a déjà tout sous la main pour le faire. On peut même penser à l&#8217;intégrer à crossbar plus tard histoire que ce soit batteries included.</p>
<p>Il faut une implémentation Python 2 et Python 3, donc une avec Twisted, et une avec asyncio.</p>
<p>Pour le client twisted, on peut fusionner le client WAMP ordinaire avec <a href="http://twistedmatrix.com/documents/14.0.0/web/howto/web-in-60/index.html</a> et <a href="https://github.com/dreid/treq">treq</a>.</p>
<p>Pour asyncio, il y a <a href="https://github.com/KeepSafe/aiohttp">aiohttp</a> qui fait client et serveur.</p>
<p>On met les clés API dans un fichier de conf ou une variable d&#8217;env, une auth via token, et yala.</p>
<p>C&#8217;est le genre de projet intéressant car pas trop gros, mais suffisamment complexe pour être un challenge surtout qu&#8217;il faudra des tests unitaires partout, de la doc, bref un truc propre.</p>
<p>Je laisse les specs là, des fois qu&#8217;il y ait quelqu&#8217;un qui ait des envies de code cet hiver et cherche un projet open source dans lequel se lancer.</p>
<p>Si on se sent un peut foufou, on peut même transformer ça en bridget HTTP <=> anything, avec des backends pour ce qu&#8217;on veut : IRC, XMPP, Redis, Trigger Happy&#8230;</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/bridge-httpwamp/feed/</wfw:commentRss>
		<slash:comments>5</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">13072</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2014/12/UERQMjQ1YlE2Rmsx_o_robin-hood-men-in-tights-bridge-fight.jpg" length="15115" type="image/jpg" />	</item>
		<item>
		<title>Qu&#8217;est-ce qu&#8217;une API ?</title>
		<link>http://sametmax.com/quest-ce-quune-api/</link>
		<comments>http://sametmax.com/quest-ce-quune-api/#comments</comments>
		<pubDate>Sat, 06 Sep 2014 19:13:58 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[api]]></category>
		<category><![CDATA[http]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[rest]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=12184</guid>
		<description><![CDATA[L'API, pour Application Programming Interface, est la partie du programme qu'on expose officiellement au monde extérieur pour manipuler celui-ci. L'API est au développeur ce que l'UI est à l'utilisateur : de quoi entrer des données et récupérer la sortie d'un traitement.]]></description>
				<content:encoded><![CDATA[<p>L&#8217;API, pour Application Programming Interface, est la partie du programme qu&#8217;on expose officiellement au monde extérieur pour manipuler celui-ci. L&#8217;API est au développeur ce que l&#8217;UI est à l&#8217;utilisateur : de quoi entrer des données et récupérer la sortie d&#8217;un traitement.</p>
<h2>L&#8217;API au sens original</h2>
<p>Initialement, une API regroupe un ensemble de fonctions ou méthodes, leurs signatures et ordre d&#8217;usage pour obtenir un résultat.</p>
<p>Par exemple, imaginons que je fasse une lib pour botter des culs en Python, <code>bottage.py</code> :</p>
<pre lang="python">def senerver(moment):
    # ...

def botter(cul):
    # ...

def main():
    # ...

if __name__ == "__main__":
    main()</pre>
<p>Je vais l&#8217;utiliser ainsi :</p>
<pre lang="python">from bottage import senerver, botter

senerver(now)
botter(le_cul_de_ce_con)</pre>
<p>Les deux fonctions <code>senerver()</code> et <code>botter()</code> sont mes points d&#8217;entrée pour cette action. Je n&#8217;utilise pas <code>main()</code>, qui est un code interne à la lib et ne me regarde pas. Il n&#8217;y a rien qui distingue cette fonction des autres dans cet exemple, mais je n&#8217;en ai pas besoin pour faire le boulot, c&#8217;est ma lib qui l&#8217;utilise automatiquement quelque part, je n&#8217;ai pas à la connaitre.</p>
<p>Donc leurs noms et leurs paramètres ainsi que leurs types sont l&#8217;API de ma lib, ce qui m&#8217;est exposé pour l&#8217;utiliser.</p>
<p>Si on veut rentrer dans des subtilités, on dira en fait que <code>senerver()</code> et <code>botter()</code> font partie de l&#8217;API publique, c&#8217;est à dire de ce qui est manipulable par un utilisateur de la lib. A l&#8217;inverse, <code>main()</code> fait partie de l&#8217;API privée, c&#8217;est à dire ce qui est manipulable par les développeurs de la lib. Mais quand on parle d&#8217;API sans préciser, on parle de l&#8217;API publique.</p>
<h2>Changement d&#8217;API</h2>
<p>En informatique, on peut généralement exposer les choses de plusieurs manières différentes. Je peux changer mon API :</p>
<pre lang="python">
import datetime

def senerver(moment=None):
    if not moment:
        moment = datetime.datetime.utcnow()
    # ...

def botter(cul):
    # ...

def init():
    # ...

if __name__ == "__main__":
    init()</pre>
<p>Ici, j&#8217;ai changé mon API pour rendre le paramètre <code>moment</code> facultatif afin de faciliter la vie des utilisateurs de la libs.</p>
<p>Et là on aborde un point très important du concept : la stabilité d&#8217;une API.</p>
<p>Puisque l&#8217;API est ce qu&#8217;on expose au monde extérieur, le monde extérieur va l&#8217;utiliser d&#8217;une certaine façon. Si on change cette manière de l&#8217;utiliser dans une version suivante, au moment de la mise à jour, on va casser leur code si on ne fait pas attention.</p>
<p>Par exemple, ici je rends un paramètre facultatif : ça ne craint pas grand-chose. Mais si j&#8217;avais fait l&#8217;inverse ? J&#8217;avais un paramètre facultatif, et soudain je le rends obligatoire. Toutes les personnes qui n&#8217;ont pas passé le paramètre vont soudain avoir un plantage s&#8217;ils passent à la nouvelle version de la lib car l&#8217;API a changé.</p>
<p>C&#8217;est donc une seconde définition de l&#8217;API : l&#8217;API est une promesse, un contrat entre l&#8217;auteur d&#8217;un code et ceux qui vont utiliser ce code. Cette promesse est &#8220;voici ce que vous pouvez utiliser sereinement dans votre programme, je ne vais pas tout péter demain&#8221;.</p>
<p>Cette promesse est plus ou moins bien respectée selon les projets. Python, par exemple, a un historique exemplaire de stabilité d&#8217;API, et n&#8217;a cassé la compatibilité qu&#8217;une fois, avec Python 3, donnant 10 ans aux développeurs pour s&#8217;adapter.</p>
<p>Dans tous les cas, si une lib est beaucoup utilisée et que son développeur a le sens des responsabilités, elle évolue plus doucement. Pour cette raison, il faut faire attention au choix qu&#8217;on fait dans le style de son API, sous peine de ne pas pouvoir le changer plus tard.</p>
<p>En effet, on peut tout à faire écrire le même code dans des tas de styles différents. Ainsi, je pourrais botter des culs avec une API orientée objet :</p>
<pre lang="python">

class Colere:

    @classmethod
    def global_init():
        # ...

    def __init__(moment):
        # ...
        self._senerver(moment)

    def _senerver():
        # ...

    def botter(cul):
        # ...

if __name__ == "__main__":
    Colere.global_init()</pre>
<p>Mon bottage de cul n&#8217;a plus du tout le même goût à l&#8217;usage :</p>
<pre lang="python">
from bottage import colere
c = Colere(now)
c.botter(un_aperi_cul)
</pre>
<p>Mon programme fait la même chose, mais mon API est différente. Notez le <code>_senerver()</code> qui est préfixé d&#8217;un underscore, une convention en Python pour dire que cette méthode doit être considérée comme ne faisant pas partie de l&#8217;API publique, donc à ne pas utiliser depuis l&#8217;extérieur. En effet, il n&#8217;y a pas de méthode privée en Python.</p>
<h2>Qualités d&#8217;une API</h2>
<p>On a vu que la stabilité était une qualité importante d&#8217;une API. Mais il y en a d&#8217;autres. Notamment la performance et l&#8217;ergonomie, généralement deux notions qui s&#8217;affrontent.</p>
<p>Pour l&#8217;ergonomie, il s&#8217;agit de rendre facile les usages qu&#8217;on fait le plus couramment, et rendre possible les usages les plus ardus. Prenez l&#8217;exemple d&#8217;une requête HTTP avec paramètre POST sur un site qui a besoin de cookies d&#8217;une requête précédente. Pas un usage incroyablement complexe a priori&#8230;</p>
<p>Avec la stdlib de Python, ça donne ça :</p>
<pre lang="python">import urllib
import urllib2
import cookielib

cookie_jar = cookielib.CookieJar()
opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie_jar))
urllib2.install_opener(opener)
urllib2.urlopen('http://site.com')

data = urllib.urlencode({"nom": "valeur"})
rsp = urllib2.urlopen('http://site.com/autre/page', data)
print(rsp.read())</pre>
<p>La même chose avec la lib <a href="http://docs.python-requests.org/en/latest/">requests</a> :</p>
<pre lang="python">
import requests

request.get('http://site.com')
res = request.post('http://site.com/autre/page', data={"nom": "valeur"})
print(res.content)</pre>
<p>Il ne s&#8217;agit pas juste du fait qu&#8217;il y ait beaucoup moins de lignes pour le faire. La facilité à découvrir comment faire dans le deuxième cas est exemplaire : en lisant, on comprend le code. En bidouillant dans le shell, on peut sans doute trouver tout ça. On n&#8217;a pas besoin de se poser la question de ce qu&#8217;est une jar, l&#8217;url encoding, etc.</p>
<p>Le premier exemple est non seulement verbeux, mais très, très difficile à trouver soi-même. En fait, même avec la doc sous les yeux, ce n&#8217;est pas évident d&#8217;arriver à ce résultat, et on y arrivera après des essais douloureux.</p>
<p>Le deuxième exemple est plus ergonomique que le premier.</p>
<p>Mais l&#8217;ergonomie a généralement un coût : celui de la performance.</p>
<p>Imaginez que j&#8217;ai la lib de bottage de fion sous forme fonctionnelle :</p>
<pre lang="python">
import datetime

def senerver(moment=None):
    if not moment:
        moment = datetime.datetime.utcnow()
    # ...

def botter(cul):
    # ...

def init():
    # ...

if __name__ == "__main__":
    init()</pre>
<p>Je veux la rendre plus ergonomique. Je sais qu&#8217;il faut obligatoirement s&#8217;énerver pour botter un cul, et je décide donc de cacher cette fonction et l&#8217;appeler automatiquement :</p>
<pre lang="python">
import moment

def _senerver(moment=None):
    if not moment:
        moment = datetime.datetime.utcnow()
    # ...

def botter(cul, moment=None):
    _senerver(moment)
    # ...

def init():
    # ...

if __name__ == "__main__":
    init()</pre>
<p>Dans la plupart des cas, ça va aider mon public :</p>
<p>Au lieu de devoir savoir qu&#8217;il faut s&#8217;énerver avant de botter, ils ont juste à botter :</p>
<pre lang="python">
from bottage import botter
botter(cul_de_jatte)
</pre>
<p>J&#8217;ai identifié que c&#8217;était l&#8217;usage le plus courant, donc c&#8217;est une amélioration. Mais ça a un prix pour une petite partie de mes utilisateurs : les très gros botteurs de cul. Ceux qui bottent des culs par centaine.</p>
<p>Avant, ils pouvaient faire :</p>
<pre lang="python">
from bottage import senerver, botter
senerver()
for cul in rang_doigons:
    botter(cul)
</pre>
<p>Mais maintenant, faisant :</p>
<pre lang="python">
from bottage import botter
for cul in rang_doigons:
    botter(cul)
</pre>
<p>Ils ont un appel à <code>_senerver()</code> à chaque tour de boucle, et donc un appel à <code>datetime.utcnow()</code> aussi !</p>
<p>Bien entendu, il est possible de remédier à cette situation, mais cet article n&#8217;est pas là pour vous expliquer comment créer une belle API. Ce serait néanmoins un très bon article.</p>
<p>Ici, je vous montre simplement qu&#8217;en facilitant, on suppose d&#8217;un usage, et ça peut se faire au détriment des autres. L&#8217;automatisme a tendance à retirer de la marge de manœuvre.</p>
<p>Une bonne API va donc proposer un moyen automatique de faire les opérations de tous les jours, va lui donner une forme (nom, ordre des actions, organisation, etc) ET un moyen de faire des choses compliquées ou performantes. Ce qui va rendre l&#8217;API plus riche, donc plus lourde, avec une plus grosse doc, etc.</p>
<p>Tout a un coût.</p>
<h2>API Web</h2>
<p>Jusqu&#8217;ici vous avez vu l&#8217;API d&#8217;une bibliothèque, mais il existe d&#8217;autres genres d&#8217;API. L&#8217;un est devenu particulièrement populaire depuis le milieu des années 2000 : l&#8217;API Web.</p>
<p>L&#8217;API Web est comme l&#8217;API précédente ce qui est exposé à l&#8217;extérieur pour manipuler un programme. Entrées. Sorties. Mais il y a plusieurs différences :</p>
<ul>
<li>Ce n&#8217;est pas une lib qu&#8217;on manipule, c&#8217;est en général un service complet.</li>
<li>On n&#8217;utilise pas le langage dudit code pour le manipuler, mais un protocole Web.</li>
<li>Les appels passent par le réseau.</li>
</ul>
<p>Il existe de nombreux protocoles qui permettent de faire une API Web : SOAP, REST, XML RPC, WAMP etc.</p>
<p>Aujourd&#8217;hui, les API Web les plus populaires utilisent majoritairement un protocole pseudo-REST (techniquement REST est plus une archi qu&#8217;un protocole, mais fuck) avec en encoding JSON.</p>
<p>Hum, je vous vois sourciller.</p>
<p>Oui, c&#8217;est clair que la phrase est un peu tordue du cul, comme si elle avait été bottée.</p>
<p>Prenons donc un exemple : un service Web de bottage de cul !</p>
<p>Vous êtes donc asskicker.io, leader mondial du bottage de cul en ligne. Et vous exposez votre processus de bottage de cul exclusif à tous les programmeurs.</p>
<p>Pour ce faire, vous mettez à disposition une API WEB sous forme pseudo REST. Au lieu d&#8217;appeler des méthodes, les développeurs vont envoyer des requêtes HTTP Get et Post à des URLs représentant les culs à botter.</p>
<p>Je ne vais pas rentrer dans les détails de ce qu&#8217;est du (pseudo) REST ou JSON exactement, mais un exemple de requêtes à faire pour botter des culs via notre API Web serait :</p>
<pre lang="python">import json
import requests

# On fait une requête GET vers l'URL du service pour obtenir de quoi s’énerver
colere = requests.get('http://asskicker.io/colere/')

# Je créer un nouveau bottage de cul
data = json.dumps({'cul': 'de bouteille', 'colere': colere['id']})
headers = {'content-type': 'application/json'}
res = requests.post('http://asskicker.io/bottage/', data=data, headers=headers)</pre>
<p>Et supposons qu&#8217;on veuille connaître le dernier bottage de cul fait :</p>
<pre lang="python">res = requests.get('http://asskicker.io/bottage/last')
print(res.json()) # et la réponse JSON du service :
# {
#     "bottage": 89080,
#     "cul": "de bouteille",
#     "colere": 99943,
#     "date": "2014-09-06 20:38:11"
# }</pre>
<p>Les URLs sont fictives, complètement inventées, et ne correspondent à rien.</p>
<p>Ici, notre API est donc la collections d&#8217;URLs (<code>http://asskicker.io/bottage/</code>, <code>http://asskicker.io/bottage/last</code>, etc.) qui permet de manipuler notre service, ainsi que les noms et types des paramètres à envoyer via <code>data</code> et le contenu de la réponse.</p>
<p>Le but de l&#8217;API Web est de permettre de manipuler du code sur une machine distante à travers le Web, depuis n&#8217;importe quel langage capable d&#8217;envoyer une requête HTTP. L&#8217;API Twitter permet de de lister des tweets et en envoyer. Par exemple, si on est authentifié, faire une requête GET sur <a href="http://api.twitter.com/1.1statuses/show/787998">http://api.twitter.com/1.1statuses/show/787998</a> permet d&#8217;obtenir en retour un JSON contenant les informations sur le tweet numéro 787998</p>
<p> L&#8217;API Google permet de faire des recherches. L&#8217;API flicker permet d&#8217;uploader des photos. Toutes les APIS ont des formes différentes, certaines sont plus ou moins faciles, plus ou moins efficaces, utilisent tels ou tels formats, mais au final, c&#8217;est la même chose : un moyen de manipuler le service en faisant des requêtes.</p>
<p>La manière classique de créer un site est de générer le HTML final sur le serveur. Or, comme il est possible d&#8217;envoyer des requêtes HTTP depuis une page Web en utilisant Ajax, on voit aujourd&#8217;hui des sites codés en Javascript qui vont chercher leurs données sur le serveur via l&#8217;API du site. Le navigateur reçoit ainsi un HTML incomplet, et le JS appelle l&#8217;API pour reconstruire la page.</p>
<p>Ainsi, on code la logique une seule fois : récupérer les informations, effectuer des actions&#8230; Et on utilise l&#8217;API pour tout ça, que ce soit pour faire le site Web, ou pour laisser d&#8217;autres programmeurs utiliser le site.</p>
<p>Évidemment, une vraie API Web est complexe, possède des problématiques de sécurité, d&#8217;authentification&#8230; Encore un bon article à écrire.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/quest-ce-quune-api/feed/</wfw:commentRss>
		<slash:comments>18</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">12184</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2014/09/v6bggki.gif" length="165254" type="image/jpg" />	</item>
		<item>
		<title>Comment fonctionne HTTP ?</title>
		<link>http://sametmax.com/comment-fonctionne-http/</link>
		<comments>http://sametmax.com/comment-fonctionne-http/#comments</comments>
		<pubDate>Wed, 18 Jun 2014 01:48:36 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[http]]></category>
		<category><![CDATA[python]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=10596</guid>
		<description><![CDATA[Plus je fais du dev Web, plus je m'aperçois que beaucoup de mes collègues n'ont aucune idée de comment fonctionne HTTP sous le capot. Comme vous le savez, ma règle numéro 1 c'est qu'<a href="http://sametmax.com/bien-expliquer-quelque-chose-les-regles-de-base/">il n'y a rien d'évident</a>, donc petit tuto pour expliquer les bases.]]></description>
				<content:encoded><![CDATA[<p>Plus je fais du dev Web, plus je m&#8217;aperçois que beaucoup de mes collègues n&#8217;ont aucune idée de comment fonctionne HTTP sous le capot. Comme vous le savez, ma règle numéro 1 c&#8217;est qu&#8217;<a href="http://sametmax.com/bien-expliquer-quelque-chose-les-regles-de-base/">il n&#8217;y a rien d&#8217;évident</a>, donc petit tuto pour expliquer les bases.</p>
<p>On ne va pas rentrer dans les petits détails, juste une petite intro histoire de savoir ce qui se passe derrière ce script PHP ou cette application bottle.</p>
<p>Article long, vous connaissez la chanson.</p>

<!-- iframe plugin v.4.3 wordpress.org/plugins/iframe/ -->
<iframe width="420" height="315" src="//www.youtube.com/embed/mDarUeXPFco" frameborder="0" 0="allowfullscreen" scrolling="yes" class="iframe-class"></iframe>

<p>Et puis c&#8217;est dans le ton de l&#8217;actu ^^</p>
<h2>La logique de client / serveur</h2>
<p>(<a href="http://sametmax.com/bien-expliquer-quelque-chose-les-regles-de-base/">Je me repompe moi-même</a>)</p>
<p>Se balader sur le Web, c&#8217;est comme aller au resto. On est un client, on demande quelque chose au serveur, le serveur va voir en cuisine, et revient avec la bouffe, ou une explication sur l&#8217;absence de la bouffe (mais jamais pourquoi la bouffe est dégueulasse, allez comprendre):</p>
<div id="attachment_965" style="width: 533px" class="wp-caption aligncenter"><a href="http://sametmax.com/wp-content/uploads/2012/06/http.png" class="grouped_elements" rel="tc-fancybox-group10596"><img class=" wp-image-965 " title="Le protocole HTTP, en gros" src="http://sametmax.com/wp-content/uploads/2012/06/http.png" alt="Schéma du protocole HTTP, en gros" width="523" height="666" /></a><p class="wp-caption-text">Le protocole HTTP, en (très) gros</p></div>
<p>Ce cycle requête/réponse se déroule des centaines de fois quand on parcours un site Web. Chaque lien cliqué déclenche une requête GET, et la page suivante ne s&#8217;affiche que parce qu&#8217;on a reçu la réponse contenant le HTML de celle-ci. Les formulaires, les requêtes AJAX, la mise à jour de vos Tweets sur votre téléphone, tout ça fonctionne sur le même principe.</p>
<p>Donc, sur votre site Web, Firefox, Chrome et les autres vont faire une requête à une machine, votre machine contient un code (si vous êtes dev, votre code :) qui va recupérer cette requête et générer une réponse.</p>
<h2>Tout est texte</h2>
<p>Généralement, les développeurs utilisent des outils sophistiqués pour écrire des sites Web. Si bien que quand on écrit du code, on ne voit pas vraiment la requête et la réponse, mais des fonctions, des objets, du HTML&#8230; Comment ça arrive et comment ça repart est géré automatiquement.</p>
<p>Regardons ce qui se passe quand ce n&#8217;est PAS géré automatiquement.</p>
<p>Voici le code d&#8217;un petit serveur HTTP écrit en Python 3. Il accepte n&#8217;importe quelle requête sur le port 7777 et retourne toujours une page avec marqué &#8220;Coucou&#8221;.</p>
<pre lang="python">import asyncio

# Le texte de la réponse qu'on va renvoyer
COUCOU = b"""HTTP/1.1 200 OK
Date: Fri, 16 Jun 2014 23:59:59 UTC
Content-Type: text/html

<html>
<body>
<h1>Coucou</h1>
</body>
</html>"""

# La fonction qui gère chaque requête et qui renvoie une réponse
# pour chacune d'entre elles. La même réponse à chaque fois pour cet
# exemple, mais on peut fabriquer une réponse différente si on veut.
def handle_request(request, response):
    # On lit la requête
    data = yield from request.read(1000000)
    # On affiche son contenu. Surprise, c'est que du texte !
    print(data.decode('ascii'))
    # On écrit notre réponse, que du texte aussi !
    response.write(COUCOU)
    # On ferme la connexion : le protocole HTTP est stateless,
    # c'est à dire qu'il n'y a pas de maintien d'un état
    # côté client ou serveur et chaque requête est indépendante
    # de toutes les autres.
    response.close()

if __name__ == '__main__':
    # Machinerie pour faire tourner le serveur :
    # Récupération de la boucle d'événements.
    loop = asyncio.get_event_loop()
    # Création du serveur qui écoute sur le port 7777
    # et qui va appeler notre fonction quand il reçoit
    # une requête.
    f = asyncio.start_server(handle_request, port=7777)
    # Installation du serveur dans la boucle d'événements.
    loop.run_until_complete(f)
    # On démarre la boucle d'événement.
    print("Serving on localhost:7777")
    loop.run_forever()

# Si vous êtes dev, vous commencez à comprendre combien
# les libs et frameworks qui gèrent tout ce bordel pour
# vous sont fantastiques.
</pre>
<p>Si on lance le serveur et qu&#8217;on visite la page <code>http://localhost:7777</code> sur un navigateur, on va alors voir ceci dans le terminal où tourne le serveur :</p>
<pre>$ python3 server.py
Serving on localhost:7777
GET / HTTP/1.1
Host: 127.0.0.1:7777
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:30.0) Gecko/20100101 Firefox/30.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: fr,fr-fr;q=0.8,en-us;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate
DNT: 1
Connection: keep-alive
Cache-Control: max-age=0
</pre>
<p>C&#8217;est la requête envoyée par notre client, et reçue par notre serveur. &#8220;Aller&#8221; sur l&#8217;adresse veut dire en fait que votre navigateur envoie ce morceau de texte.</p>
<p>Juste après, mon serveur renvoie aussi du texte. Toujours le même dans notre cas :</p>
<pre lang="html">HTTP/1.1 200 OK
Date: Fri, 16 Jun 2014 23:59:59 UTC
Content-Type: text/html

<html>
<body>
<h1>Coucou</h1>
</body>
</html></pre>
<p>Le navigateur l&#8217;interprète, et vous fabrique cette page :</p>
<div id="attachment_10597" style="width: 335px" class="wp-caption aligncenter"><a href="http://sametmax.com/wp-content/uploads/2014/06/get.png" class="grouped_elements" rel="tc-fancybox-group10596"><img src="http://sametmax.com/wp-content/uploads/2014/06/get.png" alt="" title="Vous contemplez le Web de 1995" width="325" height="186" class="size-full wp-image-10597" /></a><p class="wp-caption-text">Vous contemplez le Web de 1995</p></div>
<p>Comme vous pouvez le voir, ce n&#8217;est que du texte tout simple qui est reçu et envoyé.</p>
<p>Quand quelqu&#8217;un développe un site Web, ce qu&#8217;il fait vraiment, c&#8217;est ça. La plupart du temps il ne le voit pas car ses outils lui facilitent la tâche en analysant le texte et en lui donnant des fonctions et des objets pour le manipuler. Mais derrière, c&#8217;est juste du texte.</p>
<p>Quand quelqu&#8217;un surf le Web, ce qu&#8217;il fait vraiment, c&#8217;est ça. Mais le navigateur se charge de le cacher derrière des jolis contrôles, et affiche un résultat bien plus agréable à regarder.</p>
<h2>Structure des requêtes</h2>
<p>Le texte d&#8217;une requête est divisé en 3 parties :</p>
<ul>
<li>L&#8217;action demandée sur la ressource.</li>
<li>Les headers.</li>
<li>Le corps de la requête</li>
</ul>
<p>Prenons notre précédente requête d&#8217;exemple :</p>
<pre>
GET / HTTP/1.1
Host: 127.0.0.1:7777
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:30.0) Gecko/20100101 Firefox/30.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: fr,fr-fr;q=0.8,en-us;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate
DNT: 1
Connection: keep-alive
Cache-Control: max-age=0</pre>
<p>L&#8217;action demandée sur la ressource est toujours sur la première ligne :</p>
<p><code>GET / HTTP/1.1</code></p>
<p>Elle se divise en 3 parties :</p>
<ul>
<li>Le verbe d&#8217;action : GET, POST, PUT, OPTION, HEAD, etc. C&#8217;est ce qu&#8217;on veut faire sur les données qu&#8217;on demande. Le plus courant sur le Web, c&#8217;est GET (lire la donnée) et POST (créer la donnée, qu&#8217;on utilise souvent pour les formulaires).</li>
<li>Le chemin de la ressource. Où se trouve la ressource à laquelle on souhaite accéder. Ici c&#8217;est &#8220;/&#8221;, la racine, mais ça peut être &#8220;/user/monique/profile&#8221; par exemple.</li>
<li>La version du protocole utilisé. Aujourd&#8217;hui tout le monde utilise HTTP en version 1.1, donc ça ne change pas vraiment.</li>
</ul>
<p>Notez bien que le chemin de la ressource n&#8217;a pas à correspondre à un chemin réel d&#8217;un fichier sur l&#8217;ordinateur. Une ressource est quelque chose de complètement virtuel, quelque chose que mon programme met à disposition selon mes désirs. Si c&#8217;est un fichier, très bien, mais ce n&#8217;est pas obligatoire, et je peux générer n&#8217;importe quelle réponse qui me plait.</p>
<p>En effet, si je vais sur l&#8217;adresse <code>http://127.0.0.1:7777/user/monique/profile/</code>, vous notez que mon serveur continue de marcher. Il reçoit simplement la requête :</p>
<pre>GET /user/monique/profile/ HTTP/1.1
...
</pre>
<p>C&#8217;est à mon serveur de décider ce qu&#8217;il choisit de faire avec le chemin <code>/user/monique/profile/</code>. Ici il est un peu con et continue de renvoyer &#8220;coucou&#8221;.</p>
<p>Bien, on vient de voir &#8220;L&#8217;action demandée sur la ressource&#8221;, voyons maintenant les headers :</p>
<pre>Host: 127.0.0.1:7777
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:30.0) Gecko/20100101 Firefox/30.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: fr,fr-fr;q=0.8,en-us;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate
DNT: 1
Connection: keep-alive
Cache-Control: max-age=0</pre>
<p>Les headers sont des informations supplémentaires que le client fourni à mon serveur sous la forme :</p>
<pre>Nom-De-L-Information: contenu</pre>
<p><strong>Les sauts de ligne sont très importants.</strong> La première ligne de la requête est &#8220;L&#8217;action demandée sur la ressource&#8221;, puis on met un saut de ligne, ensuite vient un header, puis un saut de ligne, puis un header&#8230; Chaque header doit tenir sur une ligne.</p>
<p>En HTTP/1.1, seul le header <code>Host</code> est obligatoire, mais comme aucun header n&#8217;était obligatoire en HTTP/1.0, beaucoup de serveurs acceptent l&#8217;absence de tout header.</p>
<p>Les headers contiennent généralement des informations sur le client (ex: <code>Accept-Language</code> vous dit quelles langues le client accepte), le contenu de la requête (ex: <code>Content-Length</code> indique la taille de la requête) ou demande un comportement du server (<code>Cache-Control</code> précise comment gérer les ressources qu&#8217;on peut mettre en cache).</p>
<p>Pour &#8220;Le corps de la requête&#8221;, il nous faut ajouter du contenu à notre requête.</p>
<p>Pour cela, faisons une page avec un petit formulaire HTML :</p>
<pre lang="html"><html>
<head>
    <title>Test post</title>
</head>
<body>
<form method="post" action="http://127.0.0.1:7777/">
<p><input type="test" value="coucou, tu veux voir mon POST ?" name="salut">
<input type="submit"></p>
</form>
</body>
</html></pre>
<p>Ce qui nous donne cette page :</p>
<div id="attachment_10598" style="width: 335px" class="wp-caption aligncenter"><a href="http://sametmax.com/wp-content/uploads/2014/06/post.png" class="grouped_elements" rel="tc-fancybox-group10596"><img src="http://sametmax.com/wp-content/uploads/2014/06/post.png" alt="Capture d&#039;écran d&#039;un simple formulaire web sous firefox" title="Techniquement, on peut poster un formulaire avec une requête GET, mais shut..." width="325" height="186" class="size-full wp-image-10598" /></a><p class="wp-caption-text">Techniquement, on peut poster un formulaire avec une requête GET, mais shut...</p></div>
<p>Si on active le formulaire, notre serveur affiche cette requête :</p>
<pre>POST / HTTP/1.1
Host: 127.0.0.1:7777
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:30.0) Gecko/20100101 Firefox/30.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: fr,fr-fr;q=0.8,en-us;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate
DNT: 1
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 41

salut=coucou%2C+tu+veux+voir+mon+POST+%3F</pre>
<p>Déjà, vous notez que le verbe d&#8217;action a changé : <code>POST / HTTP/1.1</code>.</p>
<p>Ensuite, à la fin de la requête, on laisse une ligne vide, puis on a de nouveau du texte : </p>
<pre>salut=coucou%2C+tu+veux+voir+mon+POST+%3F</pre>
<p>C&#8217;est le corps de la requête.</p>
<p>C&#8217;est comme ça que le serveur reçoit le contenu des données des formulaires, et c&#8217;est ce qu&#8217;on retrouve dans la variable <code>$_POST</code> en PHP ou <code>request.POST</code> en Django</p>
<p>Encore une fois, les outils de programmation évitent au codeur de travailler avec du charabia, et le transforme en quelque chose de facile à comprendre et à manipuler.</p>
<h2>Structure des réponses</h2>
<p>C&#8217;est pareil, ma bonne dame. Reprenons notre exemple de réponse :</p>
<pre lang="html">HTTP/1.1 200 OK
Date: Fri, 16 Jun 2014 23:59:59 UTC
Content-Type: text/html

<html>
<body>
<h1>Coucou</h1>
</body>
</html></pre>
<p>Première ligne, on précise le protocole, puis le <a href="http://fr.wikipedia.org/wiki/Liste_des_codes_HTTP">code de réponse</a>, qui stipule la nature de votre réponse (tout va bien, une erreur, une redirection, la page n&#8217;existe pas, etc).</p>
<p>Ensuite les headers, puis on saute une ligne, et on met le corps de la réponse. Ici, le code HTML qui va donner notre jolie page &#8220;Coucou&#8221;.</p>
<h2>Tout tient là dedans</h2>
<p>Tout le reste, toutes les fonctionnalités fantastiques du Web (les liens hypertextes, les fichiers statiques JS et CSS inclus, les cookies, les redirections, le cache, la compression&#8230;) ont pour point d&#8217;entrée un de ces 3 éléments de la requête ou de la réponse. C&#8217;est que c&#8217;est un protocole bien foutu. </p>
<p>Enfin, disons, <a href="http://sametmax.com/le-web-nest-plus-http/">presque tout</a> ? :)</p>
<hr />
<p><a href="https://github.com/sametmax/codes-des-articles/tree/master/2014/juin">Télécharger le code de l&#8217;article</a></p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/comment-fonctionne-http/feed/</wfw:commentRss>
		<slash:comments>12</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">10596</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2014/06/Ro62INB.gif" length="504292" type="image/jpg" />	</item>
		<item>
		<title>Redirection 307 et 308</title>
		<link>http://sametmax.com/redirection-307-et-308/</link>
		<comments>http://sametmax.com/redirection-307-et-308/#comments</comments>
		<pubDate>Mon, 16 Jun 2014 00:20:14 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[http]]></category>
		<category><![CDATA[redirection]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=10575</guid>
		<description><![CDATA[Le standard HTTP 1.1 vient de <a href="http://evertpot.com/http-11-updated/">subir une mise à jour</a>.

Oui, LE standard HTTP 1.1. La fameuse <a href="http://tools.ietf.org/html/rfc2616">RFC2616</a>, qui n'a pas été touchée depuis l'année de sortie de The Matrix (coïncidence ? Je ne pense pas...).

Bref, qu'est-ce qui change ?]]></description>
				<content:encoded><![CDATA[<p>Le standard HTTP 1.1 vient de <a href="http://evertpot.com/http-11-updated/">subir une mise à jour</a>.</p>
<p>Oui, LE standard HTTP 1.1. La fameuse <a href="http://tools.ietf.org/html/rfc2616">RFC2616</a>, qui n&#8217;a pas été touchée depuis l&#8217;année de sortie de The Matrix (coïncidence ? Je ne pense pas&#8230;).</p>
<p>Bref, qu&#8217;est-ce qui change ?</p>
<p>Essentiellement la forme, qui permettra à la RFC de HTTP 2.0 de faire référence à des parties de celle de la HTTP 1.1, maintenant divisée en 8, et évitera de se répéter.</p>
<p>Le web ne va donc pas casser.</p>
<p>Mais il y a quand même intronisation officielle de la redirection 308, qui est à la 301 ce que la 307 est à la 302.</p>
<p>Je me doute que ça vous parle autant qu&#8217;un personnage de film de Charlie Chaplin en fond d&#8217;écran d&#8217;un Windows avec driver realtek.</p>
<p>Pour rappel, quand un serveur HTTP répond à un client, il lui renvoie un code pour indiquer la nature de sa réponse. Quand tout va bien, c&#8217;est 200, quand la page n&#8217;est pas trouvée, c&#8217;est le fameux 404, quand le serveur est en erreur, c&#8217;est une 50x, etc.</p>
<p>Quand le serveur renvoie un code 30x, c&#8217;est généralement une redirection : on dit au client, ce que tu cherches est ailleurs, et le client, recevant ce code, fait donc une seconde requête, sur la nouvelle adresse.</p>
<p>Le code 301 indique une redirection permanente, ce qui signifie que le client peut considérer que c&#8217;est la nouvelle adresse qui remplace l&#8217;ancienne, pour toujours.</p>
<p>Le code 302 indique une redirection temporaire, généralement on utilise ça pour orienter le client sur le site à la suite d&#8217;une action, comme la saisie d&#8217;un formulaire.</p>
<p>Mais ces deux codes ont une particularité : le client effectue une simple requête GET vers la nouvelle adresse. Si vous avez fait une requête complexe avant, par exemple une requête POST avec plein de paramètres, le client va se rediriger avec une nouvelle requête GET basique, toute l&#8217;information précédente est perdue.</p>
<p>Cela peut être ce que l&#8217;on veut. Mais parfois, on souhaite que le client fasse la redirection avec une copie exacte de la requête initiale.</p>
<p>C&#8217;est ce que fait le code 307 : une redirection temporaire, mais avec la même requêtes. C&#8217;est comme la 302, donc, mais répète la même requête deux fois.</p>
<p>Le code 308 demande aussi une redirection en répétant la requête, mais une redirection permanente, comme la 301.</p>
<p><del datetime="2014-06-16T07:31:44+00:00">C&#8217;est ce dernier qui a été ajouté officiellement au protocole, puisqu&#8217;il est déjà supporté par la plupart des navigateurs : même <a href="http://blogs.msdn.com/b/ieinternals/archive/2012/03/29/http-308-permanent-redirect-pushing-the-web-forward-by-breaking-unwanted-forward-compatibility.aspx">IE le comprends depuis 2008</a>.</del> </p>
<p>(le support est vraiment aléatoire, voir comments)</p>
<p>Par curiosité, vous pouvez tester la redirection <a href="http://webdbg.com/test/308/">ici</a>.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/redirection-307-et-308/feed/</wfw:commentRss>
		<slash:comments>9</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">10575</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2014/06/TWm6d7k.gif" length="542518" type="image/jpg" />	</item>
		<item>
		<title>Le potentiel de WAMP, autobahn et crossbar.io</title>
		<link>http://sametmax.com/le-potentiel-de-wamp-autobahn-et-crossbar-io/</link>
		<comments>http://sametmax.com/le-potentiel-de-wamp-autobahn-et-crossbar-io/#comments</comments>
		<pubDate>Sun, 01 Jun 2014 10:09:32 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[autobahn]]></category>
		<category><![CDATA[crossbar]]></category>
		<category><![CDATA[flask]]></category>
		<category><![CDATA[http]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[wamp]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=10380</guid>
		<description><![CDATA[Je sais, je sais, je vous fais chier avec <a href="http://sametmax.com/crossbar-le-futur-des-applications-web-python/">crossbar</a> et <a href="http://sametmax.com/un-petit-gout-de-meteor-js-en-python/">autobahn</a>.

Mais ça me tue de ne pas voir plus de monde exploiter cette techno.]]></description>
				<content:encoded><![CDATA[<p>Je sais, je sais, je vous fais chier avec <a href="http://sametmax.com/crossbar-le-futur-des-applications-web-python/">crossbar</a> et <a href="http://sametmax.com/un-petit-gout-de-meteor-js-en-python/">autobahn</a>.</p>
<p>Mais ça me tue de ne pas voir plus de monde exploiter cette techno.</p>
<p>Pendant que Max fait la sieste, j&#8217;ai pris mon stylo et j&#8217;ai fait la liste des besoins d&#8217;une app Web actuelle. Quels sont les composants qu&#8217;on utilise presque systématiquement, mais en agrégeant divers bouts de trucs à droite et à gauche ?</p>
<p>Ensuite j&#8217;ai regardé les possibilités des outils WAMP :</p>
<ul>
<li>PUB/SUB et RPC.</li>
<li>Asynchrone.</li>
<li>Gestionnaire de process intégré.</li>
<li>Serveur stand alone qui n&#8217;a pas besoin d&#8217;un proxy pour être en prod.</li>
</ul>
<p>M&#8217;inspirant de cela, et du travail que je suis en train de faire avec l&#8217;équipe de Tavendo pour faire une API flaskesque pour autobahn, j&#8217;ai prototypé une API d&#8217;un framework Web qu&#8217;on pourrait coder au dessus de cette techno.</p>
<p>Voilà ce que ça donne&#8230;</p>
<p>Une API qui mélange flask et nodejs pour le Web</p>
<pre lang="python">app = Application('YourProjectName')

# Envoyer et recevoir des requêtes HTTP
@app.http.post(r'/form')
def _(req, res):
    res.json({'data': 'pouet'})

@app.http.get(r'/user/:id/')
def _(req, res):
    res.render('index.html', {'data': 'pouet'})

# Servir des fichiers statiques
@app.http.serve('uri', '/path/to/dir', [allow_index])

app.run()</pre>
<p>Comme c&#8217;est asynchrone, on a de très bonnes perfs. Comme c&#8217;est basé sur Twisted, on a pas besoin d&#8217;un serveur wsgi (gunicorn, uwsgi, etc) ni d&#8217;un proxy (nginx) devant. On peut le mettre en prod tel quel.</p>
<p>Parti de ce principe, on peut ajouter la gestion du PUB/SUB et du RPC pour WAMP :</p>
<pre lang="python"># Callback attendant l'événement
@app.wamp.event('auth.signedin')
def _(ctx, a, b, c):
    pass

# déclenchement de l'événément
app.wamp.pub('auth.signedin')

# Déclaration du fonnction appelable à distance
@app.wamp.remote('auth.signin')
def _(ctx, a, b, c):
    pass

# appel de la fonnction
app.wamp.call('auth.signin')</pre>
<p>On est souvent perdu quand on fait de l&#8217;asynchrone pour la première fois avec Python car on ne sait pas comment lancer du code après <code>.run()</code>. On peut régler la question proposant des hooks pour les instants clés de l&#8217;app.</p>
<pre lang="python"># Callback à lancer quand l'app est prête
@app.on('app.ready')
def _(ctx, args):
    pass

# Signalement que l'app est prête (fait automatiquement en interne
# pour les moments les plus importants)
app.emit('app.ready')</pre>
<p>Et tant qu&#8217;on y est, puisqu&#8217;on a une event loop, profitons en pour proposer du CRON intégré à l&#8217;app. C&#8217;est moins chiant à déployer qu&#8217;un script CRON, c&#8217;est cross plateforme, et on a accès facilement à toute sa stack.</p>
<pre lang="python"># Lancer du code tous les x temps ou a une date précise
@app.cron(every=seconds)
@app.cron(every=timedelta, overlap=False)
@app.cron(hour=7, minute=30, day_of_week=1)
@app.cron(when=datetime)
def _(ctx, args):
    pass

</pre>
<p>Pourquoi s&#8217;arrêter là ? Event loop + message passing + safe queues + workers = tasks queues !</p>
<pre lang="python"># Créer une file d'attente
queue = @app.queue('name', [workers], [result_backend])

# Callback appelé par un worker quand il depop ce 
# message dans la file
@queue.task('encode.video')
def _(ctx, data):
    pass

# Envoie d'une tache dans la queu
queue.append('encode.video', data)
</pre>
<p>Comme on utilise Twisted, on a accès à une chiée de protocoles, et on peut aussi créer les siens. On peut donc imaginer un système de plugins qui rajoute des protocoles supportés :</p>
<pre lang="python">app = Application('YourProjectName')
app.plug('lib.ajoutant.sms', [namespace])</pre>
<p>Si on en a beaucoup et que le namespace nous convient :</p>
<pre lang="python">app = Application('YourProjectName', plugins=('lib1', 'lib2', 'etc'))</pre>
<p>Exemples de plugins possibles :</p>
<pre lang="python"># Recevoir et envoyer des SMS (via un service type twilio, une gateway kannel ou
# un modem physique)
@app.sms.receive(r'LOVE \w+ \w+')
def _(ctx, args):
    pass
app.sms.send('test', [contact])


# Envoyer et recevoir des emails (via un server SMTP ou IMAP)
@app.email.receive(src=r'.*@sametmax.com', dest=r'spam.*@*.')
def _(ctx, args):
    pass
app.email.send('test', [contact, title, attachments])


# techniquement n'importe quel service de message pour lequel on peut écrire
# un backend
@app.tweet.receive(r'Chat')
@app.fb.receive(r'Like')
@app.instagram.receive(r'Bouffe')
@app.irc.message(r'dtc')
def _(ctx, args):
    pass</pre>
<p>Le problème des apps centrées sur un objet, c&#8217;est qu&#8217;elles ont souvent un design monolithique. Ce n&#8217;est pas un problème du concept d&#8217;app, c&#8217;est juste que les auteurs ont pensé &#8220;point d&#8217;entrée&#8221;, et pas &#8220;élément composable&#8221;.</p>
<p>Si besoin, on doit pouvoir composer une app via plusieurs sous-app :</p>
<pre lang="python">app = Application()
app.embed('autre.app')</pre>
<p>ou</p>
<pre lang="python">app = Application(embed=['app1', 'app2', 'app3'])</pre>
<p>Il faut des hooks pour overrider la configuration, mais vous avez compris le principe.</p>
<p>Un autre problème avec les plateformes comme NodeJS, c&#8217;est qu&#8217;il est difficile d&#8217;utiliser plusieurs coeurs. C&#8217;est une des raisons du succès de Go.</p>
<p>Or, Crossbar encourage la division en plusieurs process qui communiquent entre eux (un peu comme les channels). Créons aussi une API pour ça :</p>
<pre lang="python">p1 = app.process()
p2 = app.process()

# Déclarer et appeler une procédure dans process 1
@p1.wamp.remote('auth.signin')
def _(ctx, args):
    pass

# Déclarer et appeler une procédure dans process 2
@p2.wamp.event('auth.signedin')
def _(ctx, args):
    pass</pre>
<p>Ainsi on profite enfin de plusieurs CPU. La même chose en plus facile à changer:</p>
<pre lang="python"># Déclarer et appeler une procédure
@app.wamp.remote('auth.signin')
def _(ctx, args):
    pass

# Déclarer et appeler une procédure
@app.wamp.event('auth.signedin')
def _(ctx, args):
    pass

app.processes({
    1: ['wamp.remote:auth.signin']
    2: ['wamp.event:auth.signedin']
})</pre>
<p>En bonus, on fait la nique au GIL.</p>
<p>Mieux, on peut bouger ses process sur plusieurs machines :</p>
<p>Machine 1 (routeur):</p>
<pre lang="python">
router = Application(endpoint="0.0.0.0:8080")
router.run()
</pre>
<p>Machine 2 (authentification):</p>
<pre lang="python">
# IP du router
auth = Application('auth', connect_to="182.64.1.15:8080")

# Nommage automatique en fonction du nom de la fonction
# et de l'app, avec possibilité d'annuler ou overrider le prefix.
# Ici du coup la fonction s'appellera en RPC via 'auth.signin'
@auth.wamp.remote()
def signin(ctx, args):
    pass

auth.run()
</pre>
<p>Machine 3 (API REST):</p>
<pre lang="python">
web = Application('site', connect_to="182.64.1.15:8080")

@web.http.post(r'api/auth/')
def _(req, res):
    user = yield res.wamp.call('auth.signin',
                               req.POST['username'],
                               req.POST['password'])*
    if user
        user = yield res.wamp.pub('auth.signedin', user.userid)
        res.json({'token': user.token})
    else:
        res.json({'error': 'nope'})


@web.http.get(r'api/stuff/')
def _(req, res):
    res.json(get_stuff())

@web.http.serve('uri', '/path/to/dir', [allow_index])

web.run()
</pre>
<p>Et vous savez le plus beau dans tout ça ? En Python on a plein de libs qui sont encore bloquantes. En théorie on ne peut pas les utiliser dans les apps asynchrones. Quand on a toute sa logique métiers dans des classes d&#8217;ORM, c&#8217;est balot. Mais pas ici ! On met un process avec tous ces appels bloquants, et on les appelle depuis des process non bloquant en RPC de manière asynchrone. Pif, paf, pouf, problème isolé.</p>
<p>Après, libre à son imagination de rajouter des fonctionnalités de confort&#8230;</p>
<p>Callback qui sera appelé seulement x fois :</p>
<pre lang="python"># Déclarer et appeler une procédure
@p1.wamp.event('auth.signedin', options={'limit_calls': x} )
def _(ctx, args):
    pass</pre>
<p>Raccourcis pour les opérations courantes :</p>
<pre lang="python"># Recevoir et envoyer un événement
@app.sub('auth.signin')
def _(ctx, *args):
    # ctx.pub
@app.pub('auth.signedin')

# Déclarer et appeler une procédure
@app.proc('auth.signedin')
def _(ctx, args):
    # ctx.call
app.rpc()</pre>
<p>Comme je vous l&#8217;avais expliqué, crossbar peut gérer le cycle de vie de services externes à votre application au démarrage. Autant exposer cette API programativement :</p>
<pre lang="python">@app.service(['/urs/bin/nodejs', 'script.js'], [user], [group])</pre>
<p><code>.run()</code>, c&#8217;est cool, mais si on veut changer des options via la ligne de commande, faut se taper tout le boulot alors que ça pourrait très bien se générer automatiquement :</p>
<pre lang="python">@app.cmd_run()</pre>
<p>Et si vous faites : <code>python sites.py --debug=true --endpoint=0.0.0.0:5252</code>, ça le prend automatiquement en compte. Y a pas de raison de se faire chier.</p>
<p>En parlant de générer automatiquement des trucs, le fichiers de configs pour les services externes sur lesquels on peut avoir envie de brancher notre app, c&#8217;est toujours galère. Autant fournir un exemple de base qui est sûr de toujours marcher, généré avec les paramètres de notre app :</p>
<pre lang="bash">python site.py template centos:nginx
python site.py template ubuntu:upstart
python site.py template bsd:systemd # :D</pre>
<p>On peut partir très loin dans le délire &#8220;battery included&#8221;. Typiquement, on peut fournir des services externes nous même puisque crossbar nous le propose, et coder des versions moins bien, mais compatibles (et suffisantes pour les petits sites), de projets toujours utilses :</p>
<ul>
<li>cache (compatible redis)</li>
<li>live settings (compatible etcd) mais avec en prime un event wamp propagé à chaque</li>
<p>  changement de valeur</p>
<li>build (compatible, heu, j&#8217;en sais rien) qui s&#8217;occupe en tâche de fond de surveiller le >système de fichier et lancer les compilations, les minifications, les copies, les tests unittaires, etc.</li


<li>logging centralisé (compatible sentry).</li>
<li>Un bridge WAMP/REST qui permet d&#8217;envoyer et recevoir des events WAMP sur votre app Django ou flask en utilisant HTTP.</li>
</ul>
<p>On plug tout ça a une admin Web.</p>
<p>J&#8217;espère que je vous ai donné maintenant l&#8217;envie de vous plonger un peu plus dans cette techno, et peut être coder quelque chose avec.</p>
<p>Il n&#8217;y a plus d&#8217;excuses pour ne pas avoir de framework web next gen, ultime de la mort qui tue en Python. A part le fait qu&#8217;on soit des feignasses.</p>
<p>Ah, merde, on est foutus.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/le-potentiel-de-wamp-autobahn-et-crossbar-io/feed/</wfw:commentRss>
		<slash:comments>29</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">10380</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2014/06/tumblr_n3hz135rRO1r539hzo1_500.jpg" length="48460" type="image/jpg" />	</item>
		<item>
		<title>Le Web n&#8217;est plus HTTP + HTML</title>
		<link>http://sametmax.com/le-web-nest-plus-http/</link>
		<comments>http://sametmax.com/le-web-nest-plus-http/#comments</comments>
		<pubDate>Fri, 23 May 2014 05:24:53 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Philo et culture]]></category>
		<category><![CDATA[http]]></category>
		<category><![CDATA[internet]]></category>
		<category><![CDATA[web]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=10304</guid>
		<description><![CDATA[Demain, l'internet des objets avec le protocole DTC.]]></description>
				<content:encoded><![CDATA[<p>Si vous voulez énerver un blogger technophile, utilisez le mot Web là où vous devriez utiliser le mot <a href="http://sebsauvage.net/~sebsauva/comprendre/internet/index.html">Internet</a> et inversement.</p>
<p>Internet, c&#8217;est beaucoup plus que le Web. C&#8217;est SSH, IMAP, TELNET, DNS, POP, SMTP, FTP, RTSP, NNTP, Bittorent, TOR, Freenet, Bitcoin, et quelques centaines d&#8217;autres protocoles qui se parlent.</p>
<p>Jusqu&#8217;ici, le Web, c&#8217;était juste HTTP. Des ressources Web, sur lesquelles on agissait via une requête textuelle verbalisée (GET, POST, PUT, OPTION, HEAD, etc) et qui retournait une réponse, généralement en forme de HTML.</p>
<p>Ça a un peu évolué, on a eu SSL qui s&#8217;est rajouté, et donc HTTPS, et AJAX, qui n&#8217;a pas changé le protocole, mais rendu la nature des requêtes un peu différente. Rien qui n&#8217;empêche de debugger avec CURL.</p>
<p>Mais c&#8217;est bientôt fini tout ça.</p>
<p>Aujourd&#8217;hui les nouveaux protocoles utilisés dans le cadre du Web sont en passe de prendre le pouvoir. Bien sûr il y a  <a href="https://en.wikipedia.org/wiki/SPDY">SPDY</a> et <a href="http://en.wikipedia.org/wiki/QUIC">QUIC</a>, mais surtout, il a les protocoles basés sur les websockets type <a href="http://wamp.ws/">WAMP.ws</a>, mais également les nouvelles capacités P2P promises par <a href="http://en.wikipedia.org/wiki/WebRTC">WebRTC</a>. Et des apps qui utilisent massivement les données hors ligne, le scripting JS pour des features essentielles, de la video, du son&#8230;</p>
<p>Et donc adios, l&#8217;époque où vous pouviez juste dégainer <a href="http://docs.python-requests.org/">requests</a> et parler à un site. Bye bye le state less, le human readable, le cycle requête / réponse.</p>
<p>Le nombre de technologies qu&#8217;on doit empiler aujourd&#8217;hui pour déployer un site devient énorme : un moteur de recherche, un message broker, un gestionnaire de fil d&#8217;attente, un gestionnaire de déploiement, des technos d&#8217;isolation&#8230;</p>
<p>C&#8217;est fini la simplicité. C&#8217;est fini la transparence. L&#8217;ère du hacker amateur qui pouvait s&#8217;occuper d&#8217;un peu de tout, touche doucement à sa fin.</p>
<p>Au revoir et merci. Je me suis super amusé.</p>
<p>Et désolé pour les mômes qui arrivent maintenant, vous allez en chier. Mais vous avez aussi plus de possibilités qu&#8217;il n&#8217;y en a jamais eu. Plus qu&#8217;un homme ne peut concevoir. Plus que tous les hommes en fait.</p>
<p>Et RIP HTTP. Ou pas, puisqu&#8217;on passe notre temps à faire des APIs REST maintenant, mais aussi car on est en train de récréer un peu tout au dessus d&#8217;HTTP. Long live HTTP, alors, le nouveau TCP/IP. Sauf quand on fait du real time. Ou du P2P. Changement de status : &#8220;c&#8217;est compliqué entre moi et mon navigateur&#8221;.</p>
<p>Internet, phagocyté par le Web, sur lequel on reconstruit Internet et même le desktop ?</p>
<p>Je ne crois pas qu&#8217;il existe un seul métier qui ait autant changé en 10 ans. J&#8217;espère qu&#8217;on en laisse pas trop derrière en courant comme des fous en riant les yeux mi-clos. Pourvu qu&#8217;il y ait pas trop d&#8217;arbres en face. Pourvu qu&#8217;on aille pas dans la direction de la falaise.</p>
<p>En tout cas, c&#8217;est toujours fun. Je crois que je vais descendre la prochaine pente en roulant sur le côté. Et avoir la tête qui tourne. Vomir. Et dire que c&#8217;est la faute de Javascript.</p>
<p>Et recommencer.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/le-web-nest-plus-http/feed/</wfw:commentRss>
		<slash:comments>15</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">10304</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2014/05/3Mz9r1S.png" length="551410" type="image/jpg" />	</item>
	</channel>
</rss>
