<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" >

<channel>
	<title>object &#8211; Sam &amp; Max</title>
	<atom:link href="http://sametmax.com/tag/object/feed/" rel="self" type="application/rss+xml" />
	<link>http://sametmax.com</link>
	<description>Du code, du cul</description>
	<lastBuildDate>Thu, 05 Sep 2019 08:22:03 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.7</generator>
<site xmlns="com-wordpress:feed-additions:1">32490438</site>	<item>
		<title>Le guide ultime et définitif sur la programmation orientée objet en Python à l&#8217;usage des débutants qui sont rassurés par les textes détaillés qui prennent le temps de tout expliquer. Partie 1.</title>
		<link>http://sametmax.com/le-guide-ultime-et-definitif-sur-la-programmation-orientee-objet-en-python-a-lusage-des-debutants-qui-sont-rassures-par-les-textes-detailles-qui-prennent-le-temps-de-tout-expliquer-partie-1/</link>
		<comments>http://sametmax.com/le-guide-ultime-et-definitif-sur-la-programmation-orientee-objet-en-python-a-lusage-des-debutants-qui-sont-rassures-par-les-textes-detailles-qui-prennent-le-temps-de-tout-expliquer-partie-1/#comments</comments>
		<pubDate>Tue, 15 Jan 2013 07:30:56 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[class]]></category>
		<category><![CDATA[object]]></category>
		<category><![CDATA[poo]]></category>
		<category><![CDATA[python]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=4134</guid>
		<description><![CDATA[Je viens de dire que c'était le guide ultime et définitif sur la programmation orientée objet en Python à l'usage des débutants qui sont rassurés par les textes détaillés qui prennent le temps de tout expliquer. Partie 1. Je peux pas faire titre plus explicite, si ?]]></description>
				<content:encoded><![CDATA[<p>Prérequis à ce tuto bien chargé :</p>
<ul>
<li>comprendre parfaitement les mots clés les plus courants (conditions, tests, pass, etc);</li>
<li>comprendre parfaitement les fonctions (et donc les <a href="http://sametmax.com/operateur-splat-ou-etoile-en-python/">paramètres avancées</a> en Python);</li>
<li>comprendre la notion de <a href="http://sametmax.com/valeurs-et-references-en-python/">référence</a>;</li>
<li>connaitre les <a href="http://sametmax.com/quest-ce-quune-structure-de-donnees/">structures de données</a> de base (string, int, list, dict, etc).</li>
</ul>
<h2>Intro</h2>
<p>Il y a des tas de manières de programmer. Des styles. Des formes que l&#8217;on donne au code. On leur donne des noms: programmation procédurale, fonctionnelle, orientée flux, par contrat, etc. C&#8217;est ce qu&#8217;on appelle des paradigmes, des points de vue sur comment on doit faire le boulot.</p>
<p>En vérité, le point de vue n&#8217;est pas déterminant. Vous pouvez faire le même boulot en utilisant n&#8217;importe lequel. L&#8217;important c&#8217;est de coder.</p>
<p>Mais chaque point de vue possède des caractéristiques et des outils différents. </p>
<p>Ce que vous allez voir est ce qu&#8217;on appelle la programmation orientée objet, ou POO. C&#8217;est un simple point de vue, un outil, mais il est très utilisé en Python, Ruby ou Java.</p>
<p>Quand vous avez appris la programmation, on vous a montré comment stocker des données dans des structures de données:</p>
<ul>
<li>les listes</li>
<li>les chaînes</li>
<li>les entiers</li>
<li>les dictionnaires</li>
<li>etc</li>
</ul>
<p>Et on vous a montré comment créer un comportement pour votre programme en utilisant des mots clés, puis plus tard en utilisant des fonctions pour regrouper ces mots clés. </p>
<p>En Python, à ce stade, vous utilisez des fonctions pour agir sur des structures de données.</p>
<p><strong>La programmation orienté objet, c&#8217;est un style de programmation qui permet de regrouper au même endroit le comportement (les fonctions) et les données (les structures) qui sont faites pour aller ensemble.</strong></p>
<p>C&#8217;est tout. C&#8217;est une simple question d&#8217;organisation du programme.</p>
<h2>Qu&#8217;est-ce qu&#8217;un objet</h2>
<p>Un objet est un&#8230; truc. Un machin. Un bidule.</p>
<p>Ça peut vous paraître une définition floue, mais c&#8217;est parce que c&#8217;est exactement ce que peut être un objet: n&#8217;importe quoi que vous décidiez de coder. L&#8217;objet est un moyen de dire à la machine : “ce < entrez_ici_un_nom_de_truc > possède telle donnée, et fait telle chose avec”.</p>
<p>En Python, absolument tout est un objet : une chaîne, un entier, un dictionnaire, une liste, une fonction&#8230; Vous avez donc manipulé des objets sans le savoir. Maintenant vous allez créer les vôtres.</p>
<p>Créer des objets se fait en deux étapes: décrire à quoi ressemble votre objet, et demander à l&#8217;ordinateur d&#8217;utiliser cette description pour le fabriquer.</p>
<p>En Python 2.x, cela donne ceci:</p>
<pre lang="python">class DescriptionDeLObject:
    pass
>>> object_tout_neuf = DescriptionDeLObject()
>>> print object_tout_neuf
<__main__.DescriptionDeLObject instance at 0x3112440></pre>
<p>La description de l&#8217;objet (le plan de construction) est :</p>
<pre lang="python">class DescriptionDeLObject:
    pass</pre>
<p>C&#8217;est ce qu&#8217;on appelle une classe. La classe est le moyen, en Python, de décrire à quoi va ressembler un objet.</p>
<p>On dit ici:</p>
<p>&#8220;Cet objet s&#8217;appelle DescriptionDeLObject.&#8221;</p>
<p>C&#8217;est tout.</p>
<p>Ensuite, on crée l&#8217;objet:</p>
<pre lang="python">>>> object_tout_neuf = DescriptionDeLObject()</pre>
<p><code>DescriptionDeLObject()</code> (notez les parenthèses), est la syntaxe Python pour dire &#8220;fabrique un objet à partir de ce plan&#8221;. Le nouvel objet va être retourné, et mis dans la variable <code>object_tout_neuf</code>.</p>
<p>La variable <code>object_tout_neuf</code> contient un objet issu de la classe <code>DescriptionDeLObject</code>, on dit qu&#8217;il contient une instance de <code>DescriptionDeLObject</code>. C&#8217;est pour cela que l&#8217;action de créer un objet à partir d&#8217;une classe est appelée <em>instanciation</em>.</p>
<p>Python ne sait pas grand chose sur cet objet si ce n&#8217;est son nom et son adresse en mémoire. Si on fait <code>print</code> dessus, c&#8217;est donc ce qu&#8217;il vous donne:</p>
<pre lang="python">>>> print object_tout_neuf
<__main__.DescriptionDeLObject instance at 0x3112440></pre>
<p>On peut créer autant d&#8217;objets que l&#8217;on veut à partir d&#8217;une classe :</p>
<pre lang="python">>>> DescriptionDeLObject()
<__main__.DescriptionDeLObject instance at 0x31c1d40>
>>> DescriptionDeLObject()
<__main__.DescriptionDeLObject instance at 0x31d6cf8>
>>> DescriptionDeLObject()
<__main__.DescriptionDeLObject instance at 0x31d6bd8>
>>> DescriptionDeLObject()
<__main__.DescriptionDeLObject instance at 0x31d6c68></pre>
<h2>Méthodes</h2>
<p>Les méthodes sont des fonctions déclarées à l&#8217;intérieur de la classe. <em>Méthode</em> est juste un nom pour dire &#8220;cette fonction est dans une classe&#8221;. </p>
<pre lang="python">class DescriptionDeLObject:
    
    def la_methode(objet_en_cours):

        print 'Edgar Morin'</pre>
<p>Nous avons créé une &#8220;fonction&#8221; nommée <code>une_methode</code> dans le bloc de la classe. Puisqu&#8217;elle est dans ce bloc, cette fonction est ce qu&#8217;on appelle une méthode.</p>
<p>Elle n&#8217;existe pas en dehors de la classe.</p>
<pre lang="python">>>> la_methode()
Traceback (most recent call last):
  File "<ipython-input-12-c02691e8aa46>", line 1, in <module>
    la_methode()
NameError: name 'la_methode' is not defined</pre>
<p>Mais, elle est attachée à chaque objet. On peut l&#8217;utiliser en faisant < variable_contenant_objet >.< nom_de_méthode >. Ainsi, pour appeler une méthode, il nous faut forcément une instance :</p>
<pre lang="python">>>> objet_tout_neuf = DescriptionDeLObject()
>>> objet_tout_neuf.la_methode()
Edgar Morin</pre>
<p>Arrivé à ce stade, vous devez vous demander &#8220;quel est ce <code>objet_en_cours</code>&#8221; qui est défini comme paramètre de la méthode ?</p>
<p>C&#8217;est une spécificité de Python : quand vous appelez une méthode depuis un objet, l&#8217;objet est automatiquement passé en premier paramètre par Python. C&#8217;est automatique, et invisible.</p>
<p>C&#8217;est très facile à comprendre en faisant une méthode qui retourne <code>objet_en_cours</code> pour voir ce qu&#8217;il y a dedans :</p>
<pre lang="python">>>> class DescriptionDeLObject:
...         
...         def une_methode(objet_en_cours):
...         
...                 return objet_en_cours
...     
>>> ze_object = DescriptionDeLObject()
>>> print ze_object 
<__main__.DescriptionDeLObject instance at 0x3429170>
>>> print ze_object.une_methode()
<__main__.DescriptionDeLObject instance at 0x3429170></pre>
<p>Python fait comme si on avait fait :</p>
<pre lang="python">DescriptionDeLObject.une_methode(ze_object)
</pre>
<p><code>objet_en_cours</code> et <code>ze_object</code> contiennent la même chose : l&#8217;objet en cours. <code>objet_en_cours</code> est juste le nom que nous avons donné à notre premier argument, mais Python passe toujours automatiquement en premier argument l&#8217;objet en cours afin que vous puissiez modifier cet objet à l&#8217;intérieur d&#8217;une méthode.</p>
<p>On dit donc que <code>objet_en_cours</code> est l&#8217;instance courante.</p>
<p>Une méthode doit donc toujours déclarer au moins un paramètre pour accueillir la référence à l&#8217;objet en cours, sinon ça plante. Voyez plutôt :</p>
<pre lang="python">class DescriptionDeLObject:
    
    def methode_sans_objet_en_cours():

        print "test"

    def methode_avec_objet_en_cours(objet_en_cours):

        print "test"

>>> ze_object = DescriptionDeLObject()
>>> ze_object.methode_avec_objet_en_cours() 
test
>>> ze_object.methode_sans_objet_en_cours()
Traceback (most recent call last):
  File "<ipython-input-19-90434b7e7bfa>", line 1, in <module>
    ze_object.methode_sans_objet_en_cours()
TypeError: methode_sans_objet_en_cours() takes no arguments (1 given)</pre>
<p>Python dit que <code>methode_sans_objet_en_cours</code> est déclarée sans argument mais on lui en a passé un tout de même. Et en effet, Python lui a passé de manière invisible l&#8217;objet en cours en tant que premier argument. </p>
<p>En résumé, on déclare une classe avec une méthode ainsi:</p>
<pre lang="python">
class DescriptionDeLObject:
    
    def nom_de_methode(objet_en_cours):

        faire quelque chose ici
</pre>
<p>Et on l&#8217;utilise ainsi:</p>
<pre lang="python">
variable = DescriptionDeLObject()
variable.nom_de_methode()</pre>
<h2>Conventions</h2>
<p>En Python, peu de choses sont forcées. La plupart des choses sont des conventions. Mais ce sont des conventions fortes, les gens y tiennent.</p>
<p>Parmi ces conventions, il y a les conventions de nommage, à savoir:</p>
<ul>
<li>
on nomme les classes sans espace, avec des majuscules : NomDUneClasse</li>
<li>
on nomme le reste en minuscule avec des underscores : nom_de_methode, nom_d_attribut, etc</li>
</ul>
<p>La convention la plus surprenante est celle du premier paramètre des méthodes qui contient l&#8217;objet en cours. Son nom n&#8217;est pas forcé, contrairement aux autres langages (comme <code>this</code> en Java par exemple), en fait c&#8217;est un paramètre tout à faire ordinaire. Néanmoins, la (très très forte) convention est de l&#8217;appeler <code>self</code> :</p>
<pre lang="python">class DescriptionDeLObject:
    
    def nom_de_methode(self):

        faire quelque chose ici</pre>
<p>Appelez-donc TOUJOURS le premier paramètre de chaque méthode <code>self</code>, et rappelez-vous qu&#8217;il contiendra toujours l&#8217;instance courante.</p>
<p>Enfin, les concepteurs de Python ont ajouté une convention supplémentaire : les méthodes appelées automatiquement sont appelées <code>__nom_de_methode__</code> (avec deux underscores de chaque côté).</p>
<p>En effet, il existe un certains nombre de méthodes que vous pouvez écrire, et si vous les nommez d&#8217;une certaine façon, elle seront appelées automatiquement quand une condition spéciale (liée au nom), se présente.</p>
<p>Nous verrons cela avec la méthode <code>__init__</code>.</p>
<h2>Attributs</h2>
<p>Vous avez vu que les méthodes étaient juste des fonctions attachées à un objet. Hé bien les attributs sont juste des variables attachées à un objet.</p>
<p>En fait, techniquement, les méthodes sont aussi des attributs, mais faisons comme si ce n&#8217;était pas le cas et séparons :</p>
<ul>
<li>méthodes : fonctions pour objets</li>
<li>attributs : variables pour objets</li>
</ul>
<p>Comme Python est un langage dynamique, on peut ajouter n&#8217;importe quel attribut à n&#8217;importe quel objet en utilisant la syntaxe < objet >.< nom_attribut > :</p>
<pre lang="python">>>> print ze_object.un_attribut # l'attribut n'existe pas
Traceback (most recent call last):
  File "<ipython-input-30-b52a599929f9>", line 1, in <module>
    ze_object.un_attribut
AttributeError: DescriptionDeLObject instance has no attribute 'un_attribut'

>>> ze_object.un_attribut = "valeur de l'attribut"
>>> print ze_object.un_attribut
valeur de l'attribut</pre>
<p>Et c&#8217;est là que vous allez voir l&#8217;interêt de <code>self</code> :</p>
<pre lang="python">class DescriptionDeLObject:
    
    def afficher(self):

        # self est l'objet en cours, donc on à accès à ses attributs !
        print self.un_attribut

    def modifier(self):

        # on peut modifier les attributs depuis l'intérieur
        self.un_attribut = "autre valeur"</pre>
<p>On peut accéder aux attributs depuis l&#8217;intérieur et l&#8217;extérieur d&#8217;un objet :</p>
<pre lang="python">>>> ze_object = DescriptionDeLObject() 
>>> ze_object.afficher() # l'attribut n'existe pas encore
Traceback (most recent call last):
  File "<ipython-input-35-c10abd45fc98>", line 1, in <module>
    ze_object.afficher() # l'attribut n'exite pas
  File "<ipython-input-33-3e1eb4d8e5f6>", line 5, in afficher
    print self.un_attribut
AttributeError: DescriptionDeLObject instance has no attribute 'un_attribut'

>>> ze_object.un_attribut = "maintenant il existe !"
>>> ze_object.afficher() 
maintenant il existe !
>>> ze_object.modifier() # l'attribut est modifié par la méthode
>>> ze_object.un_attribut 
'autre valeur'</pre>
<p>Comme une méthode est juste une fonction attachée à un objet, on peut lui passer des paramètres. Et une méthode a accès à l&#8217;objet en cours, elle peut modifier l&#8217;objet en cours. </p>
<p>Donc, une méthode peut modifier l&#8217;objet en cours en fonction des paramètres passés :</p>
<pre lang="python">class DescriptionDeLObject:
    
    def afficher(self):

        print "La valeur actuelle est %s" % self.un_attribut

    def modifier(self, valeur):

        self.un_attribut = valeur * 2

>>> ze_object = DescriptionDeLObject()
>>> ze_object.un_attribut = 1 # on met un entier en valeur cette fois
>>> ze_object.afficher()
La valeur actuelle est 1
>>> ze_object.modifier(2) # on passe un paramètre 
>>> ze_object.afficher()
La valeur actuelle est 4</pre>
<p>Les méthodes servent exactement à cela : retourner les valeurs à l&#8217;intérieur de l&#8217;objet, ou à les modifier.</p>
<h2>Initialisation d&#8217;un objet</h2>
<p>On souhaite généralement donner un état de départ à tout nouvel objet créé. Par exemple, si vous travaillez sur un jeu vidéo de course de voitures, vous voudrez peut-être créer un objet voiture avec du carburant et une couleur de peinture. </p>
<p>Il serait contre productif de devoir les spécifier à chaque fois. Pour automatiser le travail, Python met à disposition des méthodes appelées automatiquement quand une condition est remplie. Ce sont les méthodes nommées <code>__methode__</code>.</p>
<p>Dans notre cas, on veut que notre objet ait un état de départ, donc on va utiliser la méthode qui est appelée automatiquement après la création de l&#8217;objet. C&#8217;est la méthode <code>__init__</code>.</p>
<p>Si vous définissez une méthode avec le nom <code>__init__</code>, Python va automatiquement, et de manière invisible, appeler la méthode après avoir créé l&#8217;objet : </p>
<pre lang="python">class DescriptionDeLObject:
    
    def __init__(self):

        print "L'objet a été créé !"
        print "La méthode est appelée automatiquement"

>>> ze_object = DescriptionDeLObject()
L'objet a été créé !
La méthode est appelée automatiquement</pre>
<p><code>__init__</code> est une méthode tout à fait ordinaire. Seul le nom est important: comme elle est appelée ainsi, Python la détecte automatiquement et l&#8217;appelle au bon moment.</p>
<p>C&#8217;est très utile pour fournir un état de départ:</p>
<pre lang="python">class Voiture:

    def __init__(self):

        self.carburant = 100
        self.couleur = "noire"

>>> v = Voiture()
>>> v.couleur
'noire'
>>> v.carburant
100</pre>
<p>Bien entendu, on veut généralement pouvoir changer l&#8217;état de départ. Ici encore, Python nous aide:<strong> si vous passez des paramètres à l&#8217;instanciation, ils sont passés automatiquement à <code>__init__</code></strong>.</p>
<p>Comme <code>__init__</code> est une méthode ordinaire (et donc une fonction), on peut lui donner des paramètres avec des valeurs par défaut mais accepter une nouvelle valeur si elle est passée :</p>
<pre lang="python">class Voiture:

    def __init__(self, combien_de_carburant=100, quelle_couleur="noire"):

        self.carburant = combien_de_carburant
        self.couleur = quelle_couleur


>>> v1 = Voiture() # sans paramètres, les valeurs par défaut sont utilisées
>>> v1.couleur
'noire'
>>> v1.carburant
100
>>> v2 = Voiture(50, 'rouge et jaune à petit pois') # on change les valeurs
>>> v2.couleur 
'rouge et jaune \xc3\xa0 petit pois'
>>> v1.couleur
'noire'
>>> v3 = Voiture(quelle_couleur="fushia virant sur l'aigue marine")
>>> v3.couleur
"fushia virant sur l'aigue marine"
>>> v3.carburant
100</pre>
<p>Les valeurs passées dans <code>Voiture(valeurs, passées)</code>, sont automatiquement repassées à <code>__init__</code>(self, valeurs, passées). </p>
<p>En résumé : <code>__init__</code> est appelée automatiquement après que l&#8217;objet soit créé, et on lui passe les paramètres passés à l&#8217;instanciation. Comme <code>__init__</code> est une méthode et a accès à l&#8217;instance courante, elle peut ajouter des attributs à l&#8217;objet en cours en fonction de ces paramètres. On utilise ça pour créer des objets avec un état de départ par défaut, et permettre une personnalisation de cet état de départ.</p>
<p>J&#8217;ai mis des noms différents pour les paramètres d&#8217;<code>__init__</code> et les attributs de l&#8217;objet, mais en réalité on leur met souvent le même nom par convention. Donc l&#8217;exemple ci-dessus s&#8217;écrirait plutôt :</p>
<pre lang="python">class Voiture:

    def __init__(self, carburant=100, couleur="noire"):

        self.carburant = carburant
        self.couleur = couleur
</pre>
<p><code>carburant</code> et <code>couleur</code> ne sont pas la même chose que <code>self.carburant</code> et <code>self.couleur</code> : les premiers n&#8217;existent que dans <code>__init__</code>. Une fois qu&#8217;<code>__init__</code> a fini de s’exécuter, ils disparaissent. Les seconds sont des attributs de l&#8217;objet en cours, et sont donc toujours disponibles tant que l&#8217;objet existe. Le fait qu&#8217;ils portent le même nom ne pose aucun problème car la syntaxe <code>self.<attribut></code> les différencie.</p>
<h2>Résumé final</h2>
<p>La classe, c&#8217;est un plan. </p>
<p>L&#8217;objet, c&#8217;est ce qu&#8217;on crée avec le plan. </p>
<p>Une méthode, c&#8217;est une fonction déclarée dans une classe (qui est attachée à chaque objet produit, et on lui passe en premier paramètre l&#8217;objet en cours). </p>
<p>Un attribut, c&#8217;est une variable attachée à un objet. </p>
<p>Une instance d&#8217;une classe, c&#8217;est l&#8217;objet issu d&#8217;une classe.</p>
<p><a href="https://fr.wikipedia.org/wiki/Spermophile">Un spermophile</a>, c&#8217;est un animal dont la queue est assez courte et plus ou moins fournie. Il aime être à 4 pattes et mange parfois des glands. Ça n&#8217;a rien à voir, mais je me suis dit qu&#8217;il fallait faire passer l&#8217;info. Ah oui, et la cuniculture, <a href="https://fr.wikipedia.org/wiki/Cunniculture">c&#8217;est prendre soin d&#8217;un lapinou</a>. La levrette, par contre, n&#8217;est pas la femelle du lièvre. </p>
<p>Le vocabulaire en informatique, <a href="http://danstonchat.com/14113.html">c&#8217;est primordial</a>.<br />
<a href="http://sametmax.com/le-guide-ultime-et-definitif-sur-la-programmation-orientee-objet-en-python-a-lusage-des-debutants-qui-sont-rassures-par-les-textes-detailles-qui-prennent-le-temps-de-tout-expliquer-partie-2/"><br />
La partie 2</a>, c&#8217;est par ici.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/le-guide-ultime-et-definitif-sur-la-programmation-orientee-objet-en-python-a-lusage-des-debutants-qui-sont-rassures-par-les-textes-detailles-qui-prennent-le-temps-de-tout-expliquer-partie-1/feed/</wfw:commentRss>
		<slash:comments>43</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">4134</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2013/01/michel-ange.jpg" length="19849" type="image/jpg" />	</item>
	</channel>
</rss>
