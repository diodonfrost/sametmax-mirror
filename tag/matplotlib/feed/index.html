<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" >

<channel>
	<title>matplotlib &#8211; Sam &amp; Max</title>
	<atom:link href="http://sametmax.com/tag/matplotlib/feed/" rel="self" type="application/rss+xml" />
	<link>http://sametmax.com</link>
	<description>Du code, du cul</description>
	<lastBuildDate>Thu, 05 Sep 2019 08:22:03 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.7</generator>
<site xmlns="com-wordpress:feed-additions:1">32490438</site>	<item>
		<title>Les bases de Numpy</title>
		<link>http://sametmax.com/les-bases-de-numpy/</link>
		<comments>http://sametmax.com/les-bases-de-numpy/#comments</comments>
		<pubDate>Wed, 19 Feb 2014 19:18:54 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[matplotlib]]></category>
		<category><![CDATA[numpy]]></category>
		<category><![CDATA[python]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=9198</guid>
		<description><![CDATA[Numpy est une lib destinée à la manipulation de grands ensembles de nombres et est très utilisée par la communauté scientifique.

Elle propose des types et des opérations beaucoup plus performants que ceux de la lib standard, et possède des raccourcis pour les traitements de masse.

Malheureusement, c'est aussi une lib complexe, et, comme souvent dans le monde de la science, les tutos pourraient être plus clairs.
]]></description>
				<content:encoded><![CDATA[<p><a href="http://www.numpy.org/">Numpy</a> est une lib destinée à la manipulation de grands ensembles de nombres et est très utilisée par la communauté scientifique.</p>
<p>Elle propose des types et des opérations beaucoup plus performants que ceux de la lib standard, et possède des raccourcis pour les traitements de masse.</p>
<p>Malheureusement, c&#8217;est aussi une lib complexe, et, comme souvent dans le monde de la science, les tutos pourraient être plus clairs.</p>
<p>Cet article ne prétend pas à une couverture exhaustive de Numpy, d&#8217;autant que je n&#8217;ai pas le niveau en maths pour faire une simple dérivée alors des opérations matricielles complexes&#8230;</p>
<p>Mais ça devrait permettre de démystifier le truc pour les gens qui regardent ça de loin comme si c&#8217;était un pingouin au Mali.</p>
<p>Commencez par installer la bestiole avec un <code><a href="http://sametmax.com/votre-python-aime-les-pip/">pip</a> install numpy</code>. Faites-vous un café pendant que ça compile.</p>
<h2><code>array</code> sur image</h2>
<p>A la base de Numpy, il y a la manipulation d&#8217;ensembles ordonnés de nombres. On peut faire les opérations voulues sur un type <code>list</code> ordinaire, mais ce serait lent, et ça prendrait pas mal de mémoire.</p>
<p>L&#8217;alternative est d&#8217;utiliser un type optimisé comme <code>ndarray</code>, fourni par Numpy.</p>
<p>Cela se manipule comme une tuple, avec une différence majeure : il ne peut contenir qu&#8217;un seul type de données. Donc on ne met que des <code>int</code>, ou que des <code>str</code>, que des <code>bool</code>, etc.</p>
<p>On peut construire un array à partir de n&#8217;importe quel itérable :</p>
<pre lang="python">>>> from numpy import array
>>> array([1, 2, 3])
array([1, 2, 3])
>>> array(u"azerty")
array(u'azerty',
      dtype='<U6')
>>> array((1.0, 2.0, 3.0))
array([ 1.,  2.,  3.])</pre>
<p>Mais souvent on utilisera une fonction générant un array automatiquement afin d&#8217;éviter de créer deux structures de données (la liste, puis l&#8217;array par exemple).</p>
<p>On peut utiliser <code>arange</code>, qui est l&#8217;équivalent de <code>range</code>, mais pour les arrays :</p>
<pre lang="python">>>> from numpy import arange
>>> arange(1, 100, 2)
array([ 1,  3,  5,  7,  9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33,
       35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67,
       69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99])</pre>
<p>Ainsi que des choses plus perfectionnées comme <code>linspace</code>, qui retourne un array de n nombre de valeurs <strong>uniformément réparties</strong> entre deux bornes:</p>
<pre lang="python">>>> from numpy import linspace
>>> linspace(0, 100, 15) # 15 valeur entre 0 et 100
array([   0.        ,    7.14285714,   14.28571429,   21.42857143,
         28.57142857,   35.71428571,   42.85714286,   50.        ,
         57.14285714,   64.28571429,   71.42857143,   78.57142857,
         85.71428571,   92.85714286,  100.        ])</pre>
<p>Comme les tuples, les arrays sont itérables, sliceables, indexables et de  taille fixe :</p>
<pre lang="python">>>> sistance = arange(10)
>>> for x in a: # iterable
...     print x
...
0
1
2
3
4
5
6
7
8
9
>>> sistance[2:4] # sliceable
array([2, 3])
>>> sistance[-1] # indexable
9
>>> sistance.append(11) # taille fixe
Traceback (most recent call last):
  File "<ipython-input-17-389b8ea2fe68>", line 1, in <module>
    sistance.append(11)
AttributeError: 'numpy.ndarray' object has no attribute 'append'
</pre>
<p>L&#8217;array représente donc une photographie figée de vos données, mais comme vous allez le voir, rapide et précise à manipuler.</p>
<h2>Opérations groupées</h2>
<p>La caractéristique marquante de l&#8217;array, c&#8217;est que si vous lui appliquez un opérateur mathématique, un nouvel array est retourné dont TOUTES les valeurs ont été modifiées.</p>
<p>Par exemple, si vous multipliez un array, un nouvel array est retourné avec toutes les valeurs multipliées :</p>
<pre lang="python">>>> duku = array([1, 2, 3])
>>> au_milieu = duku * 2
>>> au_milieu
array([2, 4, 6])</pre>
<p>En fait, numpy fait une boucle implicite &#8211; et performante &#8211; sur tout l&#8217;array pour chaque opération mathématique. Et ça devient intéressant quand on veut faire des opérations entre plusieurs arrays entre eux :</p>
<pre lang="python">>>> duku
array([1, 2, 3])
>>> au_milieu
array([2, 4, 6])
>>> de_tram = duku + au_milieu
>>> de_tram
array([3, 6, 9])</pre>
<h2>Une autre dimension</h2>
<p>Si on travaille sur une liste plate, l&#8217;array est pratique, mais on en reste là. Néanmoins sa grande force est sa capacité à travailler sur plusieurs dimensions, et donc modifier tout aussi facilement des arrays d&#8217;arrays d&#8217;arrays d&#8217;arrays (arrête !) :</p>
<pre lang="python">>>> thorique = array([ [1, 2, 3], [4, 5, 6], [7, 8, 9]])
>>> thorique
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
>>> thorique ** 3
array([[  1,   8,  27],
       [ 64, 125, 216],
       [343, 512, 729]])</pre>
<p>L&#8217;opération a été appliquée à tous les éléments sans faire de boucle, et en suivant l&#8217;imbrication de la structure de données récursivement.</p>
<p>Mais la partie la plus funky, c&#8217;est que le slicing AUSSI, peut se faire sur plusieurs dimensions.</p>
<p>Vous connaissez le slicing à une dimension :</p>
<pre lang="python">>>> import random
>>> ticence = array([[random.randint(0, 100) for x in range(5)] for x in range(5)])
>>> ticence
array([[77, 44, 93, 65,  3],
       [ 8, 64, 36, 80, 77],
       [69, 24, 57, 18, 99],
       [60, 33, 63, 71, 99],
       [33, 60, 98, 85, 70]])
>>> ticence[1:4] # récupération des élément de 1 (inclus) à 4 (exclus)
array([[ 8, 64, 36, 80, 77],
       [69, 24, 57, 18, 99],
       [60, 33, 63, 71, 99]])</pre>
<p>Mais avec un array numpy, on peut utiliser une <strong>virgule</strong> après le premier slicing, et mettre un nouveau slicing qui va travailler sur la dimension suivante.</p>
<p>Par exemple, ici j&#8217;applique le slice <code>1:4</code> sur la première dimension (je diminue le nombre de lignes) et ensuite j&#8217;applique le slicing <code>0:3</code> sur la seconde dimension (je diminue le nombre d&#8217;éléments de chaque lignes restantes, donc des colonnes).</p>
<pre lang=python>>>> ticence[1:4, 0:3]
array([[ 8, 64, 36],
       [69, 24, 57],
       [60, 33, 63]])</pre>
<p>Ca marche comme ça :</p>
<pre lang=python>array[slicing_sur_dimension1, slicing_sur_dimension2, slicing_sur_dimension3, etc]</pre>
<p>Si on commence à avoir beaucoup de dimensions et qu&#8217;on ne veut toucher que la dernière dimension, on peut utiliser Ellipsis.</p>
<pre lang="python">>>> d2 = array([[random.randint(0, 100) for x in range(5)] for x in range(5)])
>>> d3 = array([d2.copy() for x in range(5)])
>>> d4 = array([d3.copy()  for x in range(5)])
>>> d5 = array([d4.copy()  for x in range(5)])
>>> d6 = array([d5.copy()  for x in range(5)])
>>> d6[1:3,...,-3:-1]
          [... plein de trucs ...]
          [[ 9, 86],
           [16, 40],
           [63, 26],
           [51,  5],
           [ 3, 46]],

          [[ 9, 86],
           [16, 40],
           [63, 26],
           [51,  5],
           [ 3, 46]]]]]])</pre>
<p>La dernière ligne, on prend un tableau à 6 dimensions, on applique un slicing <code>1:3</code> sur la première dimension, et un slicing <code>-3:-1</code> sur la <strong>dernière</strong> dimension.</p>
<p>Il est vrai que je ne m&#8217;en sers pas souvent.</p>
<p>Ok, je ne m&#8217;en suis jamais servi de toute ma vie. A part pour ce tuto. Mais c&#8217;est super classe non ?</p>
<p>Attention, cela ne marche que si toutes les dimensions ont le même nombre d&#8217;éléments. Cela se voit facilement en cas d&#8217;erreur car si le nombre d&#8217;éléments n&#8217;est pas bon, numpy va afficher votre array en ligne et pas sous forme de tabulaire :</p>
<pre lang="python">>>> array([[1, 2, 5, 7, 9, 7, 8],[1,9]])
array([[1, 2, 5, 7, 9, 7, 8], [1, 9]], dtype=object)</pre>
<p>Vous voyez en plus qu&#8217;il précise ici <code>dtype=object</code>, alors qu&#8217;il ne l&#8217;a pas fait plus haut.</p>
<h2>Matplotlib pour afficher tout ça</h2>
<p>En théorie, la lib matplotlib n&#8217;a rien à voir avec numpy. En pratique les utilisateurs de numpy utilisent très souvent numpy + matplotlib + ipython pour avoir une équivalent de matlab en Python.</p>
<p>Matplotlib est une lib qui permet de dessiner des graphes, mais qui a la particularité d&#8217;être orienté interaction. C&#8217;est à dire qu&#8217;elle est plus destinée à fabriquer votre graphe à la main, en bidouillant vos données, et possède dont des facilités pour cela.</p>
<p>D&#8217;abord on <code>pip install matplotlib</code>, et on prie pour que ça marche car sur certains OS ça plante méchamment.</p>
<p>Et ensuite dans son shell, on peut créer un petit graphe facilement sans trop se soucier des réglages, ceux par défaut étant pas mal :</p>
<pre lang="python">
from pylab import plot, xlabel, ylabel, title, legend
from numpy import sin, pi, linspace

# On active le mode interactif.
# Cela permet de voir notre graph
# en popup et de le modifier
# en temps réel.
ion()

# Utilisation de mes vagues connaissances
# de trigo pour pondre une sinusite...
# Heu, une sinusoide.

# Un array de 50 points répartis uniformément
# entre 0 et 2pi. Ca va nous servir de
# première coordonnée pour nos points.
x = linspace(0, 2 * pi)

# La fonction sin() de numpy va
# faire un nouvel array avec le sinus
# des points de l'array précédent.
# Ca nous fait notre deuxième coordonnée.
y = sin(x)

# On dessine la courbe, et on lui donne un pti nom
plot(x, y, label=u"Moi")
# Si je me suis pas trop planté ça devrait osciller
# entre 1 et -1

# On labellise les abscisses et les ordonnées
# car des données sans une échelle claire ne
# servent à rien.
ylabel(u"Self esteem (sur l'echelle de Richter)")
xlabel(u'Temps passé sur Dota (en joule par km)')

# On titre notre œuvre
title("Brace yourself, the graph is comming")
# On active la légende car le sujet est légendaire
legend()

</pre>
<p>Ce qui nous affiche :</p>
<div id="attachment_9201" style="width: 416px" class="wp-caption aligncenter"><a href="http://sametmax.com/wp-content/uploads/2014/02/brace.png" class="grouped_elements" rel="tc-fancybox-group9198"><img src="http://sametmax.com/wp-content/uploads/2014/02/brace.png" alt="Graphe de courbe sinusoidale" title="J&#039;imagine toujours un petit train sur ce genre de courbe" width="406" height="306" class="size-full wp-image-9201" /></a><p class="wp-caption-text">J&#039;imagine toujours un petit train sur ce genre de courbe</p></div>
<p>Vous ne vous transformerez pas tout de suite en chercheur du CNRS après avoir lu ce tuto, mais j&#8217;espère qu&#8217;il vous aura donné un peu envie de faire mumuse avec Python pour manipuler vos données scientifiques.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/les-bases-de-numpy/feed/</wfw:commentRss>
		<slash:comments>22</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">9198</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2014/02/bLXjrQc.jpg" length="169906" type="image/jpg" />	</item>
	</channel>
</rss>
