<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" >

<channel>
	<title>merge &#8211; Sam &amp; Max</title>
	<atom:link href="http://sametmax.com/tag/merge/feed/" rel="self" type="application/rss+xml" />
	<link>http://sametmax.com</link>
	<description>Du code, du cul</description>
	<lastBuildDate>Thu, 05 Sep 2019 08:22:03 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.7</generator>
<site xmlns="com-wordpress:feed-additions:1">32490438</site>	<item>
		<title>Configurer un outil de merge pour git sous Windows</title>
		<link>http://sametmax.com/configurer-un-outil-de-merge-pour-git-sous-windows/</link>
		<comments>http://sametmax.com/configurer-un-outil-de-merge-pour-git-sous-windows/#comments</comments>
		<pubDate>Sat, 08 Mar 2014 23:04:12 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Administration System]]></category>
		<category><![CDATA[Programmation]]></category>
		<category><![CDATA[git]]></category>
		<category><![CDATA[kdiff3]]></category>
		<category><![CDATA[merge]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=9725</guid>
		<description><![CDATA[Si vous utilisez msysgit, il n'y a pas d'outil pratique préinstallé pour gérer ce qui suit un  <code>git mergetool</code>. Le plus simple à configurer est kdiff3.]]></description>
				<content:encoded><![CDATA[<p>Si vous utilisez msysgit, il n&#8217;y a pas d&#8217;outil pratique préinstallé pour gérer ce qui suit un  <code>git mergetool</code>. Le plus simple à configurer est kdiff3. Il suffit de le <a href="http://sourceforge.net/projects/kdiff3/files/">télécharger</a> et installer, puis de rajouter ceci dans votre fichier .gitconfig :</p>
<pre lang="ini">[diff]
    tool = kdiff3
	keepBackup = false
	prompt = false
[merge]
    tool = kdiff3
	keepBackup = false
	prompt = false
[mergetool "kdiff3"]
    path = C:/Program Files (x86)/KDiff3/kdiff3.exe
    trustExitCode = false
</pre>
<p>Remplacez &#8220;C:/Program Files (x86)/KDiff3/kdiff3.exe&#8221; par le bon chemin selon votre système, bien entendu.</p>
<p>kdiff3 a tendance à laisser trainer des fichiers *.orig après le merge, et ça peut se régler dans <code>Configure/Options > Directory Merge > Backup Files (*.orig).<br />
</code><br />
Ainsi votre prochain merge ouvrira tranquilement kdiff3 pour chaque conflit.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/configurer-un-outil-de-merge-pour-git-sous-windows/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">9725</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2014/03/tumblr_n22jp0n5kN1r539hzo1_500.jpg" length="78874" type="image/jpg" />	</item>
		<item>
		<title>Mesurer les performances d&#8217;un snippet Python</title>
		<link>http://sametmax.com/mesurer-les-performances-dun-snippet-python/</link>
		<comments>http://sametmax.com/mesurer-les-performances-dun-snippet-python/#comments</comments>
		<pubDate>Sat, 08 Jun 2013 20:20:52 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[dict]]></category>
		<category><![CDATA[merge]]></category>
		<category><![CDATA[perf]]></category>
		<category><![CDATA[python]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=6369</guid>
		<description><![CDATA[L'open source c'est fantastique. Github c'est merveilleux. On parle de <a href="http://sametmax.com/batbelt-la-lib-des-petits-outils-python-qui-vont-bien/">batbelt</a>, et paf, quelques jours plus tard on a notre <a href="https://github.com/sametmax/Bat-belt/pull/1">première contribution</a>.]]></description>
				<content:encoded><![CDATA[<p>Ca fait longtemps que j&#8217;avais pas musique.</p>

<!-- iframe plugin v.4.3 wordpress.org/plugins/iframe/ -->
<iframe width="420" height="315" src="http://www.youtube.com/embed/qeMFqkcPYcg" frameborder="0" 0="allowfullscreen" scrolling="yes" class="iframe-class"></iframe>

<p>L&#8217;open source c&#8217;est fantastique. Github c&#8217;est merveilleux. On parle de <a href="http://sametmax.com/batbelt-la-lib-des-petits-outils-python-qui-vont-bien/">batbelt</a>, et paf, quelques jours plus tard on a notre <a href="https://github.com/sametmax/Bat-belt/pull/1">première contribution</a>.</p>
<p>Ce qui est sympa avec cette lib, c&#8217;est que ce sont des fonctions simples et courtes, axées sur des tâches très précises. Le code est donc généralement <a href="https://github.com/sametmax/Bat-belt/blob/master/batbelt/structs.py">intéressant à lire</a>, mais pas trop compliqué, et on tombe souvent sur des cas d&#8217;école.</p>
<p>C&#8217;est le cas de cette modification de la fonction <code>dmerge()</code>. Originalement, <code>dmerge</code> permet de créer un dictionnaire à partir de la fusion de de 2 autres dicos, et ça marchait comme ça:</p>
<pre lang="python">def dmerge(d1, d2):
    d = {}
    d.update(d1)
    d.update(d2)
    return d</pre>
<p>Facile à comprendre, rapide, simple, et le comportement par défaut est intuitif : si une clé est en double, la clé du deuxième dico écrase la première.</p>
<p>Comme le <a href="http://sametmax.com/batbelt-la-lib-des-petits-outils-python-qui-vont-bien/#comment-9657">précisait Etienne,</a> ce comportement est néanmoins un parmi de nombreux possibles. On pourrait aussi vouloir:</p>
<ul>
<li>Lever une exception en cas de doublon.</li>
<li>Concaténer ou additionner les doublons.</li>
<li>Mettre les doublons dans une liste.</li>
<li>Garder la valeur originale en cas de doublon.</li>
<li>Prendre la valeur la plus grande / petite en cas de doublon.</li>
<li>Etc.</li>
</ul>
<p>Pour cela, notre contributeur a proposé qu&#8217;on puisse passer en paramètre une fonction qui choisit quelle valeur garder en cas de doublon. Le code devient donc :</p>
<pre lang="python">
def dmerge(d1, d2, merge_func=lambda v1, v2: v2):
    d = {}
    d.update([(k, v) for k, v in d1.iteritems() if k not in d2])
    d.update([(k, v) for k, v in d2.iteritems() if k not in d1])
    d.update([(k, merge_func(v, d2[k])) for k, v in d1.iteritems() if k in d2])
    return d
</pre>
<p>Avoir une valeur par défaut nous permet de garder le comportement initial. Pour cela on utilise une <a href="http://sametmax.com/fonctions-anonymes-en-python-ou-lambda/">lambda</a>. C&#8217;est ce qu&#8217;on appelle l&#8217;injection de dépendance.</p>
<p>Comme j&#8217;ai bien faire mumuse avec Python, je me suis demandé : &#8220;quelle est la stratégie de merge la plus rapide ?&#8221;. J&#8217;ai donc fait plusieurs tests de merge, avec plusieurs algos. Voici ce que ça donne:</p>
<pre lang="python">
 from itertools import chain
  
  
 def dmerge1(d1, d2, merge_func=None):
     """
         Mon premier essai, en virant la lambda et en utilisant itertools.
     """
     d = {}
  
     if merge_func is None:
  
         d.update(d1)
         d.update(d2)
         return d
  
     for k, v in chain(d1.iteritems(), d2.iteritems()):
         if k in d1 and k in d2:
             d[k] = merge_func(d1[k], d2[k])
         else:
             d[k] = v
  
     return d
  
  
  
 def dmerge2(d1, d2, merge_func=lambda v1, v2: v2):
     """
         Le code du PR original
     """
     d = {}
     d.update([(k, v) for k, v in d1.iteritems() if k not in d2])
     d.update([(k, v) for k, v in d2.iteritems() if k not in d1])
     d.update([(k, merge_func(v, d2[k])) for k, v in d1.iteritems() if k in d2])
     return d
  
  
 def dmerge3(d1, d2, merge_func=None):
     """
        Un mélange du code original et de mon premier essai.
     """
     d = {}
  
     d.update(d1)
  
     if merge_func is None:
         d.update(d2)
         return d
  
     for k, v in d2.iteritems():
         if k in d:
             d[k] = merge_func(d[k], v)
         else:
             d[k] = v
  
     return d
  
  
  
 def dmerge4(d1, d2, merge_func=None):
     """
         Le code original, en virant la lambda
     """
     d = {}
  
     if merge_func is None:
         d.update(d1)
         d.update(d2)
         return d
  
     d.update([(k, v) for k, v in d1.iteritems() if k not in d2])
     d.update([(k, v) for k, v in d2.iteritems() if k not in d1])
     d.update([(k, merge_func(v, d2[k])) for k, v in d1.iteritems() if k in d2])
     return d
  
  
 if __name__ == "__main__":
  
     import random
     import timeit
  
     print('Generate test dicts')
  
     # pour que le test soit juste, il faut créer plusieurs types de dicos:
     # des longs, et des courts avec plein de collisions ou moins
     d1 = {random.randint(0, 100): 'd1' for x in xrange(10000)}
     d2 = {random.randint(0, 100): 'd2' for x in xrange(10000)}
     d3 = {random.randint(0, 10000000): 'd1' for x in xrange(1000000)}
     d4 = {random.randint(0, 10000000): 'd2' for x in xrange(1000000)}
  
     merge_to_list = lambda a, b: [a, b]
  
     # ensuite il faut s'assurer que toutes ces fonctions retournent bien
     # la même chose

     print("Testing returns value all match")
  
     assert (dmerge1(d1, d2) == dmerge2(d1, d2)
             == dmerge3(d1, d2) == dmerge4(d1, d2))
     assert (dmerge1(d1, d2, merge_to_list) == dmerge2(d1, d2, merge_to_list)
            == dmerge3(d1, d2, merge_to_list) == dmerge4(d1, d2, merge_to_list))
  
     assert (dmerge1(d3, d4) == dmerge2(d3, d4)
             == dmerge3(d3, d4) == dmerge4(d3, d4))
     assert (dmerge1(d3, d4, merge_to_list) == dmerge2(d3, d4, merge_to_list)
             == dmerge3(d3, d4, merge_to_list) == dmerge4(d3, d4, merge_to_list))
  
     assert (dmerge1(d1, d4) == dmerge2(d1, d4)
             == dmerge3(d1, d4) == dmerge4(d1, d4))
     assert (dmerge1(d1, d4, merge_to_list) == dmerge2(d1, d4, merge_to_list)
             == dmerge3(d1, d4, merge_to_list) == dmerge4(d1, d4, merge_to_list))
  
  
     # enfin on lance l'évaluation du temps d'éxécution avec timeit()

     print("Start timing")
  

     # ce code est exécuté une fois par appel de timeit
     # notez l'astuce 'from __main__ import x' qui importe du code
     # du fichier en cours, ce qui sert rarement
     setup = '''from __main__ import (dmerge1, dmerge2, dmerge3, dmerge4,
                                      d1, d2, d3, d4, merge_to_list)'''
  
  

     # ensuite on fait des appels à timeit : 
     # - le premier paramètre est le code à mesurer: il faut qu'il 
     #   soit le plus simple et court possible
     # - le second et le code d'initialisation avant le test (hors mesure)
     # - le 3e est le nombre de fois que le code va être appelé. 


     # on va tester chaque fonction pour chaque type de dico, une fois
     # avec l'approche par défaut, et une fois avec une fonction de merge
     # personnalisée
     print "Lots of collisions"
  
     print "Default merge strategy"
     print "1", timeit.timeit("dmerge1(d1, d2)", setup=setup, number=1000000)
     print "2", timeit.timeit("dmerge2(d1, d2)", setup=setup, number=1000000)
     print "3", timeit.timeit("dmerge3(d1, d2)", setup=setup, number=1000000)
     print "4", timeit.timeit("dmerge4(d1, d2)", setup=setup, number=1000000)
  
     print "Custom merge strategy"
     print "1", timeit.timeit("dmerge1(d1, d2, merge_to_list)",
                               setup=setup, number=100000)
     print "2", timeit.timeit("dmerge2(d1, d2, merge_to_list)",
                               setup=setup, number=100000)
     print "3", timeit.timeit("dmerge3(d1, d2, merge_to_list)",
                               setup=setup, number=100000)
     print "4", timeit.timeit("dmerge4(d1, d2, merge_to_list)",
                               setup=setup, number=100000)
  

    # le nombre de répétitions est bien plus faible ici car sinon le test
    # est très très long

     print "Long dictionaries"
  
     print "Default merge strategy"
     print "1", timeit.timeit("dmerge1(d3, d4)", setup=setup, number=100)
     print "2", timeit.timeit("dmerge2(d3, d4)", setup=setup, number=100)
     print "3", timeit.timeit("dmerge3(d3, d4)", setup=setup, number=100)
     print "4", timeit.timeit("dmerge4(d3, d4)", setup=setup, number=100)
  
     print "Custom merge strategy"
     print "1", timeit.timeit("dmerge1(d3, d4, merge_to_list)",
                               setup=setup, number=100)
     print "2", timeit.timeit("dmerge2(d3, d4, merge_to_list)",
                               setup=setup, number=100)
     print "3", timeit.timeit("dmerge3(d3, d4, merge_to_list)",
                               setup=setup, number=100)
     print "4", timeit.timeit("dmerge4(d3, d4, merge_to_list)",
                               setup=setup, number=100)
  
     print "Mixed dictionaries"
  
     print "Default merge strategy"
     print "1", timeit.timeit("dmerge1(d1, d4)", setup=setup, number=100)
     print "2", timeit.timeit("dmerge2(d1, d4)", setup=setup, number=100)
     print "3", timeit.timeit("dmerge3(d1, d4)", setup=setup, number=100)
     print "4", timeit.timeit("dmerge4(d1, d4)", setup=setup, number=100)
  
     print "Custom merge strategy"
     print "1", timeit.timeit("dmerge1(d1, d4, merge_to_list)",
                              setup=setup, number=100)
     print "2", timeit.timeit("dmerge2(d1, d4, merge_to_list)",
                              setup=setup, number=100)
     print "3", timeit.timeit("dmerge3(d1, d4, merge_to_list)",
                              setup=setup, number=100)
     print "4", timeit.timeit("dmerge4(d1, d4, merge_to_list)",
                              setup=setup, number=100)
  

# Et voici le résultat que ça nous ressort. On voit clairement 
# que la 3eme fonction donne les meilleurs perfs, du coup
# c'est celle qu'on a choisit
  
 ## Generate test dicts
 ## Testing returns value all match
 ## Start timing
 ## Lots of collisions
 ## Default merge strategy
 ## 1 19.9299340248
 ## 2 148.185166121
 ## 3 21.2276539803
 ## 4 21.2074358463
 ## Custom merge strategy
 ## 1 30.646312952
 ## 2 18.522135973
 ## 3 14.0125968456
 ## 4 18.5139119625
 ## Long dictionaries
 ## Default merge strategy
 ## 1 84.4819910526
 ## 2 383.444111109
 ## 3 80.7273669243
 ## 4 86.0287930965
 ## Custom merge strategy
 ## 1 294.41114521
 ## 2 377.38009119
 ## 3 154.505481005
 ## 4 256.771039963
 ## Mixed dictionaries
 ## Default merge strategy
 ## 1 19.9574320316
 ## 2 87.1410660744
 ## 3 19.3570361137
 ## 4 19.524998188
 ## Custom merge strategy
 ## 1 60.6157000065
 ## 2 86.3876900673
 ## 3 59.0331327915
 ## 4 87.0504939556
 ## [Finished in 2494.7s]
 </pre>
<p> Le test complet a pris en tout 2494.7s, soit 41 minutes, pour tourner sur ma machine, et je l&#8217;ai lancé plusieurs fois avec différentes modifs au fil de la journée. Il faut vraiment est un geek pour aimer faire ce genre de connerie. Parce que soyons honnête, tout le monde s&#8217;en branle des perfs de cette fonction :-)</p>
<p> Il faut savoir aussi qu&#8217;après coup j&#8217;ai réalisé que son code utilisait des listes en intention, et non des <a href="http://sametmax.com/python-love-les-listes-en-intention-partie-2/">expressions génératrices</a>, ce qui fait qu&#8217;il faut attendre que toute la liste soit générée avec que <code>update()</code> fasse son travail.</p>
<p> Il y avait donc des cas supplémentaires à tester et j&#8217;avais mergé son code dans batbelt. Arf, l&#8217;optimisation n&#8217;a jamais de fin ^^</p>
<p> Bref, j&#8217;ai relancé un test avec avec des listes en intentions (et même avec des expressions ternaires ce qui donne des trucs capilotractés):</p>
<pre lang="python">
def dmerge1(d1, d2, merge_func=None):
    """
        Une version de l'ancien dmerge3 qui utilise une expression génératrice.
    """
    d = {}

    d.update(d1)

    if merge_func is None:
        d.update(d2)
        return d

    d.update((k, (v if k not in d else merge_func(d[k], v))) for k, v in d2.iteritems())

    return d



def dmerge2(d1, d2, merge_func=lambda v1, v2: v2):
    """
        La version du proposée par notre gentil contributeur, mais
        avec des expressions génératrices à la place des listes en 
        intention.
    """
    d = {}
    d.update((k, v) for k, v in d1.iteritems() if k not in d2)
    d.update((k, v) for k, v in d2.iteritems() if k not in d1)
    d.update((k, merge_func(v, d2[k])) for k, v in d1.iteritems() if k in d2)
    return d



def dmerge3(d1, d2, merge_func=None):
    """
      La version la plus rapide du test précédent.
    """
    d = {}

    d.update(d1)

    if merge_func is None:
        d.update(d2)
        return d

    for k, v in d2.iteritems():
        if k in d:
            d[k] = merge_func(d[k], v)
        else:
            d[k] = v

    return d


def dmerge4(d1, d2, merge_func=None):
    """
        La version proposée par notre contributeur, optimisée comme un connard.
    """
    d = {}

    if merge_func is None:
        d.update(d1)
        d.update(d2)
        return d

    d.update((k, v) for k, v in d1.iteritems() if k not in d2)
    d.update((k, v) for k, v in d2.iteritems() if k not in d1)
    d.update((k, merge_func(v, d2[k])) for k, v in d1.iteritems() if k in d2)
    return d


## Generate test dicts
## Testing returns value all match
## Start timing
## Lots of collisions
## Default merge strategy
## 1 12.2690660954
## 2 97.121183157
## 3 12.1084120274
## 4 12.6807589531
## Custom merge strategy
## 1 8.73903894424
## 2 12.0493769646
## 3 8.00074601173
## 4 11.4764301777
## Long dictionaries
## Default merge strategy
## 1 54.5233860016
## 2 218.695598841
## 3 70.213809967
## 4 61.8348701
## Custom merge strategy
## 1 103.258821964
## 2 217.720175982
## 3 96.5204670429
## 4 214.480421066
## Mixed dictionaries
## Default merge strategy
## 1 19.169850111
## 2 66.9599928856
## 3 19.4371211529
## 4 19.5183057785
## Custom merge strategy
## 1 64.7940750122
## 2 66.9712991714
## 3 58.5918440819
## 4 67.5281140804
## [Finished in 1619.3s]
</pre>
<p>La bonne nouvelle pour moi, c&#8217;est que l&#8217;algo 3 est toujours le plus rapide, j&#8217;ai pas à re pusher.</p>
<p>Mais il est intéressant de constater que globalement les 4 tests mettent 1619.3s à s’exécuter. Globalement utiliser des expressions génératrices boost bien les perfs.</p>
<hr />
<p><a href="https://github.com/sametmax/codes-des-articles/blob/master/2013/juin/perf.py">Télécharger le code de l&#8217;article.</a></p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/mesurer-les-performances-dun-snippet-python/feed/</wfw:commentRss>
		<slash:comments>6</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">6369</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2013/06/rmhtBR7.jpg" length="92496" type="image/jpg" />	</item>
		<item>
		<title>Être alerté par Git quand un fichier a été modifié durant le dernier merge</title>
		<link>http://sametmax.com/etre-alerte-par-git-quand-un-fichier-a-ete-modifie-durant-le-dernier-merge/</link>
		<comments>http://sametmax.com/etre-alerte-par-git-quand-un-fichier-a-ete-modifie-durant-le-dernier-merge/#comments</comments>
		<pubDate>Mon, 28 Jan 2013 12:25:50 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Administration System]]></category>
		<category><![CDATA[Programmation]]></category>
		<category><![CDATA[git]]></category>
		<category><![CDATA[hook]]></category>
		<category><![CDATA[merge]]></category>
		<category><![CDATA[pull]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=4303</guid>
		<description><![CDATA[Il y a certains fichiers comme les migrations ou les fichiers de settings dont vous avez besoin de connaître l'état. Si un collègue les modifies et les push, vous voulez le savoir au moment du pull. Bien sûr vous pouvez scruter la liste des modifs à ce moment là, mais n'est-ce pas tellement mieux si votre ordinateur fait ça pour vous et affiche une grosse alerte rouge ?]]></description>
				<content:encoded><![CDATA[<p>Il y a certains fichiers comme les migrations ou les fichiers de settings dont vous avez besoin de connaître l&#8217;état. Si un collègue les modifie et les push, vous voulez le savoir au moment du pull. Bien sûr vous pouvez scruter la liste des modifs à ce moment là, mais n&#8217;est-ce pas tellement mieux si votre ordinateur fait ça pour vous et affiche une grosse alerte rouge ?</p>
<p>Mettez le code suivant du le fichier <em>.git/hooks/post-merge</em> de votre repo en local :</p>
<pre lang="bash">#!/bin/bash

# On met ici tous les fichiers (ou pattern de nom) qu'on veut surveiller
# changez les pour les adapter à votre projet
files=('settings.py' 'migrations');

# on récupère tous les noms de fichiers modifiés depuis le dernier merge
modified_files=`git diff "HEAD@{1}" --name-only`

# on boucle sur chaque nom de fichier surveillé
for watched_file in "${files[@]}"; do

    # on liste tous les fichiers modifiés qui correspondent à ce nom de
    # fichier surveillé
    modified_watched_files=(`echo "$modified_files" | grep $watched_file`)

    # si le nombre de fichiers correspondant est plus grand que 0
    if [ ${#modified_watched_files[@]} ]; then

        # pour chaque fichier qui correspond, on affiche un avertissement
        # en rouge
        for modified_watched_file in "${modified_watched_files[@]}"; do

            echo -e "\e[41m "$modified_watched_file" has changed \033[0m"

        done


    fi

done</pre>
<p>Le hook post-merge est exécute après git pull (et seulement si il n&#8217;y a pas eu de conflit). Il va afficher une bonne grosse alerte en rouge pour chaque fichier surveillé qui a été modifié entre avant et après le pull.</p>
<p>Notez au passage la syntaxe intuitive de bash pour utiliser des tableaux. On dirait presque que le mec qui a codé bash était un pote du gars qui a codé git.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/etre-alerte-par-git-quand-un-fichier-a-ete-modifie-durant-le-dernier-merge/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">4303</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2013/01/redalert_01.jpg" length="584070" type="image/jpg" />	</item>
		<item>
		<title>Accepter tous les fichiers de l&#8217;autre ou garder les siens lors d&#8217;un merge Git</title>
		<link>http://sametmax.com/accepter-tous-les-fichiers-de-lautre-ou-garder-les-siens-lors-dun-merge-git/</link>
		<comments>http://sametmax.com/accepter-tous-les-fichiers-de-lautre-ou-garder-les-siens-lors-dun-merge-git/#comments</comments>
		<pubDate>Mon, 20 Aug 2012 22:50:25 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Administration System]]></category>
		<category><![CDATA[git]]></category>
		<category><![CDATA[merge]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=1801</guid>
		<description><![CDATA[Parfois le merge peut être très simple. Vous avez fait de la merde et vous voulez oublier tout votre travail, et prendre celui de l'autre. Ou l'inverse.]]></description>
				<content:encoded><![CDATA[<p>Parfois le merge peut être très simple. Vous avez fait de la merde et vous voulez oublier tout votre travail, et prendre celui de l&#8217;autre. Ou l&#8217;inverse.</p>
<p>Après <code>git pull</code>:</p>
<pre lang="python">git checkout --theirs .</pre>
<p>Pour garder toutes les modifs des autres.</p>
<p>OU</p>
<pre lang="python">git checkout --ours .</pre>
<p>Pour garder les siennes.</p>
<p>On peut remplacer <code>.</code> (le point) par un chemin de fichier pour être plus selectif.</p>
<p>Ces commandes vont juste mettre les fichiers voulus dans la copie de travail. Pour terminer le merge, il faut faire évidement un petit <code>add</code> et un <code>commit</code>.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/accepter-tous-les-fichiers-de-lautre-ou-garder-les-siens-lors-dun-merge-git/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">1801</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2012/08/Troc1.png" length="417893" type="image/jpg" />	</item>
		<item>
		<title>Une astuce pour ne plus avoir peur des merges avec Git</title>
		<link>http://sametmax.com/une-astuce-pour-ne-plus-avoir-peur-des-merges-avec-git/</link>
		<comments>http://sametmax.com/une-astuce-pour-ne-plus-avoir-peur-des-merges-avec-git/#comments</comments>
		<pubDate>Mon, 16 Jul 2012 16:05:13 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[git]]></category>
		<category><![CDATA[merge]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=1147</guid>
		<description><![CDATA[La goutte de sueur au bord de la tempe, on se lance dans le <code>Git merge</code>. Les dents se serrent. Les fesses aussi. Est-ce que je vais tout pêter ?]]></description>
				<content:encoded><![CDATA[<p>Pendant longtemps, Max et moi on a joué à celui qui push le premier pour que l&#8217;autre se tape le merge. Parfois on est pas en forme, le terrain est trop lourd, les sangliers ont mangé des cochoneries&#8230; Bref, on perd la course, et la goutte de sueur au bord de la tempe, on se lance dans le <code>Git merge</code>.</p>
<p>Les dents se serrent. Les fesses aussi. Est-ce que je vais tout pêter ?</p>
<h2>Bonne nouvelle, Git ne perd rien</h2>
<p>Quand on ne connait pas <a href="http://sametmax.com/premiers-pas-avec-git/">Git</a>, on a peur de perdre son travail parcequ&#8217;on assimile le fait qu&#8217;on ne peut plus trouver son travail avec sa destruction. En fait, Git ne supprime rien (du moins, si aucune référence ne pointe sur les données &#8211; ce qui n&#8217;arrive jamais pour votre histo &#8211; vous avez 2 bonnes semaines devant vous).</p>
<p>Donc, si vos données sont commitées (les fichiers modifiés non commités ne comptent pas, évidement), ils sont quelques part dans les méandre du répository.</p>
<p>On peut utiliser cela à son avantage</p>
<h2><code>Git branch</code>, le point de sauvegarde avant d&#8217;attaquer le boss final</h2>
<p>Quand vous avez un truc tendu à faire (genre un merge de mamouth), la stratégie du débutant est de faire un gros copier/coller du repo. Et si ça merde, on supprime, et renomme, et hop, c&#8217;est tout neuf.</p>
<p>Ca marche (on l&#8217;a tous fait), mais c&#8217;est un peu con.</p>
<p>Il existe une stragétie beaucoup plus maline: simplement créer une branche</p>
<ol>
<li>Assurez-vous que votre copie de travail est propre (<a href="http://sametmax.com/soyez-relax-faites-vous-un-petit-git-stash/">git stash</a> au besoin). Vous devez avoir le message: &#8220;<em>nothing to commit (working directory clean)</em>&#8220;.</li>
<li><code>git branch point_de_sauvegarde</code></li>
<li><code>git merge mamouth</code></li>
</ol>
<p>Le 1 est très important, si vous êtes débutant et que vous l&#8217;oubliez, vous êtes dead. Il faudrait faire une option dans git qui interdit un merge sur une copie de travail en cours de modification sous peine de choc électrique par le clavier (ou juste automatiquement, mais c&#8217;est moins fun).</p>
<p>Si le merge a marché: bingo, on peut supprimer la sauvegarde avec <code>git branch -d point_de_sauvegarde</code> et commiter le merge <code>git commit -m "Je l'ai faiiiiiiiiiiit"</code>.</p>
<p>Sinon, on revient au point de sauvegarde: <code>git reset --hard point_de_sauvegarde</code> puis <code>git branch -d point_de_sauvegarde</code></p>
<p>Et voilà, comme si rien ne s&#8217;était passé !</p>
<h2>Heu, ok c&#8217;est magique, mais ça marche comment ?</h2>
<p>Ca marche d&#8217;abord en agissant prudement, et en ne faisant pas de merge sur une copie de travail en cours de modification. C&#8217;est la moitié du boulot.</p>
<p>Ensuite, on créé une nouvelle branche. Une branche n&#8217;est qu&#8217;un pointeur, ce n&#8217;est rien d&#8217;autre qu&#8217;un panneau disant &#8220;ici c&#8217;est &#8216;point de sauvegarde'&#8221;. Ce n&#8217;est pas un bras d&#8217;un arbre comme dans SVN. <strong>C&#8217;est une putain d&#8217;étiquette toute simple</strong>.</p>
<p>Donc en créant une branche, on met juste une étiquette sur le commit que l&#8217;on veut garder. Les commits de l&#8217;historique de Git sont INALTERABLES. Même avec un rebase, contrairement à la croyance populaire, on ne peut pas les supprimer. Le seul moyen de supprimer un commit est de le laisser sans aucun accès (sans étiquette ni parent avec étiquette) pendant 2 semaines ou de forcer le nettoyage avec <code>git gc</code>. </p>
<p>En clair, vous ne pouvez pas perdre un commit. Votre collègue ne peut pas vous niquer un commit par accident. La seule chose à faire si vous tenez à un commit, c&#8217;est de mettre un moyen pour le retrouver facilement. Ici, on lui met une étiquette.</p>
<p>Puis finalement, si ça marche, on supprime l&#8217;étiquette.</p>
<p>Si ça ne marche pas, on demande un hard reset depuis le point de sauvegarde. Un hard reset remet à plat votre copie de travail (les fichiers du disque), et l&#8217;index.</p>
<p>Cela marche pour une seule raison: <code>git merge</code> ne commit pas.</p>
<p>Si le merge est un fast forward, Git va juste se déplacer d&#8217;une case en avant. Si le merge est plus complexe, il va vous demander de commiter. </p>
<p>Dans le cas un, reset vous fait juste reculer d&#8217;une case. Dans le cas deux, tant que vous ne commitez pas, le hard reset annule tout ce qui a été fait, et le nouveau commit n&#8217;est jamais créé.</p>
<h2>En résumé, avant de faire un truc qui vous fait peur avec git</h2>
<ul>
<li>Verifiez que la copie de travail est propre.</li>
<li><code>git branch point_de_sauvegarde</code>.</li>
<li>Si ça marche, <code>git commit</code> (parfois inutile, mais ça ne coûte rien).</li>
<li>Si ça marche pas, <code>git reset --hard point_de_sauvegarde</code>.</li>
</ul>
<h2>L&#8217;astuce pour les levels 99</h2>
<p>Une fois que vous êtes à l&#8217;aise avec cette idée, vous réaliserez qu&#8217;en fait le point de sauvegarde n&#8217;est pas du tout obligatoire. Puisque votre merge est accessible, tous ses parents le sont. Avec <code>git log</code>, vous pouvez retrouver l&#8217;ID du parent et faire la même chose:</p>
<p><code>git reset --hard 1234abcd</code></p>
<p>Avec 1234abcd comme id du parent :-) </p>
<p>Si ça ne vous parles pas, restez avec le point de sauvegarde, c&#8217;est une bonne technique.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/une-astuce-pour-ne-plus-avoir-peur-des-merges-avec-git/feed/</wfw:commentRss>
		<slash:comments>7</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">1147</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2012/07/p.jpg" length="7004" type="image/jpg" />	</item>
	</channel>
</rss>
