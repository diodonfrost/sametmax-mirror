<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" >

<channel>
	<title>import &#8211; Sam &amp; Max</title>
	<atom:link href="http://sametmax.com/tag/import/feed/" rel="self" type="application/rss+xml" />
	<link>http://sametmax.com</link>
	<description>Du code, du cul</description>
	<lastBuildDate>Thu, 05 Sep 2019 08:22:03 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.7</generator>
<site xmlns="com-wordpress:feed-additions:1">32490438</site>	<item>
		<title>Rendez votre package exécutable avec __main__.py</title>
		<link>http://sametmax.com/rendez-votre-module-executable-avec-__main__-py/</link>
		<comments>http://sametmax.com/rendez-votre-module-executable-avec-__main__-py/#comments</comments>
		<pubDate>Tue, 13 Jan 2015 06:47:42 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[import]]></category>
		<category><![CDATA[module]]></category>
		<category><![CDATA[package]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[__init__]]></category>
		<category><![CDATA[__main__]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=15704</guid>
		<description><![CDATA[Tout le monde connait le fichier <a href="http://sametmax.com/vous-pouvez-mettre-du-code-dans-__init__-py/">__init__.py</a>, mais <code>__main__.py</code> est moins connu.]]></description>
				<content:encoded><![CDATA[<p>Tout le monde connait le fichier <a href="http://sametmax.com/vous-pouvez-mettre-du-code-dans-__init__-py/">__init__.py</a>, mais <code>__main__.py</code> est moins connu.</p>
<p>Il permet de lancer du code si on tente d&#8217;exécuter un package (c&#8217;est à dire un dossier qui contient un fichier <code>__init__.py</code>):</p>
<pre lang="bash">$ tree monpackage/
monpackakge/
├── __init__.py
└── __main__.py

0 directories, 2 files
$ cat monpackage/__main__.py
print('Hello :)')
$ python monpackage/ # ceci est un dossier 
Hello :)</pre>
<p>Le <code>__main__.py</code>  est aussi exécuté quand on fait <code>python -m monpackage</code>. </p>
<p>Notez que son exécution suppose l&#8217;import préalable du package, et que donc <code>__init__.py</code> sera toujours exécuté avant <code>__main__.py</code>. En revanche, faire juste <code>import monpackage</code> ne déclenche pas l&#8217;exécution de <code>__main__.py</code>.</p>
<p>Si vous zippez votre package et appelez la commande <code>python</code>, c&#8217;est aussi ce fichier qui sera exécuté. Pratique donc, pour faire un exécutable portable à peu de frais, tout en gardant la lib importable.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/rendez-votre-module-executable-avec-__main__-py/feed/</wfw:commentRss>
		<slash:comments>5</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">15704</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2015/01/index2.jpeg" length="8794" type="image/jpg" />	</item>
		<item>
		<title>Importer des données, retour d&#8217;expérience</title>
		<link>http://sametmax.com/importer-des-donnees-retour-dexperience/</link>
		<comments>http://sametmax.com/importer-des-donnees-retour-dexperience/#comments</comments>
		<pubDate>Thu, 16 Jan 2014 15:49:21 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[api]]></category>
		<category><![CDATA[data]]></category>
		<category><![CDATA[import]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[xml]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=8772</guid>
		<description><![CDATA[Python est simplement le meilleur langage au monde pour l'import de données. Sa capacité à lire énormément de formats facilement, sa force de manipulation de données numériques et texte, sa philosophie d'itération, ses nombreuses libs en font un outil incroyablement souple et puissant.

Voici mes 2 centimes.]]></description>
				<content:encoded><![CDATA[<p>Dédicaçons la chanson de notre article au plus barbu de mes amis poneys.</p>

<!-- iframe plugin v.4.3 wordpress.org/plugins/iframe/ -->
<iframe width="560" height="315" src="//www.youtube.com/embed/9wrVTYMGTao" frameborder="0" 0="allowfullscreen" scrolling="yes" class="iframe-class"></iframe>

<p>J&#8217;ai importé des données un très grand nombre de fois dans ma vie. Depuis des APIs, des XML, des CSV, du filesystem, des formats binaires, des formats batards, etc</p>
<p>Pour tous les jobs d&#8217;import, Python est probablement le meilleur langage au monde. Autant j&#8217;aime Python, autant je suis lucide sur le fait qu&#8217;en dev Web, Ruby et Javascript sont d&#8217;excellentes alternatives. En programmation concurrente, Go dépasse Python. En IA, Lisp est le top de la concurrence.</p>
<p>Mais pour l&#8217;import de données, Python est simplement le meilleur langage au monde. Sa capacité à lire énormément de formats facilement, sa force de manipulation de données numériques et texte, sa philosophie d&#8217;itération, ses nombreuses libs en font un outil incroyablement souple et puissant.</p>
<p>Malgré cela, on retrouve toujours des grosses difficultés dans l&#8217;import de données. Elles sont les mêmes pour tous les langages.</p>
<p>Voici mes 2 centimes.</p>
<h2>N&#8217;accordez aucune confiance à la donnée</h2>
<p>Partez du principe que tout champ peut manquer. Que toute donnée peut être mal formée ou corrompue. Ou fausse.</p>
<p>Même si le service en face est sérieux. J&#8217;ai bossé avec des données du service de santé américain, de France Télécom, de startups, d&#8217;outils Open Source, de scrapping de sites, de mon pote Maurice, et de mes propres scripts</p>
<p>Vous savez ce qu&#8217;ils ont tous en commun ? Aucun ne sont fiables. Aucun.</p>
<p>Ils ont tous des données merdiques à un moment où à un autre.</p>
<p>Ayez donc une approche défensive. Pour CHAQUE champ, posez vous la question : que doit faire le script d&#8217;import si il manque ? Si la donnée contenue est foireuse ?</p>
<h2>Les outils d&#8217;abstraction sont vos amis</h2>
<p>Un import, c&#8217;est typiquement le genre de taff où les surcouches vont énormément vous aider. ORM, DSL, XML objectify et toute lib qui peut vous éviter de travailler trop proche du format va vous faire gagner un temps fou.</p>
<p>Prenez un peu de temps pour les mettre en place. Même si ils vous font perdre un peu en perf, un gros script d&#8217;import devient TRÈS VITE un sac de nœud. Et vous voulez que les problèmes soient facilement identifiables.</p>
<p>Pour cette même raison, virez toute la logique de l&#8217;insertion des données en dehors du script. Votre script doit avoir une logique découpée en 3 parties :</p>
<ol>
<li>Le script d’acquisition, qui charge les données et les passe sous forme brute à un importeur.</li>
<li>Un importeur, qui est capable d&#8217;extraire des données raffinées à partir d&#8217;un format de données brutes et appeler le bon code d&#8217;insertion.</li>
<li>Du code d&#8217;insertion, qui attend en paramètre une donnée toujours propre (sans aucun check), et qui se charge uniquement de prendre cette donnée et la mettre dans votre système de stockage (généralement la base de données).</li>
</ol>
<p>Le script d’acquisition doit rester très simple. Une suite d&#8217;instructions logiques pour récupérer la donnée, l&#8217;énumérer et la passer à l&#8217;importeur. C&#8217;est lui qui fait les appels API, qui se connecte au FTP, qui ouvre le CSV, qui parse le XML, etc. Ainsi vous pouvez facilement interchanger les importeurs ou voir si il y a une couille dans la récupération des données.</p>
<p>L&#8217;importeur est généralement le code le plus crade. C&#8217;est une série de <code>try</code> / <code>except</code>, de logique métier, d&#8217;assainissement des données. Vous ne voulez pas de code d&#8217;insertion là dedans, car vous voulez que ce code, qui est difficile à débugger et va être celui qui va être modifié toutes les 5 minutes au fur et à mesure que vous découvrez toute les merdes, soit dédié à une seule logique : obtenir de la donnée saine. Ce code sera spaghetti, vous n&#8217;y pouvez rien. Mais vous pouvez l&#8217;isoler et le commenter à mort.</p>
<p>Le code d&#8217;insertion est un code réutilisable. Il se fout de savoir d&#8217;où vient la donnée. Il attend un format, et un seul, et toujours de données correctes, et propres. C&#8217;est le but des importeurs de lui filer une entrée normalisée et pertinente. Ce code est propre, et doit être très bien testé via des tests unittaires. Il va vous servir plusieurs fois, car c&#8217;est le même code qui sera utilisé que vous importiez d&#8217;un service X ou un service Y. Il représente VOTRE logique métier. N&#8217;insérez pas ce code dans le code d&#8217;une autre abstraction (type ORM), ainsi, si vous changez d&#8217;outils, vous changez simplement ce code, et l&#8217;interface reste la même pour vos importeurs.</p>
<h2>Debugging</h2>
<p>Votre script va planter. Beaucoup. Souvent.</p>
<p>Un champ absolument indispensable &#8211; que la spec papier notait comme toujours présent &#8211; va manquer. Un autre champ noté de type int dans le xld contient une lettre. L&#8217;encoding n&#8217;est pas le bon, alors qu&#8217;il l&#8217;a toujours été pendant 5 mois.</p>
<p>Ce n&#8217;est pas une question de si, c&#8217;est une question de quand.</p>
<p>Donc déjà, blindez votre script de <a href="http://sametmax.com/ecrire-des-logs-en-python/">log</a>. Quand je dis blindez, je veux dire que chaque <code>if</code>, chaque résultat de check, doit être accompagné d&#8217;une ligne affichant l&#8217;action en cours, et son contexte (la donnée traitée, de préférence avec un truc pour l&#8217;identifier, genre un ID). Quand il plantera à 3 heure du matin sur un truc hubuesque et que le relancer pour obtenir le même état prendra une demi-journée, le log sera votre seul chance de réparer la panne sans engager un psy.</p>
<p>Mettez aussi un gros <code>try / except</code> générique qui loggue toute exception, pour pouvoir faire un debug post mortem. Idéalement, faites le dumper <code>locals()</code> et envoyez-vous un mail d&#8217;alerte. Vous ne voulez pas que le script ne tourne pas pendant une journée sans que vous le sachiez.</p>
<p>Mettez des options dans votre scripts pour pouvoir débugger plus facilement. Par exemple, si vous avez de code d&#8217;insertion qui est sous forme de tâche asynchrone (type <a href="http://sametmax.com/files-de-taches-et-taches-recurrentes-avec-celery/">celery</a>), mettez une option <code>--synchronous</code> qui insère le code inline afin de pouvoir utiliser <a href="http://sametmax.com/debugger-en-python-les-bases-de-pdb/">pdb</a> sur tout le script en cas de besoin. Ou alors, si vous avez une grosse archive à décompresser, mettez une option <code>--nozip</code> pour pouvoir sauter cette étape.</p>
<p>Et si vous insérez un break point, mettez le dans une condition du genre :</p>
<pre lang="python">if id_du_champ_ou_autre_moyen_identifiant == "valeur":
    send_mail('Alerte, on est peut être au bug. Bouge ton fion.')
    import ipdb; ipdp.set_trace()</pre>
<p>Comme ça vous pouvez retourner à vos moutons le temps que le breakpoint s&#8217;active, ce qui, sur des gros jeux de données, peut prendre énormément de temps.</p>
<p>Enfin, je sais qu&#8217;on a tendance à être fainéant et vouloir toujours débugger en direct. Mais faites des mocks. Faites un faux XML, une API bidon, bref, un truc qui vous permet d&#8217;insérer des cas d&#8217;import avec une données dans le format attendu, et testez votre code avec ça. Pour les petits imports, c&#8217;est une perte de temps, mais pour les gros imports, ça va vous faire gagner des jours. Ainsi vous pouvez tester des cas isolé, rajouter des bugs rencontrés, etc. Et en plus ça sert de documentation.</p>
<h2>Problèmes courants</h2>
<p>Il y a mille et une manière d&#8217;avoir un import qui plante, mais il y a généralement 6 grosses foirades qu&#8217;on retrouve tout le temps.</p>
<h3>Service défaillant</h3>
<p>Le service (FTP, API, humain en face, NAS, etc) qui doit vous fournir les données est indisponible. Vous n&#8217;y pouvez rien. Envoyez-vous un SMS pour vous prévenir, aujourd&#8217;hui <a href="http://www.twilio.com/">c&#8217;est facile et ça coûte presque rien</a>. Ainsi vous pourrez dialoguer rapidement avec les personnes responsables de problème.</p>
<h3>Champs manquants</h3>
<p>Grand classique. Tout champ peut manquer. Tout. Même un ID unique sans lequel la donnée n&#8217;a aucune sens. Faites vous un wrapper du genre :</p>
<pre lang="python">def get_data(champ):
    try:
        # extraire le champ
    except ChampAbsent, ChampMalFormé:
        return None</pre>
<p>Et utilisez le partout. Et décidez ce que doit faire votre programme si il rencontre <code>None</code>. Pour TOUS les champs. Si <code>None</code> est une valeur possible, utilisez <code>Ellipsis</code>. Si <code>Ellipsis</code> est une valeur possible, faites vous une classe <code>InvalidData</code>.</p>
<h3>Mauvais encoding</h3>
<p>Super vicieux. Je vous renvoie à <a href="http://sametmax.com/lencoding-en-python-une-bonne-fois-pour-toute/">l&#8217;article sur l&#8217;encoding</a> pour cela.</p>
<h3>Donnée aberrante</h3>
<p>Impossible à prévoir, très difficile à identifier. Donnée de mauvais type, date ou nombre hors limites, texte dans la mauvaise langue, etc. Vous ne pouvez pas tout prévoir. Pour ça, il faudra faire au fur et à mesure des plantages.</p>
<h3>Données mal formatée et malicieuses</h3>
<p>En plus de <code>get_data</code>, il vous faut un <code>clean_data</code>. Qui check si on peut processer la donnée sereinement. Pour tous les champs également. C&#8217;est con, mais si LEUR système n&#8217;escape pas les entrées utilisateurs, c&#8217;est VOTRE système dans lequel se retrouve les injections de code.</p>
<h2>Performances</h2>
<p>La vitesse de votre script sera généralement limitée par 3 facteurs :</p>
<ul>
<li>Vitesse de lecture.</li>
<li>Vitesse d&#8217;écriture.</li>
<li>Vos plantages.</li>
</ul>
<p>Ces 3 facteurs sont en général très liés.</p>
<p>La meilleur stratégie, c&#8217;est d&#8217;extrapoler un max de données, et de cacher tout ce qui est cacheable. Par exemple, copiez les données brutes sur vos serveurs (genre si c&#8217;est un fichier sur le leur). Copiez les références externes, même si vous n&#8217;en avez pas besoin afin d&#8217;éviter une query de plus, vous les supprimerez plus tard. Pré-calculez les champs, par exemple age, si vous avez la date de naissance, etc.</p>
<p>Si vous avez beaucoup de checks à faire pour l&#8217;assainissement des données, mettez vos données en cache (par exemple dans redis), pour que les looks up soient rapides, ou au moins, ajoutez les index qui vont bien dans la DB (on peut avoir des perfs X10 rien qu&#8217;avec ça).</p>
<p>Ensuite, partez du principe que ça va planter souvent, donc :</p>
<ul>
<li>Faites des opérations <a href="https://fr.wikipedia.org/wiki/Idempotent">idempotentes</a>, c&#8217;est à dire qu&#8217;on peut les relancer autant de fois qu&#8217;on veut sans risque. Typiquement, vérifiez si une donnée existe avant l&#8217;insertion, et si oui, faites une mise à jour complète.</li>
<li>Mettez un historique. Sauvegardez quelque part l&#8217;avancement de votre import, afin de ne pas tout recommencer depuis le début après le plantage.</li>
</ul>
<p>Ah oui, et faites des copies de sauvegarde des données brutes ET des données importées. Pour les premières, parce qu&#8217;on est pas à l&#8217;abri un &#8220;rm -fr&#8221; malencontreux. Ne rigolez pas, ça m&#8217;est arrivé la semaine dernière. Une semaine à tout DL à nouveau. Pour les secondes, parce que tant que le dernier import n&#8217;est pas terminé, on peut toujours corrompre toute sa base avec une couille de dernière minute. Comme un encoding qui change aléatoirement sur une donnée non datée.</p>
<h2>Bon sens</h2>
<p>Évidement, je parle ici d&#8217;un synthèse des problématiques rencontrées. Vous ne pouvez pas appliquer TOUT ça, ou en tout cas, pas au début, ou pas sur des petits scripts, etc. Selon le sérieux de votre source de données, il faudra plus ou moins être défensif. L&#8217;expérience et la douleur vous permettra de trouver la juste dose de morphine.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/importer-des-donnees-retour-dexperience/feed/</wfw:commentRss>
		<slash:comments>13</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">8772</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2014/01/tumblr_mzej9jOaCN1r539hzo1_500.jpg" length="218579" type="image/jpg" />	</item>
		<item>
		<title>Pourquoi il faut éviter import * en Python</title>
		<link>http://sametmax.com/pourquoi-il-faut-eviter-import-en-python/</link>
		<comments>http://sametmax.com/pourquoi-il-faut-eviter-import-en-python/#comments</comments>
		<pubDate>Mon, 25 Nov 2013 07:00:41 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[import]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[splat]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=8082</guid>
		<description><![CDATA[Vous l'avez sans doute lu 100 fois, mais savez-vous pourquoi ?]]></description>
				<content:encoded><![CDATA[<p>Ne pas utiliser l&#8217;<a href="http://sametmax.com/operateur-splat-ou-etoile-en-python/">opérateur splat</a> dans un import, vous l&#8217;avez sans doute lu 100 fois, mais savez-vous pourquoi ?</p>
<p>Regardez la fonction <code>open</code> :</p>
<pre lang="python">>>> help(open)
    open(name[, mode[, buffering]]) -> file object
    
    Open a file using the file() type, returns a file object.  This is the
    preferred way to open a file.  See file.__doc__ for further information.
(END)</pre>
<p>Maintenant, si j&#8217;importe le module <code>os</code>, ça ne change rien :</p>
<pre lang="python">>>> import os
>>> help(open)
    open(name[, mode[, buffering]]) -> file object
    
    Open a file using the file() type, returns a file object.  This is the
    preferred way to open a file.  See file.__doc__ for further information.
(END)</pre>
<p>Si par contre j&#8217;importe tout le contenu du module <code>os</code>, sans namespace :</p>
<pre lang="python">>>> from os import *
>>> help(open)
    open(filename, flag [, mode=0777]) -> fd
    
    Open a file (for low level IO).
(END)</pre>
<p>La différence ?</p>
<p>Dans le premier cas, on a la fonction <code>open()</code> built-in de Python. Dans le second cas, la fonction <code>os.open()</code> a été importée et a remplacé la fonction <code>open()</code>.</p>
<p>Ici le bug sera très difficile à trouver, car les deux fonctions ont presque la même signature :</p>
<p><code>open(name[, mode[, buffering]]) -> file object</code></p>
<p>VS </p>
<p><code>open(filename, flag [, mode=0777]) -> fd</code></p>
<p>Et en plus un usage très similaire.</p>
<p>Bottom line, <code>import *</code>, c&#8217;est pour les sessions shell. Dans vos fichiers de code, ne l&#8217;utilisez pas, vous ne savez pas ce que vous importez.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/pourquoi-il-faut-eviter-import-en-python/feed/</wfw:commentRss>
		<slash:comments>11</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">8082</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2013/11/pyclusion.jpg" length="72541" type="image/jpg" />	</item>
		<item>
		<title>Vous pouvez mettre du code dans __init__.py</title>
		<link>http://sametmax.com/vous-pouvez-mettre-du-code-dans-__init__-py/</link>
		<comments>http://sametmax.com/vous-pouvez-mettre-du-code-dans-__init__-py/#comments</comments>
		<pubDate>Wed, 26 Jun 2013 11:20:04 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[import]]></category>
		<category><![CDATA[init]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[__init__]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=3472</guid>
		<description><![CDATA[Le fichier <em>__init__.py</em> ne sert pas qu'à <a href="http://sametmax.com/les-imports-en-python/">déclarer un dossier comme un package importable</a>. C'est aussi le code exécuté automatiquement, une seule fois, quand on importe le module.]]></description>
				<content:encoded><![CDATA[<p>Le fichier <em>__init__.py</em> ne sert pas qu&#8217;à <a href="http://sametmax.com/les-imports-en-python/">déclarer un dossier comme un package importable</a>. C&#8217;est aussi le code exécuté automatiquement, une seule fois, quand on importe le module.</p>
<p>Du coup vous pouvez mettre dedans tout code Python que vous souhaitez lancer à l&#8217;import. On y voit souvent :</p>
<ul>
<li>Initialisation du cache.</li>
<li>Constantes comme <code>__version__</code>.</li>
<li>Import d&#8217;autres modules pour les mettre dans l&#8217;espace de nom courant.</li>
<li>Check de dépendances.</li>
<li>Aliasing.</li>
<li>Monkey patching and hacks tout moches qui sont là temporairement pour 6 ans.</li>
</ul>
<p>Je vous déconseille de mettre trop de code dans le fichier <em>__init__.py</em>, notamment du code métier. C&#8217;est une mauvaise habitude que l&#8217;on peut voir dans le code de Django par exemple. Car ça veut dire que l&#8217;import du package déclenche ce code, qui lui-même importe d&#8217;autres modules, qui déclenche d&#8217;autres codes, etc. Cela donne des effets de bord à l&#8217;import, alors que l&#8217;import d&#8217;un simple package est quelque chose que l&#8217;on veut généralement ne pas avoir beaucoup d&#8217;effets.</p>
<p>Dans Django par exemple, c&#8217;est ce qui fait que beaucoup de modules lèvent une exception à l&#8217;import :</p>
<p><code>django.core.exceptions.ImproperlyConfigured: Requested setting X but settings are not configured. </code></p>
<p>Alors qu&#8217;ils n&#8217;ont pas du tout besoin des settings pour fonctionner.</p>
<p>Si vous avez besoin que votre classe <code>Bidule</code> soit directement importable dans votre package <code>machin</code>, faites dans <em>machin/__init__.py</em> :</p>
<pre lang="python">from .module_qui_contient_bidule import Bidule</pre>
<p>Du coup vous pourrez faire n&#8217;importe où ailleurs:</p>
<pre lang="python">from machin import Bidule</pre>
<p>C&#8217;est bien plus propre que de mettre tout le code de <code>Bidule</code> dans le <em>__init__.py</em>.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/vous-pouvez-mettre-du-code-dans-__init__-py/feed/</wfw:commentRss>
		<slash:comments>12</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">3472</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2013/06/UHM9zrZ.jpg" length="59179" type="image/jpg" />	</item>
		<item>
		<title>Les imports en Python</title>
		<link>http://sametmax.com/les-imports-en-python/</link>
		<comments>http://sametmax.com/les-imports-en-python/#comments</comments>
		<pubDate>Thu, 16 May 2013 09:13:27 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[import]]></category>
		<category><![CDATA[module]]></category>
		<category><![CDATA[package]]></category>
		<category><![CDATA[python]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=6127</guid>
		<description><![CDATA[Un jour vous avez du écrire votre propre module. Vous n'aviez pas vraiment réfléchi à la question. C'était juste une petite lib pour regrouper des fonctions. Ou juste une app Django. Un truc tout simple. Mais les imports ont soudainement cessé de devenir clairs. Ça ne marchait pas. Rien ne marchait. Vous aviez des <code>sys.path.append</code> partout juste au cas où et c'était encore pire.

Vous avez donc décidé de vous remettre à PHP, au moins le <code>include</code> utilise les chemins de fichiers, et ça, c'est facile.]]></description>
				<content:encoded><![CDATA[<p>Je suis fan de carmina burrana depuis l&#8217;age de 12 ans, alors pourquoi pas O Fortuna comme musique d&#8217;ambiance :</p>
<p><iframe class='youtube-player' type='text/html' width='1170' height='689' src='http://www.youtube.com/embed/nIwrgAnx6Q8?version=3&#038;rel=1&#038;fs=1&#038;autohide=2&#038;showsearch=0&#038;showinfo=1&#038;iv_load_policy=1&#038;wmode=transparent' allowfullscreen='true' style='border:0;'></iframe></p>
<p>Les imports, c&#8217;était fastoche. Vous étiez dans votre petit programme, et pour importer un module de la lib standard, vous faisiez:</p>
<pre lang="python">import module
</pre>
<p>Par exemple :</p>
<pre lang="python">import os</pre>
<p>Et pour importer une classe ou une fonction de cette lib, vous faisiez :</p>
<pre lang="python">from module import fonction
from module import Classe</pre>
<p>Par exemple :</p>
<pre lang="python">from hashlib import md5
from xml.etree import Element</pre>
<p>Parfois, c&#8217;était un peu plus compliqué, mais ça allait encore. Des fois il fallait importer un sous-module :</p>
<pre lang="python">from package.sous_package import module</pre>
<p>Par exemple :</p>
<pre lang="python">from xml.sax import saxutils</pre>
<p>Mais ça allait encore.</p>
<p>Et puis un jour vous avez du écrire votre propre module. Vous n&#8217;aviez pas vraiment réfléchi à la question. C&#8217;était juste une petite lib pour regrouper des fonctions. Ou juste une app Django. Un truc tout simple. Mais les imports ont soudainement cessé de devenir clairs. Ça ne marchait pas. Rien ne marchait. Vous aviez des <code>sys.path.append</code> partout juste au cas où et c&#8217;était encore pire.</p>
<p>Vous avez donc décidé de vous remettre à PHP, au moins le <code>include</code> utilise les chemins de fichiers, et ça, c&#8217;est facile.</p>
<h2>Sous le capot</h2>
<p>Quand vous utilisez <code>import</code>, sous le capot Python utilise le fonction <code>__import__</code>. Malgré ses <code>__</code> dans le nom, c&#8217;est une fonction ordinaire, et vous pouvez d&#8217;ailleurs l&#8217;utiliser vous-même :</p>
<pre lang="python">>>> os = __import__('os')
>>> os.path.join('s', 'ton', 'mon', 'g')
u's/ton/mon/g'</pre>
<p>En fait, importer un module, c&#8217;est créer un objet module qui est assigné à une variable tout à fait normale :</p>
<pre lang="python">>>> type(os)
<type 'module'>
>>> os = "on peut ecraser un module"
>>> os.path
Traceback (most recent call last):
  File "<ipython-input-12-e34748f24345>", line 1, in <module>
    os.path
AttributeError: 'unicode' object has no attribute 'path'

>>> import sys
>>> type(sys)
<type 'module'>
>>> sys = "je t'ecrase la tronche"
>>> type(sys)
<type 'unicode'></pre>
<p>Le mécanisme de module Python n&#8217;est donc pas un truc à part, c&#8217;est un objet comme le reste, qui contient des attributs. Les attributs sont les variables et les fonctions du module.</p>
<p>Pour charger un module, la fonction <code>__import__</code> passe par les étapes suivantes :</p>
<ol>
<li>Chercher si le module <code>os</code> existe.</li>
<li>Chercher si le module a déjà été importé. Si oui, s&#8217;arrêter ici et renvoyer le module existant.</li>
<li>Si non, chercher si il a été déjà compilé en .pyc.</li>
<li>Si ce n&#8217;est pas le cas, compiler le fichier .py en .pyc.</li>
<li>Charger le bytecode du fichier pyc.</li>
<li>Créer un objet module vide.</li>
<li>Éxecuter le bytecode dans le contexte de l&#8217;objet module et remplir ce dernier avec le résultat.</li>
<li>Ajouter l&#8217;objet module dans <code>sys.modules</code>, un dictionnaire qui contient tous les modules déjà chargés.</li>
<li>Retourner le module pour pouvoir l&#8217;assigner à une variable, par défaut la variable porte son nom.</li>
</ol>
<p>La fonction <code>__import__</code> est donc très complexe, et d&#8217;ailleurs si vous voulez l&#8217;utiliser pour des trucs plus compliqués qu&#8217;un simple import de module, vous allez galérer car sa signature est vraiment zarb.</p>
<p>Mais pour vous, seule l&#8217;étape 1 est importante à comprendre. C&#8217;est l&#8217;étape à laquelle tout se joue.</p>
<h2>Comment Python définit quel module importer ?</h2>
<p>C&#8217;est la partie vraiment difficile, en effet si un import ne marche pas, c&#8217;est très souvent parce que Python ne trouve pas le module que vous voulez. Et la raison pour laquelle il ne le trouve pas, c&#8217;est que vous ne comprenez pas comment il cherche.</p>
<p>Python utilise ce qu&#8217;on appelle le PYTHON PATH pour chercher les modules importables. C&#8217;est une variable système qui contient une liste de dossiers. Par exemple, sur ma machine, elle contient ceci :</p>
<pre lang="python">['',
 '/usr/bin',
 '/usr/local/lib/python2.7/dist-packages/grin-1.2.1-py2.7.egg',
 '/usr/lib/python2.7',
 '/usr/lib/python2.7/plat-linux2',
 '/usr/lib/python2.7/lib-tk',
 '/usr/lib/python2.7/lib-old',
 '/usr/lib/python2.7/lib-dynload',
 '/home/sam/.local/lib/python2.7/site-packages',
 '/usr/local/lib/python2.7/dist-packages',
 '/usr/local/lib/python2.7/dist-packages/setuptools-0.6c11-py2.7.egg-info',
 '/usr/lib/python2.7/dist-packages',
 '/usr/lib/python2.7/dist-packages/PIL',
 '/usr/lib/python2.7/dist-packages/gst-0.10',
 '/usr/lib/python2.7/dist-packages/gtk-2.0',
 '/usr/lib/pymodules/python2.7',
 '/usr/lib/python2.7/dist-packages/ubuntu-sso-client',
 '/usr/lib/python2.7/dist-packages/ubuntuone-client',
 '/usr/lib/python2.7/dist-packages/ubuntuone-control-panel',
 '/usr/lib/python2.7/dist-packages/ubuntuone-couch',
 '/usr/lib/python2.7/dist-packages/ubuntuone-installer',
 '/usr/lib/python2.7/dist-packages/ubuntuone-storage-protocol',
 '/usr/lib/python2.7/dist-packages/wx-2.6-gtk2-unicode',
 '/usr/lib/python2.7/dist-packages/IPython/extensions']</pre>
<p> Donc, quand vous faites <code>import os</code>, Python va faire une boucle <code>for</code> là dessus et chercher dans chaque dossier si un package (un dossier avec un fichier <code>__init__.py</code>) ou un module (un fichier avec l&#8217;extension <em>.py</em>) nommé <code>os</code> existe.</p>
<p> Dès qu&#8217;il en trouve un, il s&#8217;arrête de chercher et l&#8217;importe. Si il n&#8217;en trouve pas, il va lever une <code>ImportError</code>.</p>
<p> Ce qui signifie que si votre module n&#8217;est PAS dans le PYTHON PATH, vous ne pouvez PAS l&#8217;importer. C&#8217;est impossible.</p>
<p> La grande majorité des problèmes d&#8217;import vient du fait que le module que vous essayez d&#8217;importer n&#8217;est pas dans le PYTHON PATH.</p>
<p> Maintenant, la grande question, c&#8217;est :</p>
<h2>Qu&#8217;est-ce qui est dans le PYTHON PATH ?</h2>
<p>Par défault, les dossiers <em>sites-packages</em> et <em>dist-packages</em> dans le dossier d&#8217;installation Python sont dans le PYTHON PATH. Quelques autres sont ajoutés selon les systèmes, mais vous pouvez toujours compter sur <em>sites-packages</em> et <em>dist-packages</em> pour être dans le PYTHON PATH. Quand vous installez une lib, par exemple avec <a href="http://sametmax.com/votre-python-aime-les-pip/">pip</a>, c&#8217;est là dedans que la lib va s&#8217;installer, pour être sûre de pouvoir être importée.</p>
<p>Quand vous êtes dans un <a href="http://sametmax.com/les-environnement-virtuels-python-virtualenv-et-virtualenvwrapper/">virtualenv</a>, les dossiers <em>sites-packages</em> et <em>dist-packages</em> de l&#8217;environnement virtuel sont ajoutés au PYTHON PATH.</p>
<p>Mais tout ça ne change pas grand chose pour vous. En effet, vous n&#8217;allez pas mettre VOTRE code dans les dossiers <em>sites-packages</em> et <em>dist-packages</em>.</p>
<p>C&#8217;est pour cela que Python possède un mécanisme supplémentaire : le dossier qui contient le module sur lequel vous lancez la commande <code>python</code> est automatiquement ajouté au PYTHON PATH.</p>
<h2>Le PYTHON PATH, en pratique</h2>
<p>Supposons que je sois dans le dossier <em>/home/sam/Bureau</em> et que j&#8217;aie dedans ce package. Voici à quoi ressemble mon arbo (<a href="https://github.com/sametmax/codes-des-articles/blob/master/2013/mai/test_imports.zip">téléchargez l&#8217;arbo vierge</a> pour vos tests):</p>
<pre><strong>/home/sam/Bureau # <-- je suis ici</strong>
.
`-- test_imports
    |-- __init__.py
    |-- package_tout_en_haut
    |   |-- __init__.py
    |   |-- autre_sous_package
    |   |   |-- __init__.py
    |   |   `-- autre_module_en_bas.py
    |   |-- sous_module.py
    |   `-- sous_package
    |       |-- __init__.py
    |       |-- autre_module_en_bas.py
    |       |-- autre_sous_package
    |       |   |-- __init__.py
    |       |   `-- autre_module_en_bas.py
    |       `-- module_tout_en_bas.py
    `-- top_module.py</pre>
<p>Si je lance un shell Python depuis ce dossier ou un script Python contenu dans ce dossier, je peux faire <code>import test_imports</code>, car <em>/home/sam/Bureau</em> est automatiquement ajouté au PYTHON PATH.</p>
<p>Je peux donc faire :</p>
<pre lang="python">>>> import test_imports
>>> from test_imports import package_tout_en_haut
>>> from test_imports import top_module
test_imports.top_module
>>> from test_imports.package_tout_en_haut import sous_module
test_imports.package_tout_en_haut.sous_module
</pre>
<p>Mais si je me mets ici dans <em>./package_tout_en_haut/sous_package</em> :</p>
<pre>/home/sam/Bureau
.
`-- test_imports
    |-- __init__.py
    |-- package_tout_en_haut
    |   |-- __init__.py
    |   |-- autre_sous_package
    |   |   |-- __init__.py
    |   |   `-- autre_module_en_bas.py
    |   |-- sous_module.py
    |   `-- <strong>sous_package     # <-- je suis ici</strong>
    |       |-- __init__.py
    |       |-- autre_module_en_bas.py
    |       |-- autre_sous_package
    |       |   |-- __init__.py
    |       |   `-- autre_module_en_bas.py
    |       |-- module_tout_en_bas.py
    `-- top_module.py</pre>
<p>Je ne peux PAS importer <code>test_imports</code>, ni dans un shell, ni depuis un module de ce dossier :</p>
<pre lang="python">>>> import test_imports
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ImportError: No module named test_imports</pre>
<p>En effet, comme je lance la commande Python depuis</p>
<p> <em>./package_tout_en_haut/sous_package</em></p>
<p> alors</p>
<p> <em>./package_tout_en_haut/sous_package</em> </p>
<p> <strong>EST</strong> ajouté au PYTHON PATH, mais </p>
<p> <em>/home/sam/Bureau/</em> </p>
<p> n&#8217;est <strong>PAS</strong> ajouté au PYTHON PATH.</p>
<p>Je ne peux donc PAS faire </p>
<pre lang="python">from test_imports import top_module </pre>
<p>depuis un fichier comme </p>
<p><em>.test_imports/package_tout_en_haut/sous_package/autre_module_en_bas.py</em> </p>
<p>et exécuter directement </p>
<pre lang="python">python autre_module_en_bas.py</pre>
<p>ni même </p>
<pre lang="python">python ./test_imports/package_tout_en_haut/sous_package/autre_module_en_bas.py</pre>
<p>Je peux faire </p>
<pre lang="python">from test_imports import top_module</pre>
<p>depuis </p>
<p><em>autre_module_en_bas.py</em> </p>
<p>uniquement si je lance un script Python tout en haut de mon arbo qui importe </p>
<p><em>autre_module_en_bas.py</em>.</p>
<h2>Mais alors, comment on fait ?<br />
</h2>
<p>Il faut s&#8217;assurer que le dossier qui contient <code>test_imports</code>, notre module racine, soit TOUJOURS dans le PYTHON PATH.</p>
<p>Il y a plusieurs possibilités pour cela.</p>
<p>La première, c&#8217;est que notre lib va être utilisée une fois installée avec pip. Dans ce cas, on s&#8217;en branle, <code>test_imports</code> sera dans sites-packages automatiquement, et on pourra faire <code>from test_imports import top_module </code> de partout joyeusement.</p>
<p>Mais souvent, ce n&#8217;est pas le cas, votre code n&#8217;est pas fait pour être installé.</p>
<p>La seconde technique consiste à s&#8217;assurer que l&#8217;on appelle TOUJOURS la commande Python depuis le dossier qui est tout au dessus. C&#8217;est ce que fait django avec sa commande <code>./manage.py</code> par exemple.</p>
<p>Vous avez votre projet :</p>
<pre>./manage.py
projet</pre>
<p>Et tout passe par <code>python manage.py</code>, qui est au dessus de projet, donc le dossier est bien ajouté au PYTHON PATH, et tout va bien.</p>
<p>Dans votre cas ça veut dire vous assurer qu&#8217;on lance toujours votre programme depuis un script d&#8217;entrée qui est tout en haut de votre arborescence.</p>
<p>Ca veut dire que vous devez avoir un point d&#8217;entrée UNIQUE pour votre package.</p>
<p>Mais parfois ça ne convient pas. Dans le cas des tests unitaires par exemple, il vous faut un point d&#8217;entrée spécialement pour les tests.</p>
<p>Pour ce genre de scénario, il faut donc avoir le dossier qui les contient <strong>à côté</strong> de votre package.  Ainsi, si j&#8217;avais des tests unitaires, je devrais faire un dossier <em>tests</em> à côté du dossier <em>test_imports</em>. Par exemple, transformer mon arbo en un truc comme ça :</p>
<pre>src
   |_ test_imports
   |_ tests
</pre>
<p>Afin que je lance les tests en faisant <code>python tests</code> depuis <em>src</em>. Et dans mes fichiers de tests, je pourrai faire des <code>from test_imports import truc</code>.</p>
<p>La manière dont vous organisez votre projet est donc très importante en Python, et si vous avez des problèmes d&#8217;import, la première chose à faire est de changer sa structure. Il n&#8217;y a pas de magie.</p>
<p>La dernière possibilité, quand tout a échoué, c&#8217;est de rajouter à la main le dossier dans le PYTHON PATH. <code>sys.path</code> est une simple liste, on peut donc faire un <code>append()</code> dessus.</p>
<p>Par exemple, si je veux absolument (mais je ne devrais pas :-)) pouvoir faire :</p>
<p><code>python .test_imports/package_tout_en_haut/sous_package/autre_module_en_bas.py</code> et importer <code>test_imports</code> dans <em>autre_module_en_bas.py</em>, je peux faire un truc du genre :</p>
<pre lang="python">import os

dossier = os.path.dirname(os.path.abspath(__file__))

while not dossier.endswith('test_imports'):
    dossier = os.path.dirname(dossier)

dossier = os.path.dirname(dossier)

if dossier not in sys.path:
    sys.path.append(dossier)</pre>
<p>Ce code va remonter dans l&#8217;arbo jusqu&#8217;à tomber sur le chemin du dossier <em>test_imports</em> et ajouter son dossier parent au PYTHON PATH.</p>
<p>Ce n&#8217;est pas le truc le plus propre du monde, mais ça peut dépanner.</p>
<h2>Imports absolus et relatifs</h2>
<p>Si vous êtes dans <em>./package_tout_en_haut/sous_package</em> :</p>
<pre>/home/sam/Bureau
.
`-- test_imports
    |-- __init__.py
    |-- package_tout_en_haut
    |   |-- __init__.py
    |   |-- autre_sous_package
    |   |   |-- __init__.py
    |   |   `-- autre_module_en_bas.py
    |   |-- sous_module.py
    |   `-- <strong>sous_package     # <-- je suis ici</strong>
    |       |-- __init__.py
    |       |-- autre_module_en_bas.py
    |       |-- autre_sous_package
    |       |   |-- __init__.py
    |       |   `-- autre_module_en_bas.py
    |       |-- module_tout_en_bas.py
    |       `-- test_imports  # <-- autre package nommé test_imports
    |           `-- sous_module.py
    `-- top_module.py</pre>
<p>Vous voyez que vous avez deux packages nommés <em>test_imports</em>.</p>
<p>Si vous écrivez <code>import test_imports</code> dans <em>autre_module_en_bas.py</em>, que va-t-il se passer ?</p>
<p>C'est le module tout en bas qui va être importé.</p>
<p>Ce n'est pas forcément ce que vous voulez. Python 3 corrige cela en permettant des imports relatifs, et Python 2.7 peut en bénéficier en important tout en haut du module :</p>
<pre lang="python">from __future__ import absolute_import</pre>
<p>En faisant cela, vous obtenez le comportement de Python 3 dans Python 2.7, et vous pourrez alors choisir entre faire :</p>
<pre lang="python">import test_imports # importe le module tout en haut
from . import test_imports # import le module dans le même dossier
from .test_imports import sous_module
from test_imports import top_module</pre>
<p>Je vous recommande de toujours utiliser <em>from __future__ import absolute_import</em>. Ca ne coûte rien, et c'est plus cohérent. Par contre, vous ne pourrez pas tester <em>from __future__ import absolute_import</em> dans le shell, donc cet exemple ne marche pas dans ipython, mais il fonctionne parfaitement dans vos modules.</p>
<p>On peut aussi faire des imports relatifs du package contenant avec :</p>
<pre lang="python">from .. import truc
from ..package import machin</pre>
<p>N'oubliez pas que ceci ne marche que :</p>
<ul>
<li>Si <code>from __future__ import absolute_import</code> est activé.</li>
<li>Le package tout en haut (celui qui contient tous les autres) est dans le PYTHON PATH</li>
</ul>
<p>Sinon, ça ne sert A RIEN. Ce n'est pas comme un <em>../</em> dans un bash. Ça ne remonte pas d'un dossier. C'est juste une notation pour dire j'utilise celui la plutôt que l'autre, quand il y a ambiguité.</p>
<h2>Pièges des imports</h2>
<h3>Package sans init</h3>
<p>Si vous avez :</p>
<pre>.
`-- test_imports
    |-- __init__.py
    |-- package_sans_init
    |   `-- nada.py</pre>
<p><em>nada.py</em> n'est pas importable, car <em>package_sans_init</em> ne contient pas de fichier <em>__init__.py</em>, même si <em>test_imports</em> est dans le PYTHON PATH. Ce comportement est corrigé en Python 3, et tout sous-dossier d'un package importable est automatiquement importable, qu'il contienne un <em>__init__.py</em> ou non.</p>
<h3>Imports circulaires</h3>
<p>J'en ai déjà parlé <a href="http://sametmax.com/quelques-erreurs-tordues-et-leurs-solutions-en-python/">ici</a>.</p>
<p>Vous avez :</p>
<pre>.
`-- test_imports
    |-- __init__.py
    |-- package_tout_en_haut
    |   |-- __init__.py
    |   `-- sous_package
    |       |-- __init__.py
    |       |-- autre_module_en_bas.py
    |       `-- module_tout_en_bas.py</pre>
<p>Et vous importez <code>autre_module_en_bas</code> dans <code>module_tout_en_bas</code> et inversement. Non seulement ça ne marchera pas, mais en plus l'erreur est déroutante :</p>
<pre lang="python">ImportError: No module named module_tout_en_bas</pre>
<p>Oui vous avez bien lu, il va vous dire que le module n'existe pas !</p>
<p>Il n'y a pas non plus de solution propre à ce problème : soit vous fusionnez vos deux fichiers, soit vous faites un 3eme module qui utilise ces deux modules (et ces deux modules n'importent pas ce 3eme module).</p>
<p>Sinon il y a la solution crade : mettre un des imports dans un appel de fonction ou de méthode comme ça:</p>
<pre lang="python">def truc():
    import module_tout_en_bas
    module_tout_en_bas.bidule()</pre>
<p>Parfois, ça dépanne :-) On ne tue pas des chatons non plus, donc si ça ne devient pas une habitude, ça peut passer.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/les-imports-en-python/feed/</wfw:commentRss>
		<slash:comments>37</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">6127</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2013/05/tumblr_mj4zt7GH891r539hzo1_500.jpg" length="77621" type="image/jpg" />	</item>
		<item>
		<title>Include / require / import en javascript</title>
		<link>http://sametmax.com/include-require-import-en-javascript/</link>
		<comments>http://sametmax.com/include-require-import-en-javascript/#comments</comments>
		<pubDate>Thu, 03 Jan 2013 15:04:33 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[import]]></category>
		<category><![CDATA[include]]></category>
		<category><![CDATA[javascript]]></category>
		<category><![CDATA[require]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=3977</guid>
		<description><![CDATA[On ne peut pas inclure un script dans un script en JS. Il n'y a pas de mot clé <code>import</code>, <code>include</code> ou <code>require</code>.

On peut néanmoins trouve un moyen d'inclure du code en le téléchargeant et en l'incluant dans la page.]]></description>
				<content:encoded><![CDATA[<p>On ne peut pas inclure un script dans un script en JS dans un navigateur Web. Il n&#8217;y a pas de mot clé <code>import</code>, <code>include</code> ou <code>require</code>.</p>
<p>On peut néanmoins trouver un moyen d&#8217;inclure du code en le téléchargeant et en l&#8217;incluant dans la page.</p>
<h2>Solution 1, la bourrine</h2>
<p>On peut faire une requête GET et un <code>eval sur</code>. C&#8217;est dangereux. C&#8217;est bancal. Ca marche que pour le domaine en cours. C&#8217;est pas une bonne idée. Je ne vous le montre donc pas.</p>
<h2>Solution 2, la maline</h2>
<p>On va créer une balise <code>&lt;script&gt;&lt;/script&gt;</code> et la faire pointer sur le fichier à télécharger. Ainsi on utilise le mécanisme naturel pour le navigateur d&#8217;include du code.</p>
<pre lang="javascript">var include = function(url, callback){

    /* on crée une balise<script type="text/javascript"></script> */
    var script = document.createElement('script');
    script.type = 'text/javascript';

    /* On fait pointer la balise sur le script qu'on veut charger
       avec en prime un timestamp pour éviter les problèmes de cache
    */

    script.src = url + '?' + (new Date().getTime());

    /* On dit d'exécuter cette fonction une fois que le script est chargé */
    if (callback) {
        script.onreadystatechange = callback;
        script.onload = script.onreadystatechange;
    }

    /* On rajoute la balise script dans le head, ce qui démarre le téléchargement */
    document.getElementsByTagName('head')[0].appendChild(script);
}</pre>
<p>Ca s&#8217;utilise comme ça:</p>
<pre lang="javascript">include('http://adressedemonscript.com/fichier.js', function() {
    code à exécuter une fois que le script est chargé
})</pre>
<p>La partie <a href="http://sametmax.com/quest-ce-quun-callback/">callback</a> est très importante. En effet, si vous essayez d&#8217;exécuter du code <strong>après</strong> <code>include()</code> qui dépend du code chargé <strong>par</strong> <code>include()</code>, ça va foirer : le code n&#8217;est pas encore téléchargé. En effet, les navigateurs téléchargent les balises scripts en arrière plan et en parallèle :</p>
<pre lang="javascript">include('http://adressedemonscript.com/fichier.js');
code à exécyter une fois que le script est chargé</pre>
<p>Il faut donc mettre ce code dans un callback, pour garantir qu&#8217;il soit lancé quand le script a terminé de chargé.</p>
<h2>Solution 3, la coquine</h2>
<p>jQuery, encore et toujours, possède un raccourcis pour faire tout ça pour vous:</p>
<pre lang="javascript">$('http://adressedemonscript.com/fichier.js', function() {
    code à exécuter une fois que le script est chargé
})</pre>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/include-require-import-en-javascript/feed/</wfw:commentRss>
		<slash:comments>24</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">3977</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2012/12/Car-Carrier-RoRo-TransAtlantic-Import-Service-Maps.gif" length="22360" type="image/jpg" />	</item>
		<item>
		<title>Se faciliter les imports avec les fichiers *.pth</title>
		<link>http://sametmax.com/se-faciliter-les-imports-avec-les-fichiers-pth/</link>
		<comments>http://sametmax.com/se-faciliter-les-imports-avec-les-fichiers-pth/#comments</comments>
		<pubDate>Mon, 10 Sep 2012 16:49:24 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[import]]></category>
		<category><![CDATA[path]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[python path]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=2082</guid>
		<description><![CDATA[Dans un article, nous parlions des extensions alternatives en Python, et notamment de l'usage des fichiers <em>*.pth</em>. Néanmoins cette extension est souvent mal comprise, et voici un comment en profiter au maximum.]]></description>
				<content:encoded><![CDATA[<p>Dans un article, nous parlions des <a href="http://sametmax.com/astuces-python-en-vrac/">extensions alternatives en Python</a>, et notamment de l&#8217;usage des fichiers <em>*.pth</em>. Néanmoins cette extension est souvent mal comprise, et voici un comment en profiter au maximum.</p>
<p>En Python, on a souvent des problèmes d&#8217;import: la lib est dans un dossier au dessous, ou à côté, ou à l&#8217;autre bout du disque dur, et ça plantouille parceque Python ne trouve pas le module.</p>
<p>Il existe plein de moyens de jouer avec le fameux <code>PYTHON_PATH</code> qui contient la liste des dossiers dans lesquelles chercher les libs, et la plupart sont fort verbeuses et répétitives, du genre:</p>
<pre lang="python">import os
import sys

CUR_DIR = os.path.dirname(os.path.realpath(__file__))
sys.path.extend([
    os.path.join(CUR_DIR, 'apps'),
    os.path.join(os.path.dirname(CUR_DIR), 'libs'),
    os.path.join(os.path.realpath('~'), '.local_libs')
]]}</pre>
<p>Une manière simple est d&#8217;utiliser un fichier <em>*.pth</em>: on créé un fichier texte, on le nomme <em>comme-on-veut.pth</em> (moi je me fais pas chier, je le nomme .pth comme ça c&#8217;est court et c&#8217;est caché sous nunux), et on liste tous les dossiers qu&#8217;on veut ajouter au <code>PYTHON_PATH</code>, y compris avec des chemins relatifs.</p>
<p>Oui mais, argh parmi les argh, la première fois qu&#8217;on le fait, ça ne marche pas. Alors on cherche dans la doc, et là, fustration, on apprend que les fichiers <em>*.pth</em> ne sont parsés que dans les sites directories, c&#8217;est à dire les dossiers officiels du système dans lesquels sont censés être les libs de la bibliothèque standard. Donc pas le dossier courant.</p>
<p>Eh oui, ces fichiers ont été conçus pour faciliter les déploiements, du genre quand on fait un setup.py pour son app, pas pour nous, pauvres mortels.</p>
<p>Heureusement il y a une solution Sam et Max à tout, et ici elle consiste à faire:</p>
<pre lang="python">import os
import site

CUR_DIR = os.path.dirname(os.path.realpath(__file__))
site.addsitedir(CUR_DIR)</pre>
<p>Quelque part dans son code n&#8217;importe où qui est sûr d&#8217;être éxécuté tôt, par exemple dans Django, dans le <em>settings.py</em>. Ca ajoute le dossier du projet en tant que site directory, et donc le fichier <em>.pth</em> est parsé. On peut alors dumper son listing dedans sans avoir à le répéter dans tous les scripts et fichiers qui doivent l&#8217;utiliser (et ainsi modifier cette liste facilement).</p>
<p>Attention cependant, celà rajoute votre dossier de projet dans le <code>PYTHON_PATH</code>, rendant tout ce qu&#8217;il contient importable. Normalement, c&#8217;est ce que vous voulez, mais si ce n&#8217;est pas le cas, vous pouvez avoir une gestion plus fine en ajoutant juste le fichier .pth avec <code>site.addpackage(CUR_DIR, 'fichier.pth', set())</code></p>
<h2>La feature de magie noire</h2>
<p>Dans les fichiers <em>*.pth</em>, il y a un support limité de la syntaxe Python: on peut commenter des lignes avec <code>#</code> et faire des <code>import truc</code>. </p>
<p>Sauf que si vous êtes curieux, vous verrez le détail qui tue dans l&#8217;implémentation:</p>
<pre lang="python">if line.startswith(("import ", "import\t")):
    exec line</pre>
<p>On peut donc virtuellement mettre n&#8217;importe quel code Python dans les fichiers <em>*.pth</em>. Par exemple:</p>
<pre lang="python">
../foo
import sys; print "Foo a été ajouté au PYTHON PATH"
</pre>
<p>Va afficher &#8220;Foo a été ajouté au PYTHON PATH&#8221; au démarrage du programme. Amusant. Et tellement de potentiels pour faire des trucs tordus !</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/se-faciliter-les-imports-avec-les-fichiers-pth/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">2082</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2012/09/yoda-vs-hulk.jpg" length="118963" type="image/jpg" />	</item>
		<item>
		<title>Astuces Python en vrac</title>
		<link>http://sametmax.com/astuces-python-en-vrac/</link>
		<comments>http://sametmax.com/astuces-python-en-vrac/#comments</comments>
		<pubDate>Fri, 03 Aug 2012 13:15:35 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[import]]></category>
		<category><![CDATA[iterable]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[slice]]></category>
		<category><![CDATA[yield]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=1463</guid>
		<description><![CDATA[Je n'arrive pas à trouver un lien entre tous ces trucs, alors un bon vrac fera l'affaire.]]></description>
				<content:encoded><![CDATA[<p>Je n&#8217;arrive pas à trouver un lien entre tous ces trucs, alors un bon vrac fera l&#8217;affaire.</p>
<h2>Float accepte de parser l&#8217;infini<br />
</h2>
<pre lang="python">
>>> infini = float('inf')
>>> infini
inf
>>> infini + 1
inf
>>> infini - 1
inf
>>> float('-inf')
-inf
>>> float('-inf') + 1
-inf
>>> float('inf') + float('-inf')
nan
</pre>
<p>Attention, il est très probable que ce soit dépendant de l&#8217;implémentation CPython.</p>
<h2><code>Iter()</code> peut prendre un callable en argument</h2>
<p><code>iter()</code>, c&#8217;est la fonction qui créé un générateur à partir d&#8217;un itérable:</p>
<pre lang="python">>>> generateur = iter([1, 2, 3])
>>> generateur.next()
1
>>> generateur.next()
2
>>> generateur.next()
3
</pre>
<p>Il se trouve qu&#8217;il a aussi une autre forme: <code>iter(callable, sentinel)</code>.</p>
<p>Sous cette forme, il va créer une générateur qui appelle <code>callable</code> jusqu&#8217;à ce que la valeur <code>sentinel</code> apparaisse.</p>
<pre lang="python">
>>> import datetime
>>> datetime.datetime.now().strftime("%S")
'45'
>>> generateur = iter(lambda: datetime.datetime.now().strftime("%S"), "59")
>>> generateur.next()
'56'
>>> generateur.next()
'57'
>>> generateur.next()
'58'
>>> generateur.next()
Traceback (most recent call last):
  File "<ipython-input-45-6c9f9efdd35c>", line 1, in <module>
    generateur.next()
StopIteration</pre>
<h2>Chainer les comparateurs</h2>
<p>Histoire de diminuer le nombre de <code>if</code>:</p>
<pre lang="python">>>> a, b, c, d = 1, 2, 3, 4
>>> a < b < c < d
True
>>> a == 1 > b -2
True</pre>
<h2>Le mot clé <code>else</code>, en dehors de <code>if</code></h2>
<p><code>Else</code> ne s&#8217;applique pas qu&#8217;aux conditions, mais aussi aux exceptions et aux boucles.</p>
<p>Dans une boucle for, la clause <code>else</code> est exécutée à la fin de l&#8217;itération si il n&#8217;y a pas eu de <code>break</code>.</p>
<pre lang="python">>>> import random
>>> lst = [random.randint(1, 5) for x in xrange(5)]
... for x in lst:
...     if x == 5:
...         break
... else:
...     print "5 n'a jamais été trouvé"</pre>
<p>Dans la gestion des exceptions, <code>else</code> est éxécuté si <code>catch</code> n&#8217;est jamais appelé:</p>
<pre lang="python">try:
    open('fichier')
except IOError:
    print "Une IO Error est arrivée"
else:
    print "Tout s'est bien passé"
finally:
    print "Toujours éxécuté"

print "Exécuté si on est rentré dans except ou else"</pre>
<h2>Continuation de lignes avec les parenthèses</h2>
<p><code>\</code> sur les longues lignes, ça va 5 minutes.</p>
<pre lang="python">
from force import (rouge, bleu, jaune, vert, noir, blanc, rose, fushia,
                   vermeille, vers_a_pois_jaune, call)

# ici le multi line édit de sublime text m'a vachement aidé
if (rouge.transformation and bleu.transformation and jaune.transformation
        and vert.transformation and noir.transformation and blanc.transformation
        and rose.transformation and fushia.transformation
        and  vermeille.transformation and vers_a_pois_jaune.transformation):
    print ("C'est bon là je crois qu'on a tout le monde sauf erreur de ma part"
           " dans le comptage... Ah non merde il manque jaune devant marron "
           "derrière")
    call(force='jaune_devant_marron_derriere', message="Ramène ton cul tout"
                                                       "de suite !")</pre>
<h2>Les extensions <code>.pyw</code>, <code>.pyo</code> et <code>.pth</code></h2>
<p>Vous croyiez qu&#8217;il n&#8217;y avait que <code>.py</code> et <code>.pyc</code> dans la vie ? Ah, jeunes padawans&#8230;</p>
<p><code>.pyw</code> est juste un renommage, il permet, sous Windows, de ne pas ouvrir de terminal quand on lance le script (ce qui est préférable quand on a déjà une UI)</p>
<p><code>.pyo</code> est l&#8217;extension générée quand on lance la commande <code>python</code> avec l&#8217;option <code>-o</code> (optimize). Pour le moment il retire juste les <code>assert</code>.</p>
<p><code>.pth</code> est l&#8217;extension qu&#8217;on donne à un simple fichier texte qui contient une liste de chemins de dossiers. Posé à la racine d&#8217;un site directory, il dit à Python de rajouter automatiquement ces dossiers au Python Path, ce qui évite de manipuler <code>sys.path</code>.</p>
<h2>Lever une exception à nouveau</h2>
<p>Il suffit d&#8217;utiliser <code>raise</code> sans paramètre. Pratique quand on ne veut pas interrompre la remontée d&#8217;exception, et insérer un traitement juste avant que l&#8217;exception se déclenche (en opposition à <code>finally</code> qui garanti le traitement, pas le moment de celui-ci.)</p>
<pre lang="python">try:
    open('fichier')
except IOError:
    print "pouet"
    raise</pre>
<h2>Passer une valeur à un générateur</h2>
<p>Vous aimez <a href="http://sametmax.com/comment-utiliser-yield-et-les-generateurs-en-python/">yield</a> ? Vous en abusez ? Sachez qu&#8217;on peut faire plus vicieux encore:</p>
<pre lang="python">def je_te_yield_tu_me_yield(lst):
    for x in lst:
        nouvelle_liste = yield x
        if nouvelle_liste is not None:
            for z in nouvelle_liste:
                print z</pre>
<p>Le truc tordu est qu&#8217;ici <code>yield</code> est dans un assignement. Non seulement il retourne une valeur, mais en plus il en récupère une. <code>send()</code> permet de passer une valeur à <code>yield</code> à son prochain retour (sinon la valeur reçue est toujours <code>None</code>):</p>
<pre lang="python">>>> generateur = je_te_yield_tu_me_yield([1, 2, 3])
>>> generateur.next()
1
>>> generateur.next()
2    
>>> generateur.send(('a', 'b', 'c'))
a
b
c
3</pre>
<h2>On peut inverser les booléens avec 1/0 et vice-versa</h2>
<p>Les booléens ne sont qu&#8217;une surcouche des entiers, et même si:</p>
<pre lang="python">>>> type(1) 
<type 'int'>
>>> type(bool)
<type 'type'></pre>
<p>Dans la pratique:</p>
<pre lang="python">>>> 1 == True
True
>>> 0 == False
True
>>> 2 == True
False</pre>
<p>On peut donc les interchanger:</p>
<pre lang="python">>>> True + 1 # pas sur que ce soit utile
2
>>> lst = ['a', 'b'] # par contre ça c'est cool pour les binary trees
>>> lst[False]
'a'
>>> lst[True]
'b'
>>> fin_de_phrase = True # et ça c'est TRES pratique pour le formating
>>> print "... d'une longue histoire" + ("." * fin_de_phrase)
... d'une longue histoire.
>>> fin_de_phrase = False
>>> print "... d'une longue histoire" + ("." * fin_de_phrase)
... d'une longue histoire</pre>
<h2><code>_</code> contient la dernière sortie sur le shell</h2>
<pre lang="python">>>> _
'b'
>>> 1 + 1
2
>>> _
2
>>> _ + 1
3
>>> a = [1, 2, 3]
[1, 2, 3]
>>> _.append(4)
>>> a
[1, 2, 3, 4]</pre>
<p>Ca ne marche que dans le shell, et uniquement sur ce qui est affiché à l&#8217;écran. Si vous n&#8217;affichez pas la valeur, <code>_</code> ne change pas. Attention à ne pas trop compter sur <code>_</code> car il est très volatile.</p>
<h2><code>Enumerate()</code> accepte un index de départ</h2>
<pre lang="python">>>> for i, elem in enumerate('azerty'):
...     print i, elem
...     
0 a
1 z
2 e
3 r
4 t
5 y
>>> for i, elem in enumerate('azerty', 10):
    print i, elem
...     
10 a
11 z
12 e
13 r
14 t
15 y</pre>
<h2>On peut assigner et supprimer des slices</h2>
<pre lang="python">>>> a = range(10)
>>> a
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> a[:5] = [42]
>>> a
[42, 5, 6, 7, 8, 9]
>>> a[:1] = range(5)
>>> a
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> del a[::2]
>>> a
[1, 3, 5, 7, 9]
>>> a[::2] = a[::-2]
>>> a
[9, 3, 5, 7, 1]</pre>
<h2><code>import braces</code></h2>
<p>Si vous n&#8217;aimez pas les espaces pour l&#8217;indentation, vous pouvez faire:</p>
<pre lang="python">from __future__ import braces</pre>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/astuces-python-en-vrac/feed/</wfw:commentRss>
		<slash:comments>11</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">1463</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2012/08/48672-bureau-dependance-bordel-foutoir-desordre-rangemen.jpg" length="36541" type="image/jpg" />	</item>
		<item>
		<title>Quelques erreurs tordues et leurs solutions en Python</title>
		<link>http://sametmax.com/quelques-erreurs-tordues-et-leurs-solutions-en-python/</link>
		<comments>http://sametmax.com/quelques-erreurs-tordues-et-leurs-solutions-en-python/#comments</comments>
		<pubDate>Sun, 24 Jun 2012 02:29:56 +0000</pubDate>
		<dc:creator><![CDATA[Sam]]></dc:creator>
				<category><![CDATA[Programmation]]></category>
		<category><![CDATA[django]]></category>
		<category><![CDATA[encodage]]></category>
		<category><![CDATA[encoding]]></category>
		<category><![CDATA[erreur]]></category>
		<category><![CDATA[error]]></category>
		<category><![CDATA[generator]]></category>
		<category><![CDATA[import]]></category>
		<category><![CDATA[iterable]]></category>
		<category><![CDATA[python]]></category>

		<guid isPermaLink="false">http://sametmax.com/?p=995</guid>
		<description><![CDATA[Bien que Python soit un langage dont l'une des grandes qualités est la cohérence, voici une liste d'erreurs et leurs solutions qui ont tendance à énerver.
]]></description>
				<content:encoded><![CDATA[<p>Quand vous débuggez, rappelez-vous que <a href="http://sametmax.com/debugger-en-python-les-bases-de-pdb/">pdb est votre ami</a>, et qu&#8217;il est souvent bon de <a href="http://sametmax.com/purger-les-fichiers-pyc-et-un-hook-git-en-bonus/">supprimer tous les fichiers <code>.pyc</code></a> pour éviter la confusion. Mais parfois l&#8217;erreur semble n&#8217;avoir aucun sens. Bien que Python soit un langage dont l&#8217;une des grandes qualités soit la cohérence, voici une liste d&#8217;erreurs et leurs solutions qui ont tendance à énerver (les erreurs hein, pas les solutions).</p>
<h2><code>NameError: name 'x' is not defined</code></h2>
<p>Python plante en annonçant que la variable n&#8217;est pas définie. Vous allez à la ligne donnée, et elle est là. Vous vérifiez qu&#8217;il n&#8217;y a pas de faute de frappe (genre un zéro mélangé avec la lettre O), ni une majuscule ou une minuscule échangée quelque part (Python est sensible à la casse).</p>
<p>Et rien.</p>
<p>Tout est niquel.</p>
<p>Alors pourquoi ça plante bordel de merde ?</p>
<p>Et bien ce message qui n&#8217;aide absolument pas peut venir du fait que <a href="http://sametmax.com/closure-en-python-et-javascript/">les closures sont en lecture seule en Python</a>. En résumé, vous avez essayé de faire un truc comme ça:</p>
<pre lang="python">chose = 'truc'
def fonction():
    chose = 'machin'
    # ou chose += machin ou une variante</pre>
<p>La solution est simple: ne modifiez pas <code>chose</code>. Si vous avez besoin de modifier son contenu, utilisez une variable intermédiaire:</p>
<pre lang="python">chose = 'truc'
def fonction():
    bidule = chose
    bidule += 'machin' # je sais c'est bidon, c'est pour l'exemple</pre>
<p>En Python 3.0, vous pouvez utiliser le mot clé <code>nonlocal</code> pour y palier: vous modifierez alors la variable du scope du dessus. </p>
<pre lang="python">chose = 'truc'
def fonction():
    nonlocal chose
    chose += 'machin' # je sais c'est bidon, c'est pour l'exemple</pre>
<p>Évitez d&#8217;utiliser <code>global</code>, qui a un fort potentiel d&#8217;effet de bord.</p>
<h2><code>ImportError: cannot import name bidule</code> et <code>ImportError: No module named truc</code></h2>
<p>Une fois que vous avez vérifié qu&#8217;un module existe bien avec ce nom (regardez de près, parfois c&#8217;est subtile), voici 3 possibilités:</p>
<h3>Pas de fichier __init__.py</h3>
<p>Un dossier n&#8217;est pas un module importable si il ne contient pas de fichier <code>__init__.py</code>. Vérifiez qu&#8217;il y en a un, et dans le cas contraire, créez en un vide.</p>
<p><H3>Erreur de Python Path</H3></p>
<p>Quand vous faites <code>import bidule</code>, <code>bidule</code> ne peut être importé que si le dossier qui le contient est dans le <strong>Python Path</strong>. Le Python Path est une variable qui contient une liste de dossiers dans lesquels chercher les modules à importer.</p>
<p>Le dossier courrant, le dossier contenant la bibliothèque standard de Python et le dossier où sont installés les bibliotèques Python de votre système d&#8217;exploitation sont automatiquement présents dans le Python Path.</p>
<p>Première chose: assurez-vous d&#8217;être à la racine du projet que vous lancez (erreur typique quand on utilise la commande <code>./manage.py</code> avec Django par exemple).</p>
<p>Deuxième chose: si vous utilisez une bibliothèque qui n&#8217;est pas dans le Python Path (ça arrive assez souvent avec les tests unitaires: on éxécute les tests depuis le dossier de test, et le projet est dans un dossier à côté, donc pas dans le Python Path), vous pouvez ajouter manuellement un chemin dans le Python Path.</p>
<p>Pour se faire, avant l&#8217;import qui va foirer:</p>
<pre lang="python">import sys
sys.path.append('/chemin/vers/le/dossier/parent/du/module/a/importer')</pre>
<p>On peut tout à fait spécifier un dossier relativement au dossier courant. Il n&#8217;est pas rare d&#8217;ajouter le dossier parent du dossier courrant au Python Path:</p>
<pre lang="python">import sys
import os

DOSSIER_COURRANT = os.path.dirname(os.path.abspath(__file__))
DOSSIER_PARENT = os.path.dirname(DOSSIER_COURRANT)
sys.path.append(DOSSIER_PARENT)
</pre>
<p>Par exemple, souvent dans le dossier d&#8217;un projet Django je fais un sous-dossier &#8216;apps&#8217;, puis je rajoute ceci au fichier <code>settings.py</code>:</p>
<pre lang="python">import sys
import os

PROJECT_DIR = os.path.dirname(os.path.abspath(__file__))
sys.path.append(os.path.join(PROJECT_DIR, 'apps'))</pre>
<p>Il y a deux avantages à cela:</p>
<ul>
<li>Mes applications sont regroupées dans un dossier et pas en vrac à la racine du projet, mais je peux quand même les importer en faisant <code>import nom</code> et pas <code>import apps.nom</code>.</li>
<li> J&#8217;ai maintenant une variable <code>PROJECT_DIR</code> que je peux utiliser partout, notamment pour définir où sont certains dossiers comme le dossiers des fichiers statiques:</li>
</ul>
<pre lang="python">STATIC = os.path.join(PROJECT_DIR, 'static')</pre>
<h3>Imports circulaires</h3>
<p>Si vous importez <code>poisson.rouge</code> dans <code>force.py</code>, et <code>force.bleu</code> dans <code>poisson.py</code>, vous aurez aussi ce message d&#8217;erreur (qui n&#8217;aide pas beaucoup, on est d&#8217;accord).</p>
<p>Il n&#8217;y a pas vraiment de façon élégante de s&#8217;en sortir, c&#8217;est une des plus grosses couillasses en Python.</p>
<p>Solution 1: vous refactorez votre code pour avoir <code>bleu</code> et <code>rouge</code> dans un fichier <code>couleur.py</code>, lequel est importé dans <code>poisson.py</code> et <code>force.py</code>. C&#8217;est propre, mais parfois ça n&#8217;a aucun sens, et parfois ce n&#8217;est juste pas possible.<br />
Solution 2: vous mettez l&#8217;import dans une fonctions ou une méthode dans un des deux modules (n&#8217;importe lequel):</p>
<pre lang="python">def make_bouillabaisse():
    from poisson import rouge</pre>
<p>C&#8217;est moche, mais c&#8217;est facile. Et je le répète, je n&#8217;ai jamais vu quelqu&#8217;un en 10 ans de Python proposer une solution élégante à ce problème. C&#8217;est un What The Fuck d&#8217;or.</p>
<h2><code>UnicodeDecodeError: 'ascii' codec can't decode byte 0xc3 in position 0: ordinal not in range(128)</code></h2>
<p>Arf. L&#8217;erreur à la con. Parce que généralement elle vient du fait que l&#8217;on ne comprend pas vraiment ce qu&#8217;on fait. Or difficile de résoudre un problème quand on ne comprend pas de quoi il est question. Ne vous sentez pas mal, on s&#8217;est tous retrouvé comme un demeuré devant un problème d&#8217;encodage.</p>
<p>A noter que ce n&#8217;est pas une erreur spécifique à Python, mais si vous venez d&#8217;un langage comme PHP qui passe silencieusement ce genre d&#8217;erreur et affiche en prod des texts illisibles, voire une grosse erreur à l&#8217;écran peut surprendre.</p>
<p>Voici des causes très fréquentes:</p>
<h3>Encodage du fichier.py</h3>
<p>Comme il peut y avoir 1 million de possibilités, forcez vous à:</p>
<p>&#8211; TOUJOURS avoir votre éditeur de texte réglé pour utiliser UTF-8. Surtout sur Windows. Si votre chef vous l&#8217;interdit parce que &#8220;ça pose des problèmes d&#8217;encodage&#8221; (sic), quittez votre job (meilleur choix) ou faites vous former pour comprendre comment marchent les encodages et travailler dans cet environnement hostile.<br />
&#8211; TOUJOURS avoir votre encodage (UTF-8 j&#8217;ai dis !) déclaré en haut du <code>fichier.py</code>: <code># -*- coding: utf-8 -*-</code></p>
<h3>Vérifiez que les textes en entrée sont dans l&#8217;encodage prévu</h3>
<p>Le contenu des bases de données ne sont parfois pas dans l&#8217;encodage déclaré de la table ou de la base. Le contenu d&#8217;une page HTML n&#8217;est parfois pas encodé dans l&#8217;encodage déclaré dans le HEAD. Le contenu d&#8217;un fichier n&#8217;est parfois pas encodé dans l&#8217;encodage par défaut de votre OS.</p>
<p>Il n&#8217;y a pas de secret. Pas de moyen infaillible de détection automatique. Il faut vérifier.</p>
<h3>Vous confondez encodage et décodage (Python 2.7 et moins)</h3>
<p>En Python, on DECODE pour passer d&#8217;un texte en encodé (UTF8, ISO-8859, CP1552, etc) et donc de type &#8216;str&#8217; c&#8217;est à dire un flux de bits, à un texte unicode, une représentation interne, un objet non imprimable. Il est recommandé de décoder tout texte venant d&#8217;une source extérieur à votre programme, pour tout uniformiser.</p>
<p>A l&#8217;inverse, on ENCODE pour passer du type &#8216;unicode&#8217; à un type &#8216;str&#8217;. Il <strong>obligatoire</strong> d&#8217;encoder un texte pour le communiquer au monde extérieur. Si vous ne le faites pas manuellement, Python le fera automatiquement, en essayant de deviner. Il n&#8217;est pas excellent à deviner.</p>
<p>En résumé:</p>
<pre lang="python">In [7]: texte = open('/etc/fstab').read() # ou un téléchargement, ou une requete SQL...
In [8]: type(texte)
Out[8]: str
In [9]: texte = texte.decode('UTF8')
In [10]: type(texte)
Out[10]: unicode
In [11]: print texte # encode automatiquement le texte car votre terminal ne comprend qu'un text encodé
# /etc/fstab: static file system information.
#
[.............]
In [12]: type(texte.encode('UTF8')) # à faire avant de faire un write
Out[12]: str</pre>
<p>Si ça continue de foirer, prenez tous les fichiers de votre application un par un: changez toutes les strings en unicode (les précéder d&#8217;un &#8220;u&#8221;), assurez vous que tout ce qui entre est converti en unicode (unicode() après urllib, open, etc) et tout ce qui sort est converti dans un encodage adapté (souvent UTF8) (encode(&#8216;UTF-8&#8217;) avant send(), write() ou print).</p>
<p>Si ça ne marche toujours pas, embauchez un mec comme moi qui est payé cher pour se taper la tête contre les murs à la place des autres.</p>
<h2>TypeError: &#8216;int&#8217; object has no attribute &#8216;__getitem__&#8217; et autres erreurs sur les tuples</h2>
<h3>Tuples d&#8217;un seul élément</h3>
<p>CECI N&#8217;EST PAS UN TUPLE: (1)</p>
<p>Ceci est un tuple: (1,)</p>
<pre lang="python">>>> type((1))
<type 'int'>
>>> type((1,))
<type 'tuple'>
>>> t = (1,)
>>> t[0]
1
>>> t = (1)
>>> t[0]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'int' object has no attribute '__getitem__'</pre>
<p>Et il y a plus vicieux:</p>
<pre lang="python">
>>> a = ("12345")
>>> b = ("12345",)
>>> a[0]
'1'
>>> b[0]
'12345'
</pre>
<p>C&#8217;est très dur à débugguer car on dans les deux cas il n&#8217;y a pas d&#8217;erreur étant donné que c&#8217;est une opération tout à fait légitime.</p>
<h3>Concaténation automatique</h3>
<p>Python vient avec une fonctionnalité qui concatène automatiquement les descriptions littérales de chaînes de caractères:</p>
<pre lang="python">>>> "Ceci est un"                                  " test"
'Ceci est un test'</pre>
<p>C&#8217;est très pratique pour les chaînes longues:</p>
<pre lang="python">>>> print ("Ceci est une chaîne longue "
... "et je peux la diviser sur plusieurs lignes"
... " sans me fouler")
'Ceci est une chaîne longue et je peux la diviser sur plusieurs lignes sans me fouler'</pre>
<p>Mais si vous oubliez une virgule dans un tuple (par exemple dans <code>INSTALLED_APPS</code> dans le fichier de <code>settings.py</code> de Django):</p>
<pre lang="python">>>> REGLES = (
...     "Ne jamais parler du fight club",
...     "Ne jamais croiser les effluves",
...     "Ne jamais appuyer sur le petit bouton rouge" # <===== virgule oubliée !
...     "Ne jamais goûter"
... )
>>> print REGLES[3]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: tuple index out of range
>>> print REGLES[-1]
Ne jamais appuyer sur le petit bouton rougeNe jamais goûter</pre>
<h2>Le fichier/la liste est vide</h2>
<p><a href="http://sametmax.com/python-love-les-listes-en-intention-partie-2/">On ne peut lire qu&#8217;une seule fois les générateurs en Python</a>.</p>
<p>Si vous faites:</p>
<pre lang="python">toto = (blague.title() for blague in histoire)</pre>
<p>ou</p>
<pre lang="python">toto = open('histoire.txt')</pre>
<p>Et ensuite:</p>
<pre lang="python">for blague in toto:
    print toto

len(list(toto))</pre>
<p>La dernière ligne ne marchera pas. Toto aura été vidé par la première boucle for. Si vous souhaitez utiliser plusieurs fois le résultat de votre générateur, il faut le transformer en liste:</p>
<pre lang="python">toto = list(toto)
for blague in toto:
    print toto

len(list(toto))</pre>
<p>Attention, car vous avez maintenant l&#8217;intégralité des données chargées en RAM.</p>
<h2>TypeError: ma_function() takes exactly x argument (y given)</h2>
<p>Cette erreur est très explicite, et la plupart du temps ne pose aucun problème: vérifiez que vous passez le bon nombre d&#8217;arguments à la fonction. Faites particulièrement attention si vous utilisez <a href="http://sametmax.com/operateur-splat-ou-etoile-en-python/">l&#8217;opérateur splat</a>.</p>
<p>Il existe néanmoins un cas particulier un peu taquin:</p>
<pre lang="python">
>>> class Americaine(object):
...     def dernier_mot(mot):
...         print mot
... 
>>> homme_le_plus_classe_du_monde = Americaine()
>>> homme_le_plus_classe_du_monde.dernier_mot("Monde de merde !")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: dernier_mot() takes exactly 1 argument (2 given)
</pre>
<p>On définie une seul argument (<code>mot</code>) et on en passe un seul (<code>"Monde de merdes !"</code>), alors pourquoi Python n&#8217;est pas d&#8217;accord ?</p>
<p>C&#8217;est parce que l&#8217;on déclare une méthode sans <code>self</code> dans la signature. Or Python va passer automatiquement (et de manière invisible) la référence à l&#8217;objet courrant en premier argument, du coup la méthode reçoit deux arguments: la référence à <code>homme_le_plus_classe_du_monde</code> et <code>"Monde de merde !"</code>. Ca ne marche pas puisque la méthode est déclarée pour n&#8217;accepter qu&#8217;un seul argument.</p>
<p>Il y a deux solutions. La plus simple, ajoutez <code>self</code>:</p>
<pre lang="python">
>>> class Americaine(object):
...     def dernier_mot(self, mot):
...         print mot
... 
>>> homme_le_plus_classe_du_monde = Americaine()
>>> homme_le_plus_classe_du_monde.dernier_mot("Monde de merde !")
Monde de merde !
</pre>
<p>Une seconde solution consiste à déclarer une méthode statique. Du coup on a plus besoin d&#8217;instance:</p>
<pre lang="python">
>>> class Americaine(object):
...     @staticmethod
...     def dernier_mot(mot):
...         print mot
... 
>>> Americaine.dernier_mot("Monde de merde !")
Monde de merde !
</pre>
<h2>Ma structure de données par défaut n&#8217;est pas la bonne</h2>
<p>Piège classique en Python, qu&#8217;il est important de répéter encore et encore tant il est la source de frustration chez les personnes qui ne le connaissent pas.</p>
<pre lang="python">
>>> from random import choice
>>> def bioman(forces=['rouge', 'bleu', 'vert', 'rose', 'jaune devant, marron derriere'], invite=None):
...     if invite is not None:
...         forces.append(invite)
...     return choice(forces)
... 
>>> bioman()
'rose'
>>> bioman()
'rouge'
>>> bioman(invite='magenta a pois gris')
'vert'
>>> bioman()
'jaune devant, marron derriere'
>>> bioman() # WTF ??????????
'magenta a pois gris'
</pre>
<p>Dans le dernier appel &#8216;magenta a pois gris&#8217; est tiré au sort alors qu&#8217;on ne l&#8217;a pas passé en paramètre. Comment cela est-il possible ?</p>
<p>Cela vient du fait que les paramètres par défaut sont initialisés <strong>une seule fois</strong> pour tout le programme: dès que le module est chargé.</p>
<p>Si vous utilisez un objet mutable (liste, set, dico) et que vous le modifiez (ici avec <code>append</code>), le prochain appel de la fonction utilisera toujours la référence de cet objet, et donc de sa versio modifiée.</p>
<p>La solution est soit de ne pas utiliser d&#8217;objet mutable (tuple, strings, int, etc), soit de ne pas modifier l&#8217;objet:</p>
<pre lang="python">
>>> def bioman(forces=('rouge', 'bleu', 'vert', 'rose', 'jaune devant, marron derriere'), invite=None):
...     if invite is not None:
...         forces += (invite,) # ne modifie pas l'ancien objet
...     return choice(forces)
</pre>
<p>Ou alors (et ceci est souvent utilisé même si c&#8217;est moche):</p>
<pre lang="python">
>>> def bioman(forces=None, invite=None):
...     if forces is None:
...        forces = ['rouge', 'bleu', 'vert', 'rose', 'jaune devant, marron derriere']
...     if invite is not None:
...         forces.append(invite)
...     return choice(forces)
</pre>
<p>Toutes les parties qui sont éxécutées à l&#8217;inialisation du code (en opposition à celles qui le sont à l&#8217;appel du code) sont concernées par ce problème: les paramètres par défaut, les variables à la racine des modules, les attributs de classe déclarés <strong>en dehors</strong> d&#8217;une méthode, etc.</p>
<p><strong>ItZ naute a beuhgue, Itse fitiure</strong></p>
<p>Néanmoins cela a aussi son utilité. On peut en effet l&#8217;utiliser pour partager des états:</p>
<pre lang="python">
class Model(object):
    _pool = {
        'mysql': MySQL().connect('test'),
        'sqlite': Sqlite.open('test.db')
    }
    default_connection = 'mysql'

    def query(self, connection=default_connection, *params):
        connection.super_query(*params)
</pre>
<p>Et vous avez maintenant une classe de modèle qui gère plusieurs connections. Si vous l&#8217;étendez, les enfants de la classe et toutes les instances partageront le même objet connection, mais tout le reste sera unique à chacun d&#8217;eux. Cela évite un effet de bord du singleton qui oblige à partager un état et une identité. Ici on ne partage que la partie de l&#8217;état que l&#8217;on souhaite, et pas l&#8217;identité.</p>
<p>On gagne sur les deux tableaux: si on update la connection MySQL (par exemple parcequ&#8217;on a détecté qu&#8217;elle était stale), toutes les instances ont accès à l&#8217;objet modifé. Mais si on veut overrider la connection pour une seule classe, on peut le faire sans affecter les autres simplement en remplaçant l&#8217;objet à la déclaration de la classe.</p>
<p>On peut aussi utiliser cette fonctionnalité pour créer un cache. On appelle ça &#8220;mémoiser&#8221;:</p>
<pre lang="python">
def fonction_lente(param1, param2, _cache={}):
    # les tuples peuvent être des clés de dico \o/
    key = (param1, param2)
    if key not in _cache:
        _cache[key] = process_lent(param1, param2)
    return _cache[key]
</pre>
<p>Tous les résultats sont alors stockés en mémoire vive.</p>
]]></content:encoded>
			<wfw:commentRss>http://sametmax.com/quelques-erreurs-tordues-et-leurs-solutions-en-python/feed/</wfw:commentRss>
		<slash:comments>23</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">995</post-id><enclosure url="http://sametmax.com/wp-content/uploads/2012/06/Funny-Batman-Pictures-103.jpg" length="69437" type="image/jpg" />	</item>
	</channel>
</rss>
