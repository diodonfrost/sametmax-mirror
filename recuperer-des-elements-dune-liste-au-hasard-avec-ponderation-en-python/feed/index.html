<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" 
	>
<channel>
	<title>Comments on: Récupérer des éléments d&#8217;une liste au hasard avec pondération en python</title>
	<atom:link href="http://sametmax.com/recuperer-des-elements-dune-liste-au-hasard-avec-ponderation-en-python/feed/" rel="self" type="application/rss+xml" />
	<link>http://sametmax.com/recuperer-des-elements-dune-liste-au-hasard-avec-ponderation-en-python/</link>
	<description>Du code, du cul</description>
	<lastBuildDate>Fri, 06 Sep 2019 09:34:15 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.7</generator>
	<item>
		<title>By: Gaga</title>
		<link>http://sametmax.com/recuperer-des-elements-dune-liste-au-hasard-avec-ponderation-en-python/#comment-1819</link>
		<dc:creator><![CDATA[Gaga]]></dc:creator>
		<pubDate>Wed, 12 Sep 2012 18:50:17 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=2034#comment-1819</guid>
		<description><![CDATA[&lt;span class=&quot;merci&quot;&gt;&lt;span&gt;Salaud*, pas salop ;)]]></description>
		<content:encoded><![CDATA[<p><span class="merci"><span>Salaud*, pas salop ;)</span></span></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Réchèr</title>
		<link>http://sametmax.com/recuperer-des-elements-dune-liste-au-hasard-avec-ponderation-en-python/#comment-1749</link>
		<dc:creator><![CDATA[Réchèr]]></dc:creator>
		<pubDate>Fri, 07 Sep 2012 22:22:34 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=2034#comment-1749</guid>
		<description><![CDATA[De rien m&#039;sieur Maxou. C&#039;est fait avec amour et avec du beurre.

La solution de GM marche bien aussi. Plus rapide à l&#039;exécution, mais plus consommateur de mémoire. On retrouve l&#039;éternel choix cornélien du programmeur : le temps ou la mémoire ?

Bon de toutes façons, Corneille, il est tellement mort que maintenant, c&#039;est un chanteur.]]></description>
		<content:encoded><![CDATA[<p>De rien m&#8217;sieur Maxou. C&#8217;est fait avec amour et avec du beurre.</p>
<p>La solution de GM marche bien aussi. Plus rapide à l&#8217;exécution, mais plus consommateur de mémoire. On retrouve l&#8217;éternel choix cornélien du programmeur : le temps ou la mémoire ?</p>
<p>Bon de toutes façons, Corneille, il est tellement mort que maintenant, c&#8217;est un chanteur.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: GM</title>
		<link>http://sametmax.com/recuperer-des-elements-dune-liste-au-hasard-avec-ponderation-en-python/#comment-1748</link>
		<dc:creator><![CDATA[GM]]></dc:creator>
		<pubDate>Fri, 07 Sep 2012 19:36:33 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=2034#comment-1748</guid>
		<description><![CDATA[Pour éviter la boucle de tirage de Recher, on peut mixer les deux solutions :

1) Construire le ruban sous forme de liste pondérée :
items = [&#039;server1&#039;] * 10 + [&#039;server2&#039;] * 45 + [&#039;server3&#039;] * 34
2) Ne pas mélanger
3) Choisir un nombre x au hasard entre 0 et 88, et retourner items[x].

Avec un yield au bon endroit, ça doit marcher.]]></description>
		<content:encoded><![CDATA[<p>Pour éviter la boucle de tirage de Recher, on peut mixer les deux solutions :</p>
<p>1) Construire le ruban sous forme de liste pondérée :<br />
items = [&#8216;server1&#8217;] * 10 + [&#8216;server2&#8217;] * 45 + [&#8216;server3&#8217;] * 34<br />
2) Ne pas mélanger<br />
3) Choisir un nombre x au hasard entre 0 et 88, et retourner items[x].</p>
<p>Avec un yield au bon endroit, ça doit marcher.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Max</title>
		<link>http://sametmax.com/recuperer-des-elements-dune-liste-au-hasard-avec-ponderation-en-python/#comment-1747</link>
		<dc:creator><![CDATA[Max]]></dc:creator>
		<pubDate>Fri, 07 Sep 2012 19:01:49 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=2034#comment-1747</guid>
		<description><![CDATA[merci François mais je n&#039;aime pas trop dépendre de tout un tas de libs, surtout pour de si petits bouts de codes, après on se retrouve avec des tas de dépendances parfois plus compatibles lors de mises à jour. 
Je vais quand même voir de plus près cette lib pour ce qu&#039;elle apporte d&#039;autre.]]></description>
		<content:encoded><![CDATA[<p>merci François mais je n&#8217;aime pas trop dépendre de tout un tas de libs, surtout pour de si petits bouts de codes, après on se retrouve avec des tas de dépendances parfois plus compatibles lors de mises à jour.<br />
Je vais quand même voir de plus près cette lib pour ce qu&#8217;elle apporte d&#8217;autre.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Max</title>
		<link>http://sametmax.com/recuperer-des-elements-dune-liste-au-hasard-avec-ponderation-en-python/#comment-1746</link>
		<dc:creator><![CDATA[Max]]></dc:creator>
		<pubDate>Fri, 07 Sep 2012 18:59:15 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=2034#comment-1746</guid>
		<description><![CDATA[merci recher pour ton code ça fait plaisir ^^

En effet c&#039;est bourrin ce que j&#039;ai fais, pour ça que je demandais une idée alternative et mon crie de désespoir a fini par carresser le cil de ton oreille interne, Amen...

Je suis d&#039;accord pour la confusion en première partie, c&#039;est effet l&#039;espace disque occupé en %, pour ça que je fais un 100-weight ensuite.

Merci en tous cas pour ton code, je le rajoute en edit pour pas le perdre ;)]]></description>
		<content:encoded><![CDATA[<p>merci recher pour ton code ça fait plaisir ^^</p>
<p>En effet c&#8217;est bourrin ce que j&#8217;ai fais, pour ça que je demandais une idée alternative et mon crie de désespoir a fini par carresser le cil de ton oreille interne, Amen&#8230;</p>
<p>Je suis d&#8217;accord pour la confusion en première partie, c&#8217;est effet l&#8217;espace disque occupé en %, pour ça que je fais un 100-weight ensuite.</p>
<p>Merci en tous cas pour ton code, je le rajoute en edit pour pas le perdre ;)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Kontre</title>
		<link>http://sametmax.com/recuperer-des-elements-dune-liste-au-hasard-avec-ponderation-en-python/#comment-1745</link>
		<dc:creator><![CDATA[Kontre]]></dc:creator>
		<pubDate>Fri, 07 Sep 2012 17:01:05 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=2034#comment-1745</guid>
		<description><![CDATA[D&#039;accord avec l&#039;algo de Recher. On doit même pouvoir faire une recherche par dichotomie pour aller un peu plus vite dans le &quot;ruban&quot;.
C&#039;est au passage la manière de faire un tirage avec une loi de probabilité quelconque.]]></description>
		<content:encoded><![CDATA[<p>D&#8217;accord avec l&#8217;algo de Recher. On doit même pouvoir faire une recherche par dichotomie pour aller un peu plus vite dans le &#8220;ruban&#8221;.<br />
C&#8217;est au passage la manière de faire un tirage avec une loi de probabilité quelconque.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Xavier Combelle</title>
		<link>http://sametmax.com/recuperer-des-elements-dune-liste-au-hasard-avec-ponderation-en-python/#comment-1744</link>
		<dc:creator><![CDATA[Xavier Combelle]]></dc:creator>
		<pubDate>Fri, 07 Sep 2012 16:30:02 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=2034#comment-1744</guid>
		<description><![CDATA[En fait je pense que c&#039;est plutot O(ln(N)) où N est le nombre d&#039;élément (recherche binaire)]]></description>
		<content:encoded><![CDATA[<p>En fait je pense que c&#8217;est plutot O(ln(N)) où N est le nombre d&#8217;élément (recherche binaire)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sam</title>
		<link>http://sametmax.com/recuperer-des-elements-dune-liste-au-hasard-avec-ponderation-en-python/#comment-1743</link>
		<dc:creator><![CDATA[Sam]]></dc:creator>
		<pubDate>Fri, 07 Sep 2012 16:27:27 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=2034#comment-1743</guid>
		<description><![CDATA[Y a la bouton &quot;force coloration&quot; qui pallie à ça.

Pour le reste, je laisse l&#039;auteur du code répondre ^^]]></description>
		<content:encoded><![CDATA[<p>Y a la bouton &#8220;force coloration&#8221; qui pallie à ça.</p>
<p>Pour le reste, je laisse l&#8217;auteur du code répondre ^^</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Xavier Combelle</title>
		<link>http://sametmax.com/recuperer-des-elements-dune-liste-au-hasard-avec-ponderation-en-python/#comment-1742</link>
		<dc:creator><![CDATA[Xavier Combelle]]></dc:creator>
		<pubDate>Fri, 07 Sep 2012 16:27:17 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=2034#comment-1742</guid>
		<description><![CDATA[L&#039;avantage de la méthode scipy c&#039;est que distrib.rvs() est en O(1) si elle est bien foutue]]></description>
		<content:encoded><![CDATA[<p>L&#8217;avantage de la méthode scipy c&#8217;est que distrib.rvs() est en O(1) si elle est bien foutue</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Recher</title>
		<link>http://sametmax.com/recuperer-des-elements-dune-liste-au-hasard-avec-ponderation-en-python/#comment-1741</link>
		<dc:creator><![CDATA[Recher]]></dc:creator>
		<pubDate>Fri, 07 Sep 2012 16:24:56 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=2034#comment-1741</guid>
		<description><![CDATA[&lt;span class=&quot;merci&quot;&gt;&lt;/span&gt;&lt;strong&gt;Première remarque : &lt;/strong&gt;

il y a une légère confusion sur les termes &quot;place_restante&quot; et &quot;poids en %&quot;.

J&#039;ai vaguement l&#039;impression que la valeur dans la liste initiale représente la place &lt;strong&gt;occupée&lt;/strong&gt;, et non pas la place &lt;strong&gt;restante&lt;/strong&gt;. Si ce n&#039;est pas ça, comment expliquer que le nombre d&#039;élément ajouté dans la liste items est &quot;100-weight&quot;, alors que ça devrait être, tout simplement, &quot;weight&quot;.


&lt;strong&gt;Deuxième remarque : &lt;/strong&gt;

Permettez-moi de trouver ça bourrin. Si il y a, ne serait-ce que 20 serveurs, on peut très vite avoir une liste &quot;items&quot; de plusieurs centaines d&#039;éléments. Un shuffle là-dessus, ce n&#039;est pas anodin, et ça prend un certain temps. Tout ça pour choisir des trucs au hasard. Hem...

Pour Blarg, (mon superbe jeu vidéo), j&#039;ai eu besoin de générer des nombres aléatoires pondérés. Je l&#039;ai fait de la manière suivante.

 - Initialement, on a une liste de coefficient. Par exemple : (7, 3, 0, 20, 5). Cela signifie qu&#039;on veut générer un nombre aléatoire entre 0 et 4, avec les poids de la liste. (Dans notre exemple, le nombre 2 ne sortira jamais, puisqu&#039;il a un poids de 0).
 
 - L&#039;idée, c&#039;est de voir cette liste comme un grand ruban, avec des morceaux de taille différente mis bout à bout. On choisit un point au hasard sur le ruban, on regarde à quel morceau il appartient, et ça donne le résultat.
 
 - On calcule la somme des coefs. Ca vaut 35. Cela correspond à la taille du ruban.
 
 - On choisit un nombre au hasard, sans pondération, entre 0 et 34. Cela correspond au point du ruban que l&#039;on a choisi. Mettons qu&#039;on obtienne 15.
 
 - On avance dans le ruban, jusqu&#039;à trouver le morceau appartenant au point. Ca se fait avec une boucle.
 
 --- curseur = 15. morceau courant = le premier. taille du morceau = 7.
 --- 15 &#062; 7. Ce n&#039;est pas le bon morceau. curseur = 15 - 7 = 8
 --- curseur = 8. morceau courant = le 2ème. taille du morceau = 3 
 --- 8 &#062; 3. Ce n&#039;est pas le bon morceau. curseur = 8 - 3 = 5
 --- curseur = 5. morceau courant = le 3ème. taille du morceau = 0
 --- 5 &#062; 0. Ce n&#039;est pas le bon morceau. curseur = 5 - 0 = 5
 --- curseur = 5. morceau courant = le 4ème. taille du morceau = 20
 --- 5 &#060;= 20. C&#039;est le bon morceau.

 - On renvoie la valeur 4.

Il suffit, ensuite, de choisir le serveur correspondant à l&#039;index 4.

On recommence le même process autant de fois que nécessaire. Pas besoin de module de statistiques compliqué, pas besoin de créer une grande liste. Les seules actions lentes, c&#039;est le random.randrange (mais c&#039;est un peu inévitable quand on veut choisir des trucs au hasard), ainsi que la boucle pour avancer dans le ruban. 

Si on est puriste, on classe la liste de coef par ordre décroissant. Cela permet de faire moins d&#039;itérations dans la boucle, à chaque tirage. On a plus de chances de tomber immédiatement sur le morceau de ruban choisi. Il faut juste garder quelque part une correspondance entre la liste de coef initiale et la liste de coef classée.

Et voici le pastebin &#034;kivabien&#034;.
http://is.gd/b3GbA4

Votre biniou de 0bin n&#039;a pas détecté que c&#039;était du python, et ne me l&#039;a pas syntaxiquement coloré. C&#039;est bien dommage. Tant pis, vous vous abîmerez les yeux !]]></description>
		<content:encoded><![CDATA[<p><span class="merci"></span><strong>Première remarque : </strong></p>
<p>il y a une légère confusion sur les termes &#8220;place_restante&#8221; et &#8220;poids en %&#8221;.</p>
<p>J&#8217;ai vaguement l&#8217;impression que la valeur dans la liste initiale représente la place <strong>occupée</strong>, et non pas la place <strong>restante</strong>. Si ce n&#8217;est pas ça, comment expliquer que le nombre d&#8217;élément ajouté dans la liste items est &#8220;100-weight&#8221;, alors que ça devrait être, tout simplement, &#8220;weight&#8221;.</p>
<p><strong>Deuxième remarque : </strong></p>
<p>Permettez-moi de trouver ça bourrin. Si il y a, ne serait-ce que 20 serveurs, on peut très vite avoir une liste &#8220;items&#8221; de plusieurs centaines d&#8217;éléments. Un shuffle là-dessus, ce n&#8217;est pas anodin, et ça prend un certain temps. Tout ça pour choisir des trucs au hasard. Hem&#8230;</p>
<p>Pour Blarg, (mon superbe jeu vidéo), j&#8217;ai eu besoin de générer des nombres aléatoires pondérés. Je l&#8217;ai fait de la manière suivante.</p>
<p> &#8211; Initialement, on a une liste de coefficient. Par exemple : (7, 3, 0, 20, 5). Cela signifie qu&#8217;on veut générer un nombre aléatoire entre 0 et 4, avec les poids de la liste. (Dans notre exemple, le nombre 2 ne sortira jamais, puisqu&#8217;il a un poids de 0).</p>
<p> &#8211; L&#8217;idée, c&#8217;est de voir cette liste comme un grand ruban, avec des morceaux de taille différente mis bout à bout. On choisit un point au hasard sur le ruban, on regarde à quel morceau il appartient, et ça donne le résultat.</p>
<p> &#8211; On calcule la somme des coefs. Ca vaut 35. Cela correspond à la taille du ruban.</p>
<p> &#8211; On choisit un nombre au hasard, sans pondération, entre 0 et 34. Cela correspond au point du ruban que l&#8217;on a choisi. Mettons qu&#8217;on obtienne 15.</p>
<p> &#8211; On avance dans le ruban, jusqu&#8217;à trouver le morceau appartenant au point. Ca se fait avec une boucle.</p>
<p> &#8212; curseur = 15. morceau courant = le premier. taille du morceau = 7.<br />
 &#8212; 15 &gt; 7. Ce n&#8217;est pas le bon morceau. curseur = 15 &#8211; 7 = 8<br />
 &#8212; curseur = 8. morceau courant = le 2ème. taille du morceau = 3<br />
 &#8212; 8 &gt; 3. Ce n&#8217;est pas le bon morceau. curseur = 8 &#8211; 3 = 5<br />
 &#8212; curseur = 5. morceau courant = le 3ème. taille du morceau = 0<br />
 &#8212; 5 &gt; 0. Ce n&#8217;est pas le bon morceau. curseur = 5 &#8211; 0 = 5<br />
 &#8212; curseur = 5. morceau courant = le 4ème. taille du morceau = 20<br />
 &#8212; 5 &lt;= 20. C&#039;est le bon morceau.</p>
<p> &#8211; On renvoie la valeur 4.</p>
<p>Il suffit, ensuite, de choisir le serveur correspondant à l&#039;index 4.</p>
<p>On recommence le même process autant de fois que nécessaire. Pas besoin de module de statistiques compliqué, pas besoin de créer une grande liste. Les seules actions lentes, c&#039;est le random.randrange (mais c&#039;est un peu inévitable quand on veut choisir des trucs au hasard), ainsi que la boucle pour avancer dans le ruban. </p>
<p>Si on est puriste, on classe la liste de coef par ordre décroissant. Cela permet de faire moins d&#039;itérations dans la boucle, à chaque tirage. On a plus de chances de tomber immédiatement sur le morceau de ruban choisi. Il faut juste garder quelque part une correspondance entre la liste de coef initiale et la liste de coef classée.</p>
<p>Et voici le pastebin &quot;kivabien&quot;.<br />
<a href="http://is.gd/b3GbA4" rel="nofollow">http://is.gd/b3GbA4</a></p>
<p>Votre biniou de 0bin n&#039;a pas détecté que c&#039;était du python, et ne me l&#039;a pas syntaxiquement coloré. C&#039;est bien dommage. Tant pis, vous vous abîmerez les yeux !</p>
]]></content:encoded>
	</item>
</channel>
</rss>
